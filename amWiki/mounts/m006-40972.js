if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m006']=[{"name":"01-基础篇.md","path":"006-MySQL/01-基础篇.md","content":"## 执行一条查询语句流程\n\n![查询语句执行流程](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/08/13522416914739441691473944041VX9yWt-mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)\n\n```\n（1）连接器：简历连接，管理连接、校验用户身份\n（2）查询缓存：如果命中，直接返回（mysql8.0后移除）\n（3）解析器：\n\t\t- 词法分析：提取关键字、表名、字段名、查询条件\n\t\t- 语法分析：判断sql是否正确\n（4）优化器：选择最优的方案执行：如何选择索引？如何关联表的顺序？\n（5）执行器：调用引擎接口，返回结果\n```\n\n## 为什么移除查询缓存？\n\n\n\n## InnoDB 与 MyISAM 的区别 x *\n\n```\n（1）事务：InnoDB 支持事务，拥有错误回滚的能力；MyISAM 不支持事务 \n（2）锁：InnoDB 支持表、行级锁，拥有更好的并发性能；而 MyISAM 支持表级锁，锁的粒度较大。 \n（3）崩溃恢复：InnoDB引引擎通过 redolog 日志实现了崩溃恢复，可以在数据库发生异常情况（如断电）时，通过日志文件进行恢复，保证数据的持久性和一致性。Myisam是不支持崩溃恢复的。\n（4）MVCC：InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持 \n\nInnoDB 支持外键，MyISAM 不支持外键 \nselect count(*) from table 时，MyISAM 更快，因为它有一个变量保存了整个 表的总行数，可以直接读取，InnoDB 就需要全表扫描。 \nInnodb 不支持全文索引，而 MyISAM 支持全文索引（5.7 以后的 InnoDB 也支持 全文索引） \nInnoDB 表必须有主键，而 MyISAM 可以没有主键 Innodb 表需要更多的内存和存储，而 MyISAM 可被压缩，存储空间较小，。 \nInnodb 按主键大小有序插入，MyISAM 记录插入顺序是，按记录插入顺序保存。 \n```\n\n\n\n## [MySQL事务的12连问，你顶得了嘛](https://juejin.cn/post/7204010536765194277) TODO\n\n## [SQL优化13连问，收藏好](https://juejin.cn/post/7208571916154847288) TODO\n\nhttps://juejin.cn/post/7199666255884009532\n\nhttps://juejin.cn/post/7193682380077400122","timestamp":1694515333622},{"name":"02-索引.md","path":"006-MySQL/02-索引.md","content":"## 什么是索引？\n\n```\n（1）索引是一种用于快速查询和检索数据的数据结构，形象的说就是索引是数据的目录。\n（2）一般存储在磁盘的文件中，会占用物理空间\n（3）适当的索引可以提高查询效率，过多的索引会导致效率下降，增加内存使用。\n\n索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。\n在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。\n```\n\n## 索引的优缺点\n\n```\n优点：\n（1）主要原因：可以大大加快数据的检索速度\n（2）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性\n\n缺点：\n（1）耗费时间：创建索引和维护索引需要耗费时间。当对表中数据进行增删改时，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率\n（2）耗费空间：索引需要使用物理文件存储，会耗费一定的空间\n```\n\n\n\n\n\n## 索引底层数据结构选型\n\n### Hash表\n\n```\n哈希表是键值对集合，检索的速度很快。\n但是Hash可能会存在hash冲突，需要链地址等方法来解决\n不选择hash表作为索引的主要原因是：hash索引不支持顺序和范围查询\n```\n\n### 二叉查找树(BST)\n\n```\n（1）是一种基于二叉树的数据结构，它的左子树 < 根 < 右子树，\n（2）当二叉查找树平衡时，查找效率比较高，为log2（N），但特殊情况下会退化成链表，时间复杂度就是O（n）\n```\n\n### AVL树\n\n```\n（1）是一种自平衡二叉查找树，特点是保证任何节点的左右子树高度之差不超过 1，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。\n（2）AVL树需要通过旋转来保持平衡，会有较大的计算开销而降低查找性能。\n（3）每个树节点只存一个数据，而每次磁盘IO只能读取一个节点的数据，如果要查询的数据分布在多个节点，那么就需要进行多次磁盘IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。\n```\n\n### 红黑树 \n\n```\n（1）是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态\n（2）红黑树不要求严格的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因\n\n\n是一种自平衡二叉查找树，它通过引入额外的颜色属性（红或黑）来保持树的平衡，从而确保查找、插入和删除操作的高效性\n特点：\n（1）（颜色属性）节点非黑即红\n（2）（根属性）根节点一定是黑色\n（3）（叶子属性）叶子节点（NIL）一定是黑色\n（4）（红色属性）每个红色节点的两个子节点，都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)\n（5）（黑色属性）从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。\n\nhttps://javaguide.cn/database/mysql/mysql-index.html#红黑树\n```\n\n### B 树& B+树\n\n```\n（1）数据存放：\n\t- B 树的所有节点既存放键(key) 也存放数据(data)\n\t- B+树只有叶子节点存放 key 和 data，其他节点只存放 key。\n\t\n（2）叶子结点\n\t- B 树的叶子节点都是独立的;\n\t- B+树的叶子节点有一条引用链指向与它相邻的叶子节点。\n\n（3）范围查找：\n\t- 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；\n\t- B+树的范围查询，只需要对链表进行遍历即可。\n\t\n（4）磁盘IO次数更少\n\t- B树的非叶子结点也存放数据，和B+树相比，相同的页大小（16kb）B+树就能存储更多的键值，树就会更矮更胖，这样一来，查找数据进行的磁盘IO次数也就会减少，效率更快。\n\nhttps://javaguide.cn/database/mysql/mysql-index.html#b-树-b-树\n```\n\n\n\n## 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？ \n\n可以从这几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数等等。\n\n为什么不是哈希结构？为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？\n\n```\nHash\n（1）Hash等值查询效率很高，但无法范围查询\n\n 二叉树\n （1）极端情况下会退化为链表\n （2）数据量多时，磁盘IO多\n \n 平衡二叉树\n （1）插入、更新时，需要左旋右旋维持平衡，维护代价大\n （2）数据量大，树的高度高，磁盘IO多\n \n B树\n （1）B+树只在在叶子节点存放数据，B树在非叶子节点也存放数据，存储相同数据量级别的情况下，B+树比B树低，磁盘IO次数更少。（innoDB页大小默认16kb，不存数据就能存更多键值）\n （2）B+树叶子结点用双向链表连接，适合范围查询、排序查找；B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。\n```\n\n\n\n参考：\n\n-   [阿里一面](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247488130&idx=1&sn=2f225ba5100c882089eec8a2666fee54&chksm=cf21cdabf85644bd91c8f0bc223d883a53896f3bd71e06a4167e050155fe64f55872c7ad97d8&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)\n-   [为什么 MySQL 喜欢 B+ 树？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247502168&idx=1&sn=ff63afcea1e8835fca3fe7a97e6922b4&scene=21#wechat_redirect)\n\n\n\n## 索引的分类\n\n```\n按「数据结构」分类：B+tree索引、Hash索引、全文索引。\n按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。\n按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。\n按「字段个数」分类：单列索引、联合索引。\n```\n\n\n\n## 主键索引\n\n```\n主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。\n```\n\n##  二级索引\n\n```\n二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。\n\n唯一索引，普通索引，前缀索引等索引属于二级索引。\n```\n\n\n\n## 聚簇索引与非聚簇索引\n\n### 聚簇索引（聚集索引）\n\n#### 是什么\n\n```\n索引结构和数据一起存放的索引，并不是一种单独的索引类型。（在B+树中就是非叶子节点存放索引，叶子节点存放索引 + 数据）\n\n有哪些？\n- 主键索引\n```\n\n#### 优缺点\n\n```\n优点：\n（1）查询速度快：由于聚簇索引中的数据行与索引行存储在相同的位置，因此可以加快数据的检索速度。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。\n（2）对排序查找和范围查找，由于数据行在物理上是相邻的，所以效率较高。\n\n缺点：\n（1）依赖性有序的数据。主键最好是整型，如果是字符串，需要在插入时排序，影响插入和查找的效率。\n（2）增删改带索引代价大：聚簇索引的叶子节点存放着数据，索引列修改时，可能需要重新调整整个索引结构。\n```\n\n###  非聚簇索引（非聚集索引）\n\n#### 是什么\n\n```\n索引结构和数据分开存放的索引，并不是一种单独的索引类型\n\n有哪些？\n- 二级索引(辅助索引)\n```\n\n#### 优缺点：\n\n```\n优点：\n- 更新代价比聚簇索引小\n\n缺点\n- 依赖于有序的数据：跟聚簇索引一样，非聚簇索引也依赖于有序的数据\n- 可能会二次查询(回表)： 当查到索引对应的指针或主键后，如果查询的数据不只是索引列，还需要根据指针或主键再到数据文件或表中查询。\n```\n\n### 非聚簇索引一定回表查询吗(覆盖索引)?\n\n```\n如果索引列包含要查询的内容，就不需要回表进行查询数据\n```\n\n### 聚集索引与非聚集索引的区别\n\n```\n（1）存储结构\n\t\t- 聚簇索引：数据表的记录和索引结构是一起存储的。表中的数据行是按照索引的顺序物理存储的\n\t\t- 非聚簇索引：索引结构和数据表记录是分开存储的。非聚集索引只包含索引字段和一个指针到实际记录或聚集索引的指针。\n（2）数量：\n\t\t- 聚簇索引：每个数据表只能有一个聚集索引，因为数据的物理存储顺序只能有一种。\n\t\t- 非聚集索引：在大多数数据库中，一个数据表可以有多个非聚集索引。\n```\n\n\n\n## 覆盖索引和联合索引\n\n### 索引覆盖\n\n```\n如果索引包含要查找的字段的值，就称为索引覆盖\n```\n\n### 联合索引\n\n```\n多个字段创建的索引叫联合索引，也叫 组合索引 或 复合索引。\n```\n\n#### 有这样一个sql，where a > 1 and b = 1 and c > 1怎么创建索引\n\n```\n创建联合索引：bca或者bac\n\n需要考虑哪一列是最具选择性的，即能最有效地缩小结果集的范围。通常，等于操作(=)比范围操作(>, <)更具选择性。\n```\n\n\n\n### 最左前缀匹配原则\n\n```\n（1）在使用联合索引时，会根据索引中的字段顺序，从左至右依次到查询条件中去匹配。\n（2）如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 >、<）才会停止匹配。\n（3）对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。\n\n比如，如果创建了一个 (a, b, c) 联合索引，就相当于建了a, ab, abc三个索引。\n（因为有优化器，a、b、c的顺序可以不固定）\n\n可以利用联合索引：\nwhere a=1；\nwhere a=1 and b=2 and c=3；\nwhere a=1 and b=2；\n\n无法用联合索引：\nwhere b=2；\nwhere c=3；\nwhere b=2 and c=3；\n\nhttps://javaguide.cn/database/mysql/mysql-index.html#联合索引\nhttps://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ\n```\n\n如下语句需要执行多少次树的搜索\n\n```\nname,age字段加上联合索引索引\nselect * from employee where name like \'小%\' order by age desc;\n```\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/18/15225316923433731692343373583J1CqFv-640.png)\n\n```\n联合索引项是先按姓名name从小到大排序，如果名字name相同，则按年龄age从小到大排序。面试官要求查所有名字第一个字是“小”的人，SQL的like \'小%\'是可以用上idx_name_age联合索引的。\n\n该查询会沿着idx_name_age索引树，找到第一个字是小的索引值，因此依次找到小军、小伦、小燕、，分别拿到Id=600、100、700，然后回三次表，去找对应的记录。\n```\n\n[参考](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247488130&idx=1&sn=2f225ba5100c882089eec8a2666fee54&chksm=cf21cdabf85644bd91c8f0bc223d883a53896f3bd71e06a4167e050155fe64f55872c7ad97d8&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)\n\n## 索引下推\n\n```\n是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。\n\n如select * from employee where name like \'小%\' and age=28 and sex=\'0\';\n\n查找到“小”字开头的数据id后就回表找出数据行，再去对比age、sex字段\n索引下推就是会先做判断，直接过滤\n```\n\n## 千万级数据量的表添加索引，如何做？\n\n```\n给表添加索引的时候，是会对表加锁的。如果不谨慎操作，有可能出现生产事故的。可以参考以下方法：\n1.先创建一张跟原表A数据结构相同的新表B。\n2.在新表B添加需要加上的新索引。\n3.把原表A数据导到新表B\n4.rename新表B为原表的表名A，原表A换别的表名；\n```\n\n[参考](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247488130&idx=1&sn=2f225ba5100c882089eec8a2666fee54&chksm=cf21cdabf85644bd91c8f0bc223d883a53896f3bd71e06a4167e050155fe64f55872c7ad97d8&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)\n\n## 正确使用索引的一些建议\n\n### 选择合适的字段创建索引\n\n```\n（1）不为 NULL 的字段： 索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。\n（2）被频繁查询的字段： 我们创建索引的字段应该是查询操作非常频繁的字段。被作为条件查询的字段：被作为 WHERE 条件查询的字段，应该被考虑建立索引。\n（3）频繁需要排序的字段： 索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。\n（4）被经常频繁用于连接的字段：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。\n```\n\n### 被频繁更新的字段应该慎重建立索引\n\n```\n虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。\n```\n\n### 限制每张表上的索引数量\n\n```\n（1）索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。\n（2）索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。\n（3）因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。\n```\n\n### 尽可能的考虑建立联合索引而不是单列索引\n\n```\n（1）索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树\n（2）如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。\n（3）如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。\n```\n\n### 注意避免冗余索引\n\n```\n冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。\n如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。\n```\n\n### 字符串类型的字段使用前缀索引代替普通索引\n\n```\n前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。\n```\n\n### 避免索引失效 x\n\n```\n索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：\n（1）创建了联合索引，但查询条件未遵守最左匹配原则;（查询时的条件列不是联合索引中的第一个列，索引失效）\n（2）在索引列上进行计算、函数、类型转换等操作;\n（3）查询条件导致\n    - 以 % 开头的 LIKE 查询比如 like \'%abc\';\n    - 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;\n\t\t- 索引字段上使用 is not null，可能导致索引失效。（表中null较多就用索引）\t\t\n\t\t- 索引字段上使用（!= 或者 < >，not in）时，可能会导致索引失效。\t \n（4）发生隐式转换; \n\t\t- 字符串和数字比较：select * from t_user where varchar类型 = 1300000001;\n\t\t- 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。\n\t\t\nhttps://xiaolincoding.com/mysql/index/index_lose.html#索引存储结构长什么样\n\n```\n\n[田螺：后端程序员必备：索引失效的十大杂症](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487958&idx=1&sn=ac9137cfed0b9383d87cd77a0f417487&chksm=cf21cefff85647e947e072765dea74f388c37d44d920e7f148e113a06ea42f7721058b14bb5b&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)\n\n\n\n为什么索引字段上使用（!= 或者 < >，not in）时，可能会导致索引失效（ is not null 同理）\n\n```\n当你使用!=或<>时，你实际上是在查找除某个值之外的所有其他值。在许多情况下，MySQL认为最有效的方法是进行全表扫描而不是使用索引，特别是当这个值在表中不是很常见时。\n\n当你使用IN操作符时，MySQL可能会选择使用索引进行范围扫描。但当你使用NOT IN时，它可能不会这样做，因为你正在查找的是一个值列表之外的所有值，这种情况下，全表扫描可能更加高效。\n```\n\n\n\n### 删除长期未使用的索引\n\n```\n删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。\nMySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用。\n```\n\n## 隐式转换 x\n\n```\n（1）当操作符左右两边的数据类型不一致时，会发生隐式转换。\n（2）当 where 查询操作符左边为数值类型时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。\n（3）当 where 查询操作符左边为字符类型时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。\n（4）字符串转换为数值类型时，非数字开头的字符串会转化为0，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。\n```\n\n\n\n```\n不转换：\n（1）都是字符串，按字符串比，不做类型转换\n（2）都是整数，按整数比，不做类型转换\n\n转换：\n（1）十六进制的值和非数字做比较时，会被当做二进制串\n（2）有一个参数是timestamp或DATETIME，并且另外一个参数是常量，常量会被转换为timestamp\n（3）有一个参数是decimal类型，如果另外一个参数是decimal或者整数，会将整数转换为decimal后进行比较；如果另外一个参数是浮点数，则会把decimal转换为浮点数进行比较\n（4）所有其他情况下，两个参数都会被转换为浮点数再进行比较\n\n转换规则：\n（1）不以数字开头的字符串都将转换为0。如\'abc\'、\'a123bc\'、\'abc123\'都会转化为0；\n（2）以数字开头的字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如\'123abc\'会转换为123，\'012abc\'会转换为012也就是12，\'5.3a66b78c\'会转换为5.3，其他同理。\n```\n\n\n\n\n\n## MySQL 使用 like “%x“，索引一定会失效吗？（最左匹配类似）\n\n```\n如：select * from s where name like \"%xxx\";\n如果数据库里表s只有id字段和name字段，id为主键索引，name为二级索引\nselect * 就相当于 select id，name, 这个查询的数据都在二级索引的B+树上，所以直接在索引树上查找就行。\n（因为二级索引的 B+ 树的叶子节点包含「索引值（name）+主键值」，所以查二级索引的 B+ 树就能查到全部结果了，这个就是覆盖索引。）\n\nhttps://xiaolincoding.com/mysql/index/index_issue.html\n```\n\n为什么选择全扫描二级索引树，而不扫描聚簇索引树呢？\n\n```\n因为二级索引树的记录东西很少，就只有「索引列+主键值」，而聚簇索引记录的东西会更多，比如聚簇索引中的叶子节点则记录了主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列。\n\n再加上，这个 select * 不用执行回表操作。\n\n所以， MySQL 优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多，因此 MySQL 选择了「全扫描二级索引树」的方式查询数据。\n```\n\n为什么这个数据表加了非索引字段，执行同样的查询语句后，怎么变成走的是全表扫描呢？\n\n```\n加了其他字段后，select * from t_user where name like \"%xx\"; 要查询的数据就不能只在二级索引树里找了，得需要回表操作才能完成查询的工作，再加上是左模糊匹配，无法利用索引树的有序性来快速定位数据，所以得在二级索引树逐一遍历，获取主键值后，再到聚簇索引树检索到对应的数据行，这样实在太累了。\n\n所以，优化器认为上面这样的查询过程的成本实在太高了，所以直接选择全表扫描的方式来查询数据。\n```\n\n\n\n## count(*)  &  count(1)  & count（id）& count(字段)\n\n```\nhttps://xiaolincoding.com/mysql/index/count.html\n```\n\n### count() 是什么？\n\n```\n统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。\n```\n\n### 哪种 count 性能最好？\n\n```\ncount(*) = count(1) > count(主键字段) > count(字段)\n```\n\n### count(id) 执行过程是怎样的？\n\n```\n（1）在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。\n（2）server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。\n（3）最后将 count 变量的值发送给客户端。\n\n读取数据时\n如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，\n然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。 【比count(1)多的一步，count(1)不需要读取id来判断】\n但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。\n```\n\n为什么优先选二级索引？\n\n```\n这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。\n```\n\n### count(1) 执行过程是怎样的？\n\nCount(1)是什么\n\n```\n统计「某表中，1 这个表达式不为 NULL 的记录」有多少个\n1 这个表达式就是单纯数字，它永远都不是 NULL，所以其实是在统计表中有多少个记录。\ncount（id）需要读取id值后，判断id是不是null\n```\n\n流程\n\n```\n（1）如果表里只有主键索引，没有二级索引时。InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，「但是不会读取记录中的任何字段的值」。\n因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。\n```\n\n### count（1）比count（id）效率高的原因\n\n```\ncount(1) 相比 count(主键字段) 少一个步骤，不需要读取记录中的字段值来判断主键是否为null，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。\n```\n\n### count(*) 执行过程是怎样的？\n\n```\n当你使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理。\ncount(*) 执行过程跟 count(1) 执行过程基本一样的，性能没有什么差异\n MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。\n 只有当没有二级索引的时候，才会采用主键索引来进行统计。\n```\n\n### count(字段) 执行过程是怎样的？\n\n```\n如果字段没有索引，则会采用全表扫描\n```\n\n### cout为什么要通过遍历的方式来计数？\n\n```\n MyISAM ：\n 数据表都有一个 meta 信息有存储了row_count值，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果\n \n innodb：\n InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的\n 所以需要扫描表来统计具体的记录。\n```\n\n### 如何优化 count(*)？\n\n```\n一张大表经常用 count(*) 来做统计，其实是很不好\n\n（1）近似值：\n如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，使用explain给出的搜索结果条数是一个大概值，explain并不会真正的去查询。\nexplain select count(*) from table_namel\n\n（2）额外表保存计数值\n如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。\n当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。\n```\n\n","timestamp":1694515333622},{"name":"03-事务.md","path":"006-MySQL/03-事务.md","content":"## 事物有哪些特性 ACID\n\n```\n（1）原子性（Atomicity）：事务是最小的执行单位。一个事务中的所有操作，要么都执行，要么都不执行。发生错误时会进行回滚\n（2）一致性（Consistency：执行事务前后，数据保持一致。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；\n（3）隔离性（Isolation）：并发访问数据库时，一个用户的事务不会被其他事物所干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。\n（4）持久性（Durability）：事务处理结束后，对数据的修改是永久的，即使系统故障也不会丢失。\n```\n\n## InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？[x]\n\n```\n原子性是通过 「undo log（回滚日志）」 来保证的；\n持久性是通过 「redo log （重做日志）」来保证的；\n隔离性是通过 「MVCC（多版本并发控制）」 或「锁机制」来保证的；\n一致性则是通过「持久性」+「原子性」+「隔离性」来保证；\n```\n\n## 并发事务会引发什么问题？\n\n```\n脏读、不可重复读、幻读\n```\n\n### 脏读\n\n```\n一个事务读到其他事务未提交的数据\n```\n\n出现场景\n\n```\n事务A对数据进行修改还未提交，事务B读取这条数据，此时事务A进行了回滚,\n```\n\n### 不可重复读\n\n```\n在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。\n```\n\n出现场景\n\n```\n事务A读取某条数据，此时事务B更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。\n```\n\n### 幻读\n\n```\n一个事务，查询条件相同，先后读取数据的数量不一致\n```\n\n出现场景\n\n```\n事务A读取某个范围内的数据，事务B在这个范围内添加/删除数据，事务A再次读取时，查询的数量会不一致\n```\n\n### 丢失修改\n\n```\n事务A修改某条数据未提交前，事务B也对这条数据进行了修改并提交，此时事务A进行提交，事务B的修改就会丢失。\n```\n\n### 不可重复读和幻读有什么区别？\n\n```\n不可重复读是对某一条数据 多次读取不一致\n幻读是对某一个范围内的数据 多次读取不一致\n\n幻读是不可重复读的一种特殊情况，单独区分是因为解决方法不同。\n```\n\n## 并发事务的控制方式有哪些？ \n\n```\n锁和mvcc\nhttps://javaguide.cn/database/mysql/mysql-questions-01.html#并发事务的控制方式有哪些\n```\n\n\n\n## 事务的隔离级别\n\n### 有哪些？问题\n\n```\n（1）读未提交：可以读取未提交事务。可能导致脏读、幻读、不可重复读\n（2）读提交：指一个事务提交之后，它做的变更才能被其他事务看到；可能导致幻读、不可重复读\n（3）可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；可能导致幻读 【具体原因见方法】\n（4）串行化：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/100133169154649316915464935760bAug5-4e98ea2e60923b969790898565b4d643.png\" alt=\"图片\" style=\"zoom:50%;\" />\n\n### 可重复读很大程度上解决了幻读问题，是怎么解决的？[x]\n\n```\n（1）针对「快照读」（普通select语句），通过「mvcc」方式解决：\n    事务启动后，会创建一个读取视图（read view），该视图包含了事务开始时数据库中的所有数据。在事务执行期间，其他事务对数据的修改\n是查询不出来的。\n\n（2）针对「当前读」（select...for update等语句），通过「next-key lock(记录锁+间隙锁)」方式解决。\n\t\t因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。\n\n【SELECT ... FOR UPDATE 是一种用于在事务中对数据行进行加锁的语句】\n```\n\n#### 快照读是如何避免幻读的？\n\n```\n实现方式：undo log + mvcc\n\n可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，该视图包含了事务开始时数据库中的所有数据。在事务执行期间，每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。\n```\n\n#### 当前读是如何避免幻读的？\n\n```\n什么是当前读？\nMySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。\n这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。\n\n通过添加next-key lock解决\n```\n\n### MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？\n\n```\n在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。\n\nhttps://xiaolincoding.com/mysql/lock/lock_phantom.html#加锁分析\n```\n\n\n\n### 可重复读中幻读被完全解决了吗？\n\n```\n可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读。\n\nhttps://www.xiaolincoding.com/mysql/transaction/phantom.html\n```\n\n场景1:\n\n```\n事务A查询某个范围内的数据，事务B在这个范围内添加一条数据，此时事务A是看不到的。\n如果事务A去更新这个记录，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/10402916915488291691548829458XOS6lA-%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n场景2\n\n```\nT1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。\nT2 时刻：事务 B 往插入一个 id= 200 的记录并提交；\nT3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。\n\n要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。\n```\n\n### MySQL 的隔离级别是怎么实现的？\n\n```\nMySQL 的隔离级别基于锁和 MVCC 机制共同实现的。\n\n（1）「串行化」 隔离级别是通过锁来实现的，\n（2）「提交读」和 「可重复读」隔离级别是基于 MVCC 实现的。不过， 「串行化」 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。\n\nhttps://javaguide.cn/database/mysql/mysql-questions-01.html#sql-标准定义了哪些事务隔离级别\n```\n\n### 这四种隔离级别具体是如何实现的呢？？？[x]\n\n```\n（1）对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；\n（2）对于「串行化」隔离级别的事务来说，通过加「读写锁」的方式来避免并行访问；\n（3）对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同；\n\t\t- 读提交：在「每个语句执行前」都会重新生成一个 Read View。也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。\n\t\t- 可重复读： 是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。这样就保证了在事务期间读到的数据都是事务启动前的记录。\n```\n\n### 启动事务的方式\n\n```\n两种方式：\n第一种：begin/start transaction 命令：执行后并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；\n第二种：start transaction with consistent snapshot 命令：就会马上启动事务。\n```\n\n## MVCC？*\n\n```\nhttps://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-在-mvcc-里如何工作的\n```\n### 是什么\n\n```\nMvcc是多版本并发控制，保证了事务之间的隔离性，事务只能看到自己已经提交的数据版本，从而保证了数据的一致性，并且避免了事务读写并发问题\n```\n\n### 原理\n\n```\nread view有四个重要的字段：\n（1）creator_trx_id: 创建该readview的的事务的事务id\n（2）m_ids: 创建readView时，数据库中「活跃事务」的事务id列表（活跃事务指启动但未提交的事务）\n（3）min_trx_id: m_ids的最小值\n（4）max_trx_id: 创建readView时当前数据库中应该给下一个事务的id值，即m_ids的最大值+1\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/13493616915601761691560176829NlsMaT-readview%E7%BB%93%E6%9E%84.drawio.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n```\n聚簇索引中的两个隐藏列\n（1）trx_id: 当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；\n（2）roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。\n```\n\n```\n可重复读隔离级别下，执行第一个select查询时会创建Read View，整个事务期间都在使用这个Read View。\n读提交隔离级别下，每次select查询，都会创建一个新的Read View\n\n一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：\n（1）trx_id < min_trx_id, 则该条记录对当前事务「可见」。表示这个版本的记录是在创建 Read View 前已经提交的事务生成的\n（2）trx_id >= max_trx_id, 则该条记录对当前事务「不可见」。表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。\n（3）处于之间，则判断trx_id是否在m_ids里：\t？？？（应该是可重复读 和 读提交会有区别，不在列表中只会在读提交中出现，每次都会创建新的readview）\n\t\t- 在列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务「不可见」。\n\t\t- 不在列表中，表示生成该版本记录的活跃事务已经被提交，则对当前事务「可见」。\n\t\t\n这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。\n```\n\n\n\n## 可重复读是如何工作的？\n\n```\nhttps://xiaolincoding.com/mysql/transaction/mvcc.html#可重复读是如何工作的\n```\n\n```\n例子：事务A启动，接着B也跟着启动\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/14125216915615721691561572562VsQsN0-%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n```\n操作流程 & 现象：\n事务 B 读取小林的账户余额记录，读到余额是 100 万；\n事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；\n事务 B 读取小林的账户余额记录，读到余额还是 100 万；\n事务 A 提交事务；\n事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；\n```\n流程分析\n```\n分析，B三次读取时为什么都能读到100:\n（1）第一次：该条记录的trx_id = 50, 小于事务B的活跃事务m_ids，表示在事务启动前就提交，所以该版本记录对B可见\n（2）第二次：\n\t\t- A修改但未提交，mysql会记录相应的undolog，并以链表的形式串联起来，形成「版本链」，然后修改该条记录的trx_id=51。\n\t\t- B此时去读，发现trx_id=51，在自己的活跃事务m_ids里。说明这条记录被修改但未提交。所以不会读取该记录，而是沿着undolog链条找旧版本的记录，找到第一条小于事务B的min_trx_id(即在活跃事务m_ids左侧)，即trx_id=50的记录\n（3）第三次：事务A已经提交，但是事务B用的启动事务时创建的readview，所以修改依旧不可见。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/14171816915618381691561838130jD2AHR-image-20230809141717983.png\" alt=\"image-20230809141717983\" style=\"zoom:50%;\" />\n\n## 读提交是如何工作的？\n\n```\nhttps://xiaolincoding.com/mysql/transaction/mvcc.html#读提交是如何工作的\n```\n\n```\n操作流程 & 现象：\n事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；\n事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；\n事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；\n事务 A 提交事务；\n事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；\n```\n\n流程分析\n\n```\n与「可重复读事务」的区别在第三次：\n「读提交」每次创建时，都会创建一个新的readview，所以事务A提交后，B再去读，会新建一个视图，提交后的数据对B来说是可见的\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/14431816915633981691563398800novU0H-%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A12.drawio.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n## 更新是如何保证一致的？\n\n```\n更新属于当前读，会加X型的行级锁，是通过锁来保证一致性的。\n\n比如，事务 A 执行对一条 id = 1 的记录进行了更新，其他事务如果想更新或者删除这条记录的话，会发生阻塞，只有当事务 a 提交了事务才会释放锁。\n```\n\n","timestamp":1694515333622},{"name":"04-锁.md","path":"006-MySQL/04-锁.md","content":"## MySQL 有哪些锁？\n\n```\n根据加锁的范围, 分为：\n- 全局锁、\n- 表级锁: 表锁、意向锁、自增锁\n- 行级锁：记录锁、间隙锁、临键锁\n```\n\n### 全局锁\n\n#### 如何使用？\n\n```\nflush tables with read lock\t\t// 整个数据库就处于只读状态了。\nunlock tables\t\t// 解锁，当会话断开了，全局锁也会被自动释放。\n```\n\n#### 全局锁应用场景是什么？\n\n```\n全库逻辑备份\n```\n\n#### 加全局锁又会带来什么缺点呢？\n\n```\n数据库都是只读状态，如果数据库里有很多数据，备份就会花费很多的时间。\n关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。\n```\n\n#### 使用全局锁会影响业务，那有什么其他方式可以避免？[x]\n\n```\n如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。\n\nMyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法\n```\n\n### 表级锁\n\n#### MySQL 表级锁有哪些？具体怎么用的\n\n```\n表锁；\n元数据锁（MDL）;\n意向锁；\nAUTO-INC 锁；\n```\n\n#### 表锁\n\n```\n共享锁（读锁）：一个客户加了读锁，其他可以加读锁，不可以加写锁\n排他锁（写锁）：加了写锁，就不能加读锁 或 写锁\n```\n\n#### 元数据锁（MDL）\n\n```\n\n```\n\n#### 意向锁\n\n```\n意向锁快速判断是否可以对某个表使用表锁，而不用逐行遍历\n\n意向锁是表级锁，共有两种\n（1）意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。\n（2）意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。\n```\n\n意向锁之间是互相兼容的。\n\n|       | IS 锁 | IX 锁 |\n| ----- | ----- | ----- |\n| IS 锁 | 兼容  | 兼容  |\n| IX 锁 | 兼容  | 兼容  |\n\n「意向锁」和「共享锁、排它锁」互斥（这里指的是表级别的共享锁和排他锁，不会与行级的共享锁和排他锁互斥）。\n\n|      | IS 锁 | IX 锁 |\n| ---- | ----- | ----- |\n| S 锁 | 兼容  | 互斥  |\n| X 锁 | 互斥  | 互斥  |\n\n####  自增锁（AUTO-INC锁）\n\n```\n一个事务插入的数据中有自增列表时，就会获取自增锁，获取不到就阻塞，等待插入语句执行完后才释放锁，以保证插入数据时是连续递增的。\n大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。\n\n优化：\nMySQL 5.1.22，InnoDB 存储引擎提供了一种「轻量级的锁」来实现自增。\n插入的数据中有自增列表时，就会获取轻量级的锁，给该字段赋值完后就会释放\n```\n\n### 行级锁\n\n#### 行级锁有哪些种类？\n\n```\n不同隔离级别下，行级锁的种类是不同的。\n（1）读提交：记录锁\n（2）可重复读：\n\t\t- 记录锁 Record Lock：\n\t\t- 间隙锁 Gap Lock：\n\t\t- 临键锁 Next-Key Lock：\n\t\n```\n\n\n\n#### Record Lock\n\n```\n记录锁，锁住的是一条记录。\n\n记录锁是有 S 锁和 X 锁之分的：\n- 一个事务对一条记录加了S锁，其他事务可以加S锁，但不能加X锁\n- 一个事务对一条记录加了X锁, 其他事务既不能加S锁，也不能加X锁\n\n事务commit后，锁释放\n```\n\n#### Gap Lock\n\n```\n间隙锁，锁定一个范围，不包括记录本身。\n只存在于「可重复读隔离级别」，目的是为了解决可重复读隔离级别下幻读的现象。\n\n如表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。\n\n间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。\n```\n\n#### Next-Key Lock\n\n```\n临键锁，是「记录锁」+「间隙锁」的组合，锁定一个范围，并且锁定记录本身。\n\n表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。\n\n如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。\n```\n\n#### 插入意向锁\n\n```\n\n```\n\n## 表级锁和行级锁了解吗？有什么区别？\n\n```\n（1）表级锁：\n\t\t粒度比较大的锁，它锁定整个表，当一个事务获得了某个表的锁后，其他事务就不能对该表进行任务操作。所以，并发效率极低，锁冲突概率也很高\n（2）行级锁：\n\t\t粒度较小，只会锁定特定行（一行或多行），其他事务可以操作其他行。所以并发性相对较高，可能会出现死锁\n```\n\n## 共享锁和排他锁\n\n```\n不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）\n\n（1）共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。\n（2）排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）\n\n```\n\n## 当前读和快照读有什么区别？\n\n当前读：\n\n```\n读取最新版本数据，并对读取的记录加锁，阻塞其他事务同时改动相同记录，避免出现安全问题。\n\nselect...lock in share mode (共享读锁)\nselect...for update\nupdate , delete , insert\n```\n\n快照读\n\n```\n\n```\n\n## MySQL 是怎么加锁的？\n\n### 什么 SQL 语句会加行级锁？\n\n```\nInnoDB 引擎是支持行级锁的， MyISAM 引擎并不支持行级锁\n\n（1）普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。\n（2）可以用「锁定读」在查询时对记录加行级锁\n\n  // 对读取的记录加共享锁(S型锁)\n  select ... lock in share mode;\n  //对读取的记录加独占锁(X型锁)\n  select ... for update;\n  \n（3）update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/10231716916341971691634197297eYLxWQ-x%E9%94%81%E5%92%8Cs%E9%94%81.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n## MySQL 是怎么加行级锁的？TODO\n\n```\n不同的场景，加锁的形式是不同的\n加锁的对象是索引，加锁的基本单位是 next-key lock，在能使用「记录锁」或者「间隙锁」就能避免幻读现象的场景下， next-key lock 就会退化成「记录锁」或「间隙锁」。\n\nhttps://xiaolincoding.com/mysql/lock/how_to_lock.html#mysql-是怎么加行级锁的\n```\n\n### 唯一索引等值查询\n\n```\n（1）当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。\n（2）当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」\n```\n\n### 唯一索引范围查询\n\n```\n\n```\n\n## update 没加索引会锁全表？\n\n```\n(不带索引就是全表扫扫描，也就是表里的索引项都加锁，相当于锁了整张表，并不是表锁)\n\n在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁\n\n比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁（锁是加在索引上）。\nupdate socre = 100 where id = 1\n\n但是，在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。只能用select ... from\nupdate socre = 100 where name = \"xxx\"\n```\n\n\n\n\n\n## MySQL 死锁了，怎么办？TODO\n\n```\nhttps://xiaolincoding.com/mysql/lock/deadlock.html#死锁的发生\n```\n\n### 死锁的发生\n\n```\n事务A，需要插入订单1007\n事务B，需要插入订单1008\n插入前两个事务都进行了「当前读」操作，判断订单是否存在\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/14032516916474051691647405423hZW5el-90c1e01d0345de639e3426cea0390e80.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n## 加了什么锁，导致死锁的？TODO\n\n```\nhttps://xiaolincoding.com/mysql/lock/show_lock.html\n```\n\n## MySQL死锁怎么避免？（或者说怎么处理MySQL死锁）[*]\n\n```\n死锁的四个必要条件：互斥、占有且等待、不可强占用、循环等待。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。\n\n在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：\n（1）设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。\n\n（2）开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。\n```\n\n\n\n\n\n\n\n## [乐观锁 & 悲观锁](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487996&idx=1&sn=cafae3423e5ffa903a0c0a94a355f981&source=41#wechat_redirect) [*]\n\n### 乐观锁\n\n是什么\n\n```\n它假设冲突很少发生，所以它不会阻止其他线程进行读写操作。而是在数据更新时，检查数据是否被其他线程更改\n```\n\n实现方式\n\n```\n乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用。\n\n（1）版本号：为数据库表添加一个版本号字段。当读取数据时，将版本号一起读出，数据每更新一次，对应的版本号就加一。当提交事务时检查版本号是否改变，如果版本号发生了变化，说明数据已经被其他事务更新，当前事务会回滚。\n\n（2）时间戳：与版本号类似，但是使用数据的时间戳来判断数据是否有变化。\n```\n\n使用场景\n\n```\n读多写少\n```\n\n\n\n### 悲观锁\n\n是什么\n\n```\n每次读取数据时，都认为其他线程会修改数据，因此在数据被读取出来的整个过程中，都将数据锁定，其他线程不能对其进行修改。\n```\n\n实现方式\n\n```\n数据库层面的行锁、表锁等，例如：SELECT ... FOR UPDATE。\n在程序中使用synchronized或ReentrantLock等锁机制。\n```\n\n使用场景\n\n```\n写多读少\n```\n\n","timestamp":1694515333622},{"name":"05-日志.md","path":"006-MySQL/05-日志.md","content":"\n\n## undo log（回滚日志）\n\n### 是什么\n\n```\nundo log 是一种用于撤销回退的日志。\n当一个事务要修改数据时，首先会将旧值保存到undo log中，然后再修改。当时事务撤销，则可以利用undo log来进行回滚。\nundo log保证了事务的原子性\n也实现mysql多版本并发控制的重要技术。\n```\n\n### undo log 作用\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/1428331691648913169164891359542tTLG-%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png\" alt=\"回滚事务\" style=\"zoom:50%;\" />\n\n```\n（1）实现事务回滚，保障事务的原子性。\n\t\t事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。\n（2）实现 MVCC（多版本并发控制）关键因素之一。\n\t\tMVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。\n```\n\n### 发生宕机，如何利用undo log和redo log恢复？x\n\n```\n（1）首先使用redo log：系统重新启动后，会检查redo log，并重做所有已提交但尚未写入磁盘的事务。这是为了确保所有已提交的事务都被持久化。\n（2）接着使用undo log：在redo log的恢复过程之后，系统会检查是否有未完成（例如，已开始但未提交）的事务。对于这些事务，系统将使用undo log来撤销它们所做的更改，从而确保数据库的一致性。\n```\n\n### 如何回滚一条记录？undo log具体怎么回滚? *\n\n```\n事务执行过程中，执行 rollback 语句就能回滚事务了。\n\n每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：\n- 在插入一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录删掉就好了；\n- 在删除一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了；\n- 在更新一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列更新为旧值就好了。\n\n在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。\n\nhttps://mp.weixin.qq.com/s/7YcvtQOd6CUrPEx1sFhwVw\n```\n\n\n\n## Buffer Pool\n\n###  为什么需要 Buffer Pool？\n\n```\nInnodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。\n\n（1）当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。\n（2）当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。\n```\n\n### Buffer Pool 缓存什么？\n\n```\nInnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。\n\nBuffer Pool 除了缓存「索引页」和「数据页」，还包括了 「Undo 页」，「插入缓存」、「自适应哈希索引」、「锁信息」等等。\n\nhttps://xiaolincoding.com/mysql/log/how_update.html#buffer-pool-缓存什么\n```\n\n### Undo 页是记录什么？\n\n```\n开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。\n```\n\n### undo log 是如何刷盘（持久化到磁盘）的\n\n```\nundo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。\n\nbuffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。\n```\n\n\n\n\n\n## redo log（重做日志）\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/16544916916576891691657689548nkulq9-wal.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n### 什么是 redo log？\n\n```\nredo log（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力。\n当事务提交时，先把修改记录在redo log中。\n如果发生了崩溃重启，会检查redo log，并重做所有 提交了但没有写入磁盘的修改，保证数据的持久性与完整性。\n\n为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了。\n```\n\n### 为什么需要redo log？\n\n```\nBuffer Pool提高了读写效率，但是是基于内存的，如果断电重启，还没来得及刷盘的脏页数据就会丢失。\n有了redolog，就会把「在某个数据页上做了什么修改」记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。\n```\n\n### 被修改 Undo 页面，需要记录对应 redo log 吗？\n\n```\n需要的。\n\n开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。\n\n不过，在内存修改该 Undo 页面后，需要记录对应的 redo log。\n```\n\n### redo log 和 undo log 区别在哪？\n\n```\n这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：\n\nredo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；\nundo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；\n\n事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，\n事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务。\n```\n\n### redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？\n\n```\n（1）实现事务的持久性，让 MySQL 有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；\n（2）数据是随机写，先找到位置再写；redolog是顺序写，先记录在日志上，然后在合适的时间再更新到磁盘上 ，提升语句的执行性能\n```\n\n### 产生的 redo log 是直接写入磁盘的吗？\n\n```\n不是的。执行一个事务的过程中，产生的 redo log写到redo log buffer缓存中，后续在持久化到磁盘\n\n【redo log什么时候刷盘】\n```\n\n### redo log 什么时候刷盘？\n\n```\n（1）MySQL 正常关闭时；\n（2）当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；\n（3）InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。\n（4）每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘\n```\n\n\n\n## binlog（归档日志）\n\n### 为什么需要 binlog ？\n\n```\nbinlog 是逻辑日志，记录内容是语句的原始逻辑，属于MySQL Server 层，不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。\n\n主要用于数据备份、主从复制等场景\n```\n\n### redo log 和 binlog 有什么区别？\n\n```\n（1）适用对象不同：\n\t- binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；\n\t- redo log 是 Innodb 存储引擎实现的日志；\n（2）写入方式不同：\n\t- binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。\n\t- redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。\n（3）用途不同：\n\t- binlog 用于备份恢复、主从复制；\n\t- redo log 用于掉电等故障恢复。\n\t\n\t在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。\n```\n\n### 如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？\n\n```\n不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。\n\n因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。\n\nbinlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。\n```\n\n### binlog 什么时候刷盘？\n\n```\n事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。\n\n一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。\n```\n\n\n\n\n\n## update 语句的执行过程（串联三个日志）\n\n```\n当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。\n具体更新一条记录 UPDATE t_user SET name = \'xiaolin\' WHERE id = 1; 的流程如下:\n（1）执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录\n\t- 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；\n\t- 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。\n（2）执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：\n\t- 如果一样的话就不进行后续更新流程；\n\t- 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；\n（3）开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。\n（4）InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。\n（5）至此，一条记录更新完了。\n（6）在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。\n（7）事务提交，剩下的就是「两阶段提交」的事情了，接下来就讲这个。\n\nhttps://xiaolincoding.com/mysql/log/how_update.html#binlog-什么时候刷盘\n```\n\n\n\n## 主从复制 TODO\n\n```\nhttps://xiaolincoding.com/mysql/log/how_update.html#主从复制是怎么实现\n```\n\n\n\n## 两阶段提交\n\n### 为什么需要\n\n```\n（1）在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。\n（2）事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。\n\n修改一条数据，redo log和binlog持久化时：\n（1）如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入：\n\t\tMySQL 重启后，通过 redo log 能将 Buffer Pool 中 该条数据恢复到新值，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行数据仍是旧值，与主库的值不一致性\n（2）如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入：\n\t\t由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这行数据的 还是旧值，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行数据就是是新值，与主库的值不一致性；\n\t\t\nMySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决\n```\n\n### 是什么\n\n```\n两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」\n在commit阶段之前先写入binlog\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/19461816916679781691667978566pPcs18-04-20220305234956774.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n### 写入binlog发生异常，会发生什么？\n\n```\nMySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/20044416916690841691669084070ZFx8ck-05-20220305234937243.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n### redo log的commit阶段发生异常，会发生什么？\n\n```\n不会回滚事务，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据\n```\n\n### 两阶段提交有什么问题？\n\n```\n（1）磁盘 I/O 次数高\n（2）锁竞争激烈\n\nhttps://xiaolincoding.com/mysql/log/how_update.html#异常重启会出现什么现象\n```\n\n\n\n\n\n## 组提交TODO\n\n```\nhttps://xiaolincoding.com/mysql/log/how_update.html#两阶段提交有什么问题\n```\n\n","timestamp":1694515333622},{"name":"06-其他.md","path":"006-MySQL/06-其他.md","content":"## MySQL 遇到过死锁问题吗，你是如何解决的？\n\n```\n查看死锁日志 show engine innodb status; \n找出死锁 Sql \n分析 sql 加锁情况 \n模拟死锁案发 \n分析死锁日志 \n分析死锁结果\n```\n\n参考\n\n-   [手把手教你分析Mysql死锁问题](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487979&idx=1&sn=588c83d77a8851f3b3c18cd68ed9c454&chksm=cf21cec2f85647d4a77cc239ae9a4cfd31bb8832be3d98540a08ea8b4a1f46b38cf736210a02&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)\n-   [两万字详解！InnoDB锁专题！](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247499275&idx=1&sn=ca72f48a290e4fd2a2ded6ef6fd045be&chksm=cf222122f855a8347b911352cebdd722b17ea45733b91ff169353c0805d9f31cea5261ef01b9&token=1712314640&lang=zh_CN#rd)\n\n\n\n\n\n## 日常工作中你是怎么优化 SQL 的？\n\n```\n（1）增删索引。\n\t- 删除一些不必要的索引\n\t- 一些查询频繁但修改少的字段添加索引，尽量添加联合索引。\n（2）避免返回不必要的数据。返回需要的字段，比如工作流任务中，包含了一个text类型的字段，查询会消耗大量的网络和io带宽。在查询列表时是用不到这个字段信息的，只有在编辑流程时才需要查该字段。\n（3）优化limit大分页问题。先查询limit后的id，再进行\n（4）索引失效问题\n\t\t- 最左匹配\n\t\t- 操作索引列\n\t\t- where字段 in、%like、not in、is not null\n\t\t- 隐式转换\n```\n\n参考\n\n-   [后端程序员必备：书写高质量SQL的30条建议](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487972&idx=1&sn=cd035a7fcd7496658846ab9f914be2db&chksm=cf21cecdf85647dbc53e212bf1a2b95d0eb2bffe08dc0141e01f8a9b2088abffc385a2ef584e&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)\n-   [我们为什么要分库分表？](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247498625&idx=1&sn=0d7bd9d1b46eeff4c715a6761355e9b0&chksm=cf2224a8f855adbea8931c8e011711f6c70cffeef8ddf8b87729c710eacef11b46eef80fda36&token=1712314640&lang=zh_CN#rd)\n\n\n\n\n\n## Limit数据很大问题\n\n###  limit 10000,10 会比 limit 10 更慢\n\n#### 基于主键索引的limit执行过程\n\n```sql\nlimit offset, size 和 limit size\n其实 limit size ，相当于  limit 0, size。也就是从0开始取size条数据。\n\nselect * from page order by id limit 10000, 10\n（1）在innodb里的主键索引中获取到第0到（1000 + 10）条完整行数据，返回给server层【费时的地方】\n（2）server层根据offset的值挨个抛弃，最后只留下最后面的size条，也就是10条数据\n```\n\n优化\n\n```sql\n问题：用的select * 会拷贝（10000+10）条数据的完整字段，费时\n解决：先查id，再根据id查整个字段\n\nselect * from page  \nwhere id >=(select id from page  order by id limit 10000, 1) \norder by id limit 10;\n```\n\n#### 基于非主键索引的limit执行过程\n\n```sql\nselect * from page order by user_name  limit 0, 10;\n\n区别在于需要一次回表操作\n当limit offset过大时，非主键索引查询非常容易变成全表扫描\n```\n\n优化\n\n```sql\nselect * \nfrom page t1, (select id from page order by user_name limit 10000, 100) t2  \nWHERE t1.id = t2.id;\n\n问题：只是解决了回表的问题，但是还是会查询10000+100条数据给server层，再抛弃1w条数据\noffset过大时，比如到了百万千万的量级，就是“深度分页问题”\n```\n\n\n\n### limit 1000000, 10 加载很慢的话，你是怎么解决的呢？\n\n```sql\n方案一: 如果 id 是连续的，返回上次查询的最大记录(偏 移量)，再往下 limit\nselect id，name \nfrom employee where id > 1000000 limit 10.\n\n方案二：在业务允许的情况下限制页数：\n建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往 后翻太多页。\n\n方案三：order by + 索引（id 为索引） ？？？感觉还是会查100w+10条\nselect id，name \nfrom employee order by id limit 1000000，10\n\n方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位 需要获取的 id 段，然后再关联）\nselect a.* \nfrom employee a, (select id from employee where 条件 limit 100000, 10) b\nwhere a.id = b.id\n```\n\n[参考：mysql查询 limit 1000,10 和limit 10 速度一样快吗？如果我要分页，我该怎么办？](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247499838&idx=1&sn=e30f577d2a5e4fc52e40fb070293be9d&chksm=cf221f17f85596018dde39ddfd281a527bd92c5f654d76d7313b8485d04660e559090fc0d87b&token=1712314640&lang=zh_CN#rd)\n\n\n\n## 在高并发情况下，如何做到安全的修改同一行数据？\n\n```\n要安全的修改同一行数据，就要保证一个线程在修改时其它线程无法更新这行 记录。一般有悲观锁和乐观锁两种方案~\n```\n\n\n\n## select for update 含义，加行锁还是表锁 ？？？\n\n```\nselect for update 除了有查询的作用外，还会加锁（悲观锁）\n没用索引/主键的话就是表锁；否则就是是行锁，只会锁定这些索引或主键对应的行。\n```\n\n\n\n## 当数据量很大的时候怎么设计数据库？有什么方法？\n\n```\n\n```\n\n## 海量数据的时候，怎么优化SQL查询？索引？\n\n```\n（1）理解查询执行计划：使用数据库的查询执行计划工具来分析查询的性能。这些工具可以提供关于查询是如何执行的详细信息，包括使用哪些索引、执行了哪些连接等。\n（2）使用索引:\n\t- 为经常查询的字段和WHERE子句中的字段创建索引。\n\t- 考虑使用复合索引来支持多个字段的查询。\n\t- 使用覆盖索引来满足查询，从而避免访问数据表。\n\t- 避免在索引列上使用函数或计算，这可能导致索引无法使用。\n（3）减少返回的数据量:\n\t- 只选择需要的列，避免使用 SELECT *。\n\t- 使用 LIMIT 子句来限制返回的结果数量。\n（4）优化连接操作:\n\t- 仅在必要时使用连接，并确保使用索引列进行连接。\n\t- 使用内连接（INNER JOIN）代替外连接（OUTER JOIN）（如果适用）。\n（5）避免使用子查询:\n\t- 当可能的时候，使用连接代替子查询。\n```\n\n## MYSQL怎么实现事务？用哪三个语句来支持事务？\n\n```\n（1）START TRANSACTION 或 BEGIN：\n用于标记事务的开始。执行此命令后，所有的SQL语句都会在一个私有的快照中执行，直到你提交或回滚这个事务。\n\n（2）COMMIT：\n用于提交事务。当你执行COMMIT语句时，所有从START TRANSACTION或BEGIN之后所做的更改都会永久地应用到数据库。这些更改在COMMIT之前对其他事务是不可见的。\n\n（3）ROLLBACK：\n如果你决定不应用从事务开始以来所做的更改，可以使用ROLLBACK命令。执行ROLLBACK后，所有在事务中所做的更改都会被撤销，数据库会回到事务开始前的状态。\n\n除了上述基本命令外，MySQL还提供了更高级的功能，如事务的隔离级别设置，以满足不同的并发和一致性需求。\n```\n\n","timestamp":1694515333622},{"name":"07-MySQL主从.md","path":"006-MySQL/07-MySQL主从.md","content":"## 主从数据库是什么\n\n```\n一个主数据库，多个从数据库，\n主库对外提供读写的操作，从库对外提供读操作\n```\n\n作用\n\n```\n- 高可用，实时灾备，用于故障切换。比如主库挂了，可以切从库。\n- 读写分离，提供查询服务，减少主库压力，提升性能\n- 备份数据，避免影响业务。\n```\n\n## 数据库主从复制原理\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/19/10523216924135521692413552454OwckKr-640-20230819105232325.png\" alt=\"图片\" style=\"zoom:50%;\" />\n\n```\n（1）主库的更新SQL(update、insert、delete)被写到binlog\n（2）从库发起连接，连接到主库。\n（3）此时主库创建一个binlog dump thread，把bin log的内容发送到从库。\n（4）从库启动之后，创建一个I/O线程，读取主库传过来的bin log内容并写入到relay log\n（5）从库还会创建一个SQL线程，从relay log里面读取内容，从ExecMasterLog_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db\n```\n\n## 主主、主从、主备的区别\n\n主主\n\n```\n两台都是主数据库，同时对外提供读写操作。客户端访问任意一台。数据存在双向同步。\n```\n\n主从\n\n```\n一台是主数据库，同时对外提供读写操作。一台是从数据库，对外提供读的操作。数据从主库同步到从库。\n```\n\n主备\n\n```\n一台是主数据库，同时对外提供读写操作。\n一台是备库，只作为备份作用，不对外提供读写，主机挂了它就取而代之。数据从主库同步到备库。\n```\n\n## MySQL是怎么保证主从一致的\n\n```\n\n```\n\n参考\n\n-   [面试必备：聊聊MySQL的主从](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247497982&idx=1&sn=bb589329cceb5462fc41f66ec63dbf56&chksm=cf2227d7f855aec16dd4d3b3425c0401850eeaf2c9cdc82e82722d38a00c24ee9ccfa3353774&token=2044040586&lang=zh_CN#rd)","timestamp":1694515333622}]