if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m001']=[{"name":"Caffeine+Redis多级缓存.md","path":"001-JAVA/001-Redis/001-实践/Caffeine+Redis多级缓存.md","content":"https://mp.weixin.qq.com/s/_ysKYrzyRGebtotGyzQUIw","timestamp":1691335064136},{"name":"redis分布式限流器.md","path":"001-JAVA/001-Redis/001-实践/redis分布式限流器.md","content":"https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA","timestamp":1691335064136},{"name":"01-springboot引入redis.md","path":"001-JAVA/001-Redis/01-springboot引入redis.md","content":"![image-20220714142255347](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/07/14/14225516577797751657779775453rJJreW-image-20220714142255347.png)\n\n## 步骤\n\n引入依赖\n\n`pom.xml`\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n    <exclusions>\n      <exclusion>\n        <artifactId>lettuce-core</artifactId>\n        <groupId>io.lettuce</groupId>\n      </exclusion>\n    </exclusions>\n</dependency>\n  <dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n</dependency>\n```\n\n配置redis数据库\n\n`application/yaml`\n\n```yaml\nspring:\n  redis:\n    database: 0\n    host: 127.0.0.1\n    port: 6379\n    password:\n    jedis:\n      pool:\n        min-idle: 0\n        max-active: 8\n        max-idle: 8\n        max-wait: -1ms\n    connect-timeout: 30000ms\n\n```\n\n\n\n`RedisConfig.java`\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(factory);\n\n        // 设置key的序列化方式\n        template.setKeySerializer(RedisSerializer.string());\n        // 设置value的序列化方式\n        template.setValueSerializer(RedisSerializer.json());\n        // 设置hash的key的序列化方式\n        template.setHashKeySerializer(RedisSerializer.string());\n        // 设置hash的value的序列化方式\n        template.setHashValueSerializer(RedisSerializer.json());\n\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n```\n\n\n\n使用\n\n```java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@ContextConfiguration(classes = CommunityApplication.class)\npublic class RedisTests {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n  \t// 字符串\n    @Test\n    public void testStrings() {\n        String redisKey = \"test:count\";\n\n        redisTemplate.opsForValue().set(redisKey, 1);\n\n        System.out.println(redisTemplate.opsForValue().get(redisKey));\n        System.out.println(redisTemplate.opsForValue().increment(redisKey));\n        System.out.println(redisTemplate.opsForValue().decrement(redisKey));\n    }\n\n    // hash\n    @Test\n    public void testHashes() {\n        String redisKey = \"test:user\";\n\n        redisTemplate.opsForHash().put(redisKey, \"id\", 1);\n        redisTemplate.opsForHash().put(redisKey, \"username\", \"zhangsan\");\n\n        System.out.println(redisTemplate.opsForHash().get(redisKey, \"id\"));\n        System.out.println(redisTemplate.opsForHash().get(redisKey, \"username\"));\n    }\n\n  \t// list\n    @Test\n    public void testLists() {\n        String redisKey = \"test:ids\";\n\n        redisTemplate.opsForList().leftPush(redisKey, 101);\n        redisTemplate.opsForList().leftPush(redisKey, 102);\n        redisTemplate.opsForList().leftPush(redisKey, 103);\n\n        System.out.println(redisTemplate.opsForList().size(redisKey));\n        System.out.println(redisTemplate.opsForList().index(redisKey, 0));\n        System.out.println(redisTemplate.opsForList().range(redisKey, 0, 2));\n\n        System.out.println(redisTemplate.opsForList().leftPop(redisKey));\n        System.out.println(redisTemplate.opsForList().leftPop(redisKey));\n        System.out.println(redisTemplate.opsForList().leftPop(redisKey));\n    }\n\n    // set\n    @Test\n    public void testSets() {\n        String redisKey = \"test:teachers\";\n\n        redisTemplate.opsForSet().add(redisKey, \"刘备\", \"关羽\", \"张飞\", \"赵云\", \"诸葛亮\");\n\n        System.out.println(redisTemplate.opsForSet().size(redisKey));\n        System.out.println(redisTemplate.opsForSet().pop(redisKey));\n        System.out.println(redisTemplate.opsForSet().members(redisKey));\n    }\n\n    // 排序set\n    @Test\n    public void testSortedSets() {\n        String redisKey = \"test:students\";\n\n        redisTemplate.opsForZSet().add(redisKey, \"唐僧\", 80);\n        redisTemplate.opsForZSet().add(redisKey, \"悟空\", 90);\n        redisTemplate.opsForZSet().add(redisKey, \"八戒\", 50);\n        redisTemplate.opsForZSet().add(redisKey, \"沙僧\", 70);\n        redisTemplate.opsForZSet().add(redisKey, \"白龙马\", 60);\n\n        System.out.println(redisTemplate.opsForZSet().zCard(redisKey));\n        System.out.println(redisTemplate.opsForZSet().score(redisKey, \"八戒\"));\n        System.out.println(redisTemplate.opsForZSet().reverseRank(redisKey, \"八戒\"));\n        System.out.println(redisTemplate.opsForZSet().reverseRange(redisKey, 0, 2));\n    }\n\n    @Test\n    public void testKeys() {\n        redisTemplate.delete(\"test:user\");\n\n        System.out.println(redisTemplate.hasKey(\"test:user\"));\n\n        redisTemplate.expire(\"test:students\", 10, TimeUnit.SECONDS);\n    }\n\n    // 批量发送命令,节约网络开销.\n    @Test\n    public void testBoundOperations() {\n        String redisKey = \"test:count\";\n        BoundValueOperations operations = redisTemplate.boundValueOps(redisKey);\n        operations.increment();\n        operations.increment();\n        operations.increment();\n        operations.increment();\n        operations.increment();\n        System.out.println(operations.get());\n    }\n\n    // 编程式事务\n    @Test\n    public void testTransaction() {\n        Object result = redisTemplate.execute(new SessionCallback() {\n            @Override\n            public Object execute(RedisOperations redisOperations) throws DataAccessException {\n                String redisKey = \"text:tx\";\n\n                // 启用事务\n                redisOperations.multi();\n                redisOperations.opsForSet().add(redisKey, \"zhangsan\");\n                redisOperations.opsForSet().add(redisKey, \"lisi\");\n                redisOperations.opsForSet().add(redisKey, \"wangwu\");\n\n                System.out.println(redisOperations.opsForSet().members(redisKey));\n\n                // 提交事务\n                return redisOperations.exec();\n            }\n        });\n        System.out.println(result);\n    }\n\n}\n\n```\n\n\n\n\n\n## 参考\n\n-   [SpringBoot集成Redis - 基于RedisTemplate+Jedis的数据操作](https://pdai.tech/md/spring/springboot/springboot-x-redis-jedis.html)\n\n-   [SpringBoot整合Redis实现分布式缓存、分布式锁等，实战分享！](https://www.51cto.com/article/744722.html)\n    -   springboot redis的基本使用\n","timestamp":1691335064136},{"name":"02-redis实现分布式锁.md","path":"001-JAVA/001-Redis/02-redis实现分布式锁.md","content":"TODO：\n\n https://mp.weixin.qq.com/s/3zuATaua6avMuGPjYEDUdQ\n\n```\n1.2 过期时间不精准问题\n1.3 数据弱一致性问题\n\n基于 watchDog 看门狗机制以及 redLock 红锁机制给出对应的解决方案.\n```\n\nhttps://mp.weixin.qq.com/s/ha4Ojv9tDNaeMg4mAVwUTA\n\n```\n自动续期\n```\n\n\n\n实现原理\n\n```\n（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。\n（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。\n（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。\n```\n\n## key的设计\n\n```\n固定前缀:项目名:数据库名:表名:字段名:具体的值\n```\n\n## 问题\n\n### 剩余票问题\n\n如果10张票，10个人抢，同一时刻也只有一个人能拿到锁，其它也会因拿不到锁而失败返回，就会剩余票，怎么解决？\n\n```java\npublic boolean lock(String lockKey, String value, long expireTime) {\n        System.out.println(\"lock:: key:\" + lockKey + \" value: \" + value);\n        return redisTemplate.opsForValue().setIfAbsent(lockKey, value, expireTime, TimeUnit.SECONDS);\n}\n```\n解决\n\n```\n（1）规定时间内尝试获取锁，而不是获取失败就立即返回\n（2）重试机制。获取到锁的线程，执行业务逻辑之前先检测剩余票数，为0直接释放锁。未获取锁的线程在获取锁的逻辑中使用循环，直到获取到锁或超过一定的尝试次数才退出循环\n\n```\n\n```java\n@Resource\nprivate RedisTemplate redisTemplate;\n\nvoid saleTick() {\n\t\t...\n    int maxRetryCount = 3; // 最大重试次数\n    int retryIntervalMillis = 100; // 重试间隔时间（毫秒）\n    int retryCount = 0;\n  \n     try {\n          boolean locked = false;\n          while (!locked && retryCount < maxRetryCount) {\n            \tboolean locked = redisLock.tryLock(key, requestId, Duration.ofSeconds(2));\t// 2s内尝试获取锁\n              if (!locked) {\n                  retryCount++;\n                  Thread.sleep(retryIntervalMillis); // 重试间隔\n              }\n          }\n       \n       \t\t// 获取到锁的业务逻辑...\n     } finally {\n        redisLock.unlock(key, requestId);\n    }\n}\n```\n\n### 解锁要使用lua的原因？\n\n```java\n// 不使用lua的方式\npublic boolean unlock(String key, String value) {\n  \tObject currentValue = redisTemplate.opsForValue().get(key);\n  \tboolean result = false;\n    if (StringUtils.isNotEmpty(String.valueOf(currentValue)) && currentValue.equals(value)) {\n      result = redisTemplate.opsForValue().getOperations().delete(key);\n    }\n    return result;\n}\n```\n\n不使用Lua解锁可能会存在以下隐患：\n\n```\n\n（1）非原子性操作：如果在解锁过程中使用了多个Redis命令，例如先查询锁状态再进行解锁操作，那么这两个操作之间可能会发生竞争条件。即使在判断锁状态时锁是存在的，但在执行解锁操作之前，其他客户端可能已经抢占了锁，导致解锁操作失败。\n（2）网络开销增加：在不使用Lua解锁的情况下，解锁过程需要发送多个Redis命令，这会增加网络通信的开销。每个命令都需要与Redis服务器进行交互，而频繁的网络通信可能会增加延迟和降低性能。\n（3）锁的误解锁：在解锁过程中，如果由于某种原因（例如网络故障、程序异常等）导致解锁命令未能成功发送或执行，那么就会出现锁的误解锁情况。这会导致其他客户端在未完成任务的情况下获得了锁，可能引发数据一致性问题。\n\n综上所述，不使用Lua解锁可能会带来竞争条件、增加网络开销和锁的误解锁等隐患。使用Lua脚本可以解决这些问题，并提供更可靠和高效的分布式锁机制。\n\n```\n### 程序异常无法解锁，导致死锁\n\n```\nfinally中进行删除锁的操作\n```\n\n### 误解锁问题\n\n```\n给锁加一个标识符，只允许自己来操作锁，其他访问程序不能操作锁\n如String requestId = String.valueOf(gameId + Thread.currentThread().getId());\n```\n\n### 运行的程序彻底死掉，如断电，还是会无法解锁导致死锁\n\n```\n还要给锁加一个过期时间，这样就算程序死了，当时间过期后，还是能够继续执行\n```\n\n### 锁的过期时间过短，业务还未执行完成\n\n```\n守护线程/定期任务，续期\n```\n\n### 扣减库存的过程可以用lua脚本保证原子性\n\n```\n\n```\n\n### 处理业务逻辑中，使用lua脚本，避免超卖问题??也不会哦\n\n不使用lua脚本，[无法保证原子性，典型的RMW模型](https://juejin.cn/post/7127667756693979173)？？好像也不会出现超卖问题？？？\n\n```java\nint stock = Integer.parseInt(redisTemplate.opsForValue().get(\"product001-stock\").toString());\nif(stock <= 0) {\n    System.out.println(\"卖完啦！\");\n    return;\n}\nint currentStock = stock - 1;\nredisTemplate.opsForValue().set(\"product001-stock\",currentStock);\n```\n\n使用lua脚本\n\n```java\n// 方式2：Lua：参数列表下标从0开始, 获取KEYS[1]对应的值，判断是否<=0，小于返回0；大于则-1\nString script = \"local stock = redis.call(\'get\', KEYS[1])\\n\" +\n                \"if tonumber(stock) <= 0 then\\n\" +\n                \"    return 0\\n\" +\n                \"else\\n\" +\n                \"    redis.call(\'decr\', KEYS[1])\\n\" +\n                \"    return 1\\n\" +\n                \"end\";\nRedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);\nString key2 = \"product001-stock\";\nLong result = (Long) redisTemplate.execute(redisScript, Collections.singletonList(key2));\nint stock = Integer.parseInt(redisTemplate.opsForValue().get(\"product001-stock\").toString());\nif (result == 1) {\n  \t// 执行成功\n  \tSystem.out.println(\"线程：\" + Thread.currentThread().getName() + \" 抢到票，剩余: \" + stock);\n} else {\n    // 执行失败\n    System.out.println(\"抢票失败\");\n}\n```\n\n\n\n## 例子：抢票\n\n`redis`配置\n\n```java\npackage com.example.springbootdemo.redis;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.GenericToStringSerializer;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(factory);\n\n        // 设置key的序列化方式\n        template.setKeySerializer(RedisSerializer.string());\n        // 设置value的序列化方式\n        template.setValueSerializer(RedisSerializer.json());\n        // 设置hash的key的序列化方式\n        template.setHashKeySerializer(RedisSerializer.string());\n        // 设置hash的value的序列化方式\n        template.setHashValueSerializer(RedisSerializer.json());\n\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n```\n\nRedis分布式锁通用操作类\n\nTODO: 到期自动续期，参考redisson的看门狗watchdog\n\n```java\npackage com.example.springbootdemo.redis;\n\nimport com.alibaba.fastjson.JSON;\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.script.DefaultRedisScript;\nimport org.springframework.data.redis.core.script.RedisScript;\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\nimport java.lang.management.LockInfo;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Redis分布式锁通用操作类\n */\n@Slf4j\n@Component\npublic class RedisLockUtils {\n    @Resource\n    private RedisTemplate redisTemplate;\n    private static Map<String, LockInfo> lockInfoMap = new ConcurrentHashMap<>();\n    private static final Long SUCCESS = 1L;\n\n    /** 分布式锁过期时间，单位秒 */\n    private static final Long DEFAULT_LOCK_EXPIRE_TIME = 60L;\n\n    @Getter\n    @Setter\n    public static class LockInfo {\n        private String key;\n        private String value;\n        private int expireTime;\n        //更新时间\n        private long renewalTime;\n        //更新间隔\n        private long renewalInterval;\n        public static LockInfo getLockInfo(String key, String value, int expireTime) {\n            LockInfo lockInfo = new LockInfo();\n            lockInfo.setKey(key);\n            lockInfo.setValue(value);\n            lockInfo.setExpireTime(expireTime);\n            lockInfo.setRenewalTime(System.currentTimeMillis());\n            lockInfo.setRenewalInterval(expireTime * 2000 / 3);\n            return lockInfo;\n        }\n    }\n\n    /**\n     * 使用lua脚本更新redis锁的过期时间\n     * @param lockKey\n     * @param value\n     * @return 成功返回true, 失败返回false\n     */\n    public boolean renewal(String lockKey, String value, int expireTime) {\n        String luaScript = \"if redis.call(\'get\', KEYS[1]) == ARGV[1] then return redis.call(\'expire\', KEYS[1], ARGV[2]) else return 0 end\";\n        DefaultRedisScript<Boolean> redisScript = new DefaultRedisScript<>();\n        redisScript.setResultType(Boolean.class);\n        redisScript.setScriptText(luaScript);\n        List<String> keys = new ArrayList<>();\n        keys.add(lockKey);\n\n        Object result = redisTemplate.execute(redisScript, keys, value, expireTime);\n        log.info(\"更新redis锁的过期时间：{}\", result);\n        return (boolean) result;\n    }\n\n    /**\n     * 直接加锁\n     * @param lockKey    锁\n     * @param value      身份标识（保证锁不会被其他人释放）\n     * @param expireTime 锁的过期时间（单位：秒）\n     * @return 成功返回true, 失败返回false\n     */\n    public boolean lock(String lockKey, String value, long expireTime) {\n        // System.out.println(\"lock:: key:\" + lockKey + \" value: \" + value);\n        return redisTemplate.opsForValue().setIfAbsent(lockKey, value, expireTime, TimeUnit.SECONDS);\n    }\n\n    /**\n     * 直接加锁2 - lua脚本\n     * @param key\n     * @param value\n     * @param expire\n     * @return\n     */\n    public boolean lock2(String key, String value, Long expire){\n        String luaScript = \"if redis.call(\'setnx\', KEYS[1], ARGV[1]) == 1 then return redis.call(\'expire\', KEYS[1], ARGV[2]) else return 0 end\";\n        RedisScript<Long> redisScript = new DefaultRedisScript<>(luaScript, Long.class);\n        Long result = (Long) redisTemplate.execute(redisScript, Collections.singletonList(key), value, String.valueOf(expire));\n        return result.equals(Long.valueOf(1));\n    }\n\n    /**\n     * 尝试在指定时间内加锁\n     * @param key\n     * @param value\n     * @param timeout 锁等待时间\n     * @return\n     */\n    public boolean tryLock(String key, String value, Duration timeout){\n        long waitMills = timeout.toMillis();\n        long currentTimeMillis = System.currentTimeMillis();\n        do {\n            boolean lock = lock(key, value, DEFAULT_LOCK_EXPIRE_TIME);\n            if (lock) {\n                return true;\n            }\n            try {\n                Thread.sleep(1L);\n            } catch (InterruptedException e) {\n                Thread.interrupted();\n            }\n        } while (System.currentTimeMillis() < currentTimeMillis + waitMills);\n        return false;\n    }\n\n\n    /**\n     * 释放锁 - lua脚本解锁\n     * @param key\n     * @param value\n     * @return\n     */\n    public boolean unlock(String key,String value){\n        String luaScript = \"if redis.call(\'get\', KEYS[1]) == ARGV[1] then return redis.call(\'del\', KEYS[1]) else return 0 end\";\n        RedisScript<Long> redisScript = new DefaultRedisScript<>(luaScript, Long.class);\n        Long result = (Long) redisTemplate.execute(redisScript, Collections.singletonList(key), value);\n        return result.equals(Long.valueOf(1));\n    }\n\n    /**\n     * 定时去检查redis锁的过期时间\n     */\n    @Scheduled(fixedRate = 5000L)\n    @Async(\"redisExecutor\")\n    public void renewal() {\n        long now = System.currentTimeMillis();\n        for (Map.Entry<String, LockInfo> lockInfoEntry : lockInfoMap.entrySet()) {\n            LockInfo lockInfo = lockInfoEntry.getValue();\n            if (lockInfo.getRenewalTime() + lockInfo.getRenewalInterval() < now) {\n                renewal(lockInfo.getKey(), lockInfo.getValue(), lockInfo.getExpireTime());\n                lockInfo.setRenewalTime(now);\n                log.info(\"lockInfo {}\", JSON.toJSONString(lockInfo));\n            }\n        }\n    }\n\n    /**\n     * 分布式锁设置单独线程池\n     * @return\n     */\n    @Bean(\"redisExecutor\")\n    public Executor redisExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(1);\n        executor.setMaxPoolSize(1);\n        executor.setQueueCapacity(1);\n        executor.setKeepAliveSeconds(60);\n        executor.setThreadNamePrefix(\"redis-renewal-\");\n        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy());\n        return executor;\n    }\n}\n\n```\n\n抢票业务请求\n\n```java\npackage com.example.springbootdemo.redis;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.script.DefaultRedisScript;\nimport org.springframework.data.redis.core.script.RedisScript;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.annotation.Resource;\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Random;\n\n@RestController\npublic class IndexController {\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Autowired\n    private RedisLockUtils redisLock;\n\n    @GetMapping(\"/saleTick\")\n    public String saleTick() {\n        System.out.println(\"===saleTick===\");\n        String productId = \"product001\";\n        String requestId = productId + Thread.currentThread().getId();\n        String key = productId;\n        int maxRetryCount = 3; // 最大重试次数\n        int retryIntervalMillis = 100; // 重试间隔时间（毫秒）\n        int retryCount = 0;\n\n        try {\n            // 方式1：获取失败直接返回\n            // boolean locked = redisLock.lock(key, requestId, 10);\n\n            // 方式2：规定时间内尝试获取锁\n            // boolean locked = redisLock.tryLock(key, requestId, Duration.ofSeconds(2));\n\n            // 方式3：重试机制\n            boolean locked = false;\n            while (!locked && retryCount < maxRetryCount) {\n                locked = redisLock.tryLock(key, requestId, Duration.ofSeconds(1));\t// 2s内尝试获取锁\n\n                if (!locked) {\n                    retryCount++;\n                    Thread.sleep(retryIntervalMillis); // 重试间隔\n                }\n            }\n\n\n            if (!locked) {\n                // System.out.println(\"error\");\n                return \"获取锁失败\";\n            }\n\n            // 执行业务逻辑\n            // 方式1：非lua方式\n            // int stock = Integer.parseInt(redisTemplate.opsForValue().get(\"product001-stock\").toString());\n            // if(stock <= 0) {\n            //     System.out.println(\"卖完啦！\");\n            //     return \"卖完啦\";\n            // }\n            // int currentStock = stock - 1;\n            // redisTemplate.opsForValue().set(\"product001-stock\",currentStock);\n            // try {\n            //     Random random = new Random();\n            //     Thread.sleep(random.nextInt(3) * 1000);\n            // } catch (InterruptedException e) {\n            //     e.printStackTrace();\n            // }\n            // System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 抢到票，剩余: \" + currentStock);\n\n            // 方式2：Lua：参数列表下标从0开始, 获取KEYS[1]对应的值，判断是否<=0，小于返回0；大于则-1\n            String script = \"local stock = redis.call(\'get\', KEYS[1])\\n\" +\n                    \"if tonumber(stock) <= 0 then\\n\" +\n                    \"    return 0\\n\" +\n                    \"else\\n\" +\n                    \"    redis.call(\'decr\', KEYS[1])\\n\" +\n                    \"    return 1\\n\" +\n                    \"end\";\n            RedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);\n            String key2 = \"product001-stock\";\n            Long result = (Long) redisTemplate.execute(redisScript, Collections.singletonList(key2));\n            int stock = Integer.parseInt(redisTemplate.opsForValue().get(\"product001-stock\").toString());\n            if (result == 1) {\n                // 执行成功\n                System.out.println(\"线程：\" + Thread.currentThread().getName() + \" 抢到票，剩余: \" + stock);\n            } else {\n                // 执行失败\n                System.out.println(\"抢票失败\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        finally {\n\n            redisLock.unlock(key, requestId);\n        }\n\n        return \"买到了\";\n    }\n\n}\n\n```\n\n\n\n参考\n\n-   [SpringBoot整合Redis实现分布式缓存、分布式锁等，实战分享！](https://www.51cto.com/article/744722.html)\n    -   springboot redis的基本使用\n    -   lua脚本加锁、解锁\n    -   规定时间内加锁\n\n-   [SpringBoot+Redis实现分布式锁](https://zhuanlan.zhihu.com/p/536951041)\n    -   直接加锁，直接释放\n    -   封了一个内部类，描述锁的信息\n    -   加锁失败直接返回\n\n-   [手写一个Redis分布式锁，让你彻底搞懂](https://www.51cto.com/article/722510.html)\n    -   分布式锁的各种问题\n\n-   [Spring Boot 实现Redis分布式锁](https://juejin.cn/post/7127667756693979173)\n    -   代码跑不通\n\n-   [Spring Boot 集成Redisson实现分布式锁](https://juejin.cn/post/7128050664336261157)\n    -   解决锁定续期、可重入的问题\n    -   分布式系统可用\n\n-   [SpringBoot集成Redis - Redis分布式锁的实现之Jedis(setNXPX+Lua)](https://www.pdai.tech/md/spring/springboot/springboot-x-redis-lettuce-dist-lock.html)\n    -   切片，注解的方式使用\n    -   有源码\n\n-   [分布式系统 - 分布式锁及实现方案](https://www.pdai.tech/md/arch/arch-z-lock.html)\n\n-   [SpringBoot接口 - 如何保证接口幂等](https://www.pdai.tech/md/spring/springboot/springboot-x-interface-mideng.html)","timestamp":1691335064136},{"name":"03-布隆过滤器.md","path":"001-JAVA/001-Redis/03-布隆过滤器.md","content":"\n\n## 1 缓存穿透\n\n### 出现场景\n\n```java\n// 商品服务查询详情\npublic Product queryProductById (Long id){\n   // 查询缓存\n   Product product = queryFromCache(id);\n   if(product != null) {\n     return product ;\n   }\n   // 从数据库查询\n   product = queryFromDataBase(id);\n   if(product != null) {\n       saveCache(id , product);\n   }\n   return product;\n}\n```\n\n假设此商品既不存储在缓存中，也不存在数据库中，则没有办法**回写缓存** ，当有类似这样大量的请求访问服务时，数据库的压力就会极大。\n\n\n\n## 2 原理解析\n\n### 是什么？\n\n```\n是一个很长的二进制向量 和一系列随机映射函数，用于检索一个元素是否在一个集合中。\n优点是空间效率 和查询时间 都远远超过一般的算法 ，缺点是有一定的误识别率和删除困难。\n```\n\n### 实现原理\n\n```\n当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0 ，则被检元素一定不在 ；如果都是 1 ，则被检元素很可能在 \n```\n\n简单来说就是准备一个长度为 m 的位数组并初始化所有元素为 0，用 k 个散列函数对元素进行 k 次散列运算跟 len (m) 取余得到 k 个位置并将 m 中对应位置设置为 1。\n\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/20501216857102121685710212633NzArlu-640-20230602205012453.png)\n\n如上图，位数组的长度是８，散列函数个数是 3，先后保持两个元素ｘ，ｙ。这两个元素都经过三次哈希函数生成三个哈希值，并映射到位数组的不同的位置，并置为1。元素 x 映射到位数组的第０位，第４位，第７位，元素ｙ映射到数组的位数组的第１位，第４位，第６位。\n\n保存元素 x 后，位数组的第4位被设置为1之后，在处理元素 y 时第4位会被覆盖，同样也会设置为 1。\n\n当布隆过滤器**保存的元素越多** ，**被置为 1 的 bit 位也会越来越多** ，元素 x 即便没有存储过，假设哈希函数映射到位数组的三个位都被其他值设置为 1 了，对于布隆过滤器的机制来讲，元素 x 这个值也是存在的，也就是说布隆过滤器**存在一定的误判率** 。\n\n### 误判率\n\n```\n若位数组长度太小则会导致所有 bit 位很快都会被置为 1 ，那么检索任意值都会返回”可能存在“ ， 起不到过滤的效果。位数组长度越大，则误判率越小。\n\n同时，哈希函数的个数也需要考量，哈希函数的个数越大，检索的速度会越慢，误判率也越小，反之，则误判率越高。\n```\n\n### 时间和空间效率\n\n```\n布隆过滤器的空间复杂度为 O(m) ，插入和查询时间复杂度都是 O(k) 。存储空间和插入、查询时间都不会随元素增加而增大。空间、时间效率都很高。\n```\n\n### 哈希函数类型\n\n```\nMurmur3，FNV 系列和 Jenkins 等非密码学哈希函数适合，因为 Murmur3 算法简单，能够平衡好速度和随机分布，很多开源产品经常选用它作为哈希函数。\n```\n\n### 布隆过滤器支持删除吗？\n\n```\n布隆过滤器其实并不支持删除元素，因为多个元素可能哈希到一个布隆过滤器的同一个位置，如果直接删除该位置的元素，则会影响其他元素的判断。\n```\n\n## 3 开源项目实现\n\n### Guava实现\n\nGoogle Guava是 Google 开发和维护的开源 Java开发库，它包含许多基本的工具类，例如字符串处理、集合、并发工具、I/O和数学函数等等。\n\n**1、添加Maven依赖**\n\n```\n<dependency>\n    <groupId>com.google.guava</groupId>\n    <artifactId>guava</artifactId>\n    <version>31.0.1-jre<</version>\n</dependency>\n```\n\n**2、创建布隆过滤器**\n\n```java\nBloomFilter<Integer> filter = BloomFilter.create(\n  //Funnel 是一个接口，用于将任意类型的对象转换为字节流，\n  //以便用于布隆过滤器的哈希计算。\n  Funnels.integerFunnel(), \n  10000,  // 插入数据条目数量\n  0.001  // 误判率\n);\n```\n\n**3、添加数据**\n\n```java\n@PostConstruct\npublic void addProduct() {\n    logger.info(\"初始化布隆过滤器数据开始\");\n    //插入4个元素\n     filter.put(1L);\n     filter.put(2L);\n     filter.put(3L);\n     filter.put(4L);\n     logger.info(\"初始化布隆过滤器数据结束\");\n}\n```\n\n**4、判断数据是否存在**\n\n```java\npublic boolean maycontain(Long id) {\n    return filter.mightContain(id);\n}\n```\n\n### Redisson实现\n\nRedisson 是一个用 Java 编写的 Redis 客户端，它实现了分布式对象和服务，包括集合、映射、锁、队列等。Redisson的API简单易用，使得在分布式环境下使用Redis 更加容易和高效。\n\n**1、添加Maven依赖**\n\n```\n<dependency>\n   <groupId>org.redisson</groupId>\n   <artifactId>redisson</artifactId>\n   <version>3.16.1</version>\n</dependency>\n```\n\n**2、配置 Redisson 客户端**\n\n```\n@Configuration\npublic class RedissonConfig {\n\n Bean\n public RedissonClient redissonClient() {\n    Config config = new Config();\n    config.useSingleServer().setAddress(\"redis://localhost:6379\");\n    return Redisson.create(config);\n }\n \n}\n```\n\n**3、初始化**\n\n```\nRBloomFilter<Long> bloomFilter = redissonClient.\n                                      getBloomFilter(\"myBloomFilter\");\n//10000表示插入元素的个数，0.001表示误判率\nbloomFilter.tryInit(10000, 0.001);\n//插入4个元素\nbloomFilter.add(1L);\nbloomFilter.add(2L);\nbloomFilter.add(3L);\nbloomFilter.add(4L);\n```\n\n**4、判断数据是否存在**\n\n```\npublic boolean mightcontain(Long id) {\n    return bloomFilter.contains(id);\n}\n```\n\n**从源码分析 Redisson 布隆过滤器是如何实现的**\n\n[参考](https://mp.weixin.qq.com/s/0TSPT5PgFG_0pxklkcM3OA)\n\n\n\n## 4 实战要点\n\n### **1、缓存穿透场景**\n\n首先我们需要**初始化** 布隆过滤器，然后当用户请求时，判断过滤器中是否包含该元素，若不包含该元素，则直接返回不存在。\n\n若包含则从缓存中查询数据，若缓存中也没有，则查询数据库并回写到缓存里，最后给前端返回。\n\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/20594116857107811685710781730Cpqt7x-640-20230602205941617.png)\n\n### **2、元素删除场景**\n\n现实场景，元素不仅仅是只有增加，还存在删除元素的场景，比如说商品的删除。\n\n原理解析这一节，我们已经知晓：**布隆过滤器其实并不支持删除元素，因为多个元素可能哈希到一个布隆过滤器的同一个位置，如果直接删除该位置的元素，则会影响其他元素的判断** 。\n\n我们有两种方案：\n\n#### **计数布隆过滤器**\n\n计数过滤器（Counting Bloom Filter）是布隆过滤器的扩展，标准 Bloom Filter 位数组的每一位扩展为一个小的计数器（Counter），在插入元素时给对应的 k （k 为哈希函数个数）个 Counter 的值分别加 1，删除元素时给对应的 k 个 Counter 的值分别减 1。\n\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/21001416857108141685710814342ZcHtYu-640-20230602210014247.png)\n\n虽然计数布隆过滤器可以解决布隆过滤器无法删除元素的问题，但是又引入了另一个问题：“**更多的资源占用，而且在很多时候会造成极大的空间浪费** ”。\n\n#### **定时重新构建布隆过滤器**\n\n从工程角度来看，**定时重新构建布隆过滤器** 这个方案可行也可靠，同时也相对简单。\n\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/21005316857108531685710853982v3g1sy-640-20230602210053895.png)\n\n1.  定时任务触发全量商品查询 ;\n2.  将商品编号添加到新的布隆过滤器 ;\n3.  任务完成，修改商品布隆过滤器的映射（从旧 A 修改成 新 B ）;\n4.  商品服务根据布隆过滤器的映射，选择新的布隆过滤器 B进行相关的查询操作 ；\n5.  选择合适的时间点，删除旧的布隆过滤器 A。\n\n\n\n## 5 自己实现一个布隆过滤器\n\n### 基础布隆过滤器\n\n```java\nimport java.util.BitSet;\n\npublic class BloomFilter {\n    private static final int DEFAULT_SIZE = 1000000; // 默认布隆过滤器的大小\n    private static final int[] SEEDS = {3, 5, 7, 11, 13, 17, 19, 23}; // 哈希函数种子\n\n    private BitSet bitSet;\n    private HashFunction[] hashFunctions;\n\n    public BloomFilter() {\n        this(DEFAULT_SIZE);\n    }\n\n    public BloomFilter(int size) {\n        bitSet = new BitSet(size);\n        hashFunctions = new HashFunction[SEEDS.length];\n        for (int i = 0; i < SEEDS.length; i++) {\n            hashFunctions[i] = new HashFunction(size, SEEDS[i]);\n        }\n    }\n\n    public void add(String value) {\n        for (HashFunction hashFunction : hashFunctions) {\n            int hash = hashFunction.hash(value);\n            bitSet.set(hash, true);\n        }\n    }\n\n    public boolean contains(String value) {\n        for (HashFunction hashFunction : hashFunctions) {\n            int hash = hashFunction.hash(value);\n            if (!bitSet.get(hash)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static class HashFunction {\n        private int size;\n        private int seed;\n\n        public HashFunction(int size, int seed) {\n            this.size = size;\n            this.seed = seed;\n        }\n\n        public int hash(String value) {\n            int result = 0;\n            int len = value.length();\n            for (int i = 0; i < len; i++) {\n                result = seed * result + value.charAt(i);\n            }\n            return (size - 1) & result;\n        }\n    }\n}\n\n```\n\n### 定时重构布隆过滤器\n\n考虑元素删除情况, 使用\n\n```java\nimport java.util.BitSet;\nimport java.util.concurrent.TimeUnit;\n\npublic class BloomFilter {\n    private static final int DEFAULT_SIZE = 1000000; // 默认布隆过滤器的大小\n    private static final int[] SEEDS = {3, 5, 7, 11, 13, 17, 19, 23}; // 哈希函数种子\n\n    private BitSet bitSet;\n    private HashFunction[] hashFunctions;\n    private long rebuildInterval; // 重新构建布隆过滤器的时间间隔\n    private long lastRebuildTime; // 上次重新构建布隆过滤器的时间\n\n    public BloomFilter() {\n        this(DEFAULT_SIZE);\n    }\n\n    public BloomFilter(int size) {\n        bitSet = new BitSet(size);\n        hashFunctions = new HashFunction[SEEDS.length];\n        for (int i = 0; i < SEEDS.length; i++) {\n            hashFunctions[i] = new HashFunction(size, SEEDS[i]);\n        }\n        rebuildInterval = TimeUnit.DAYS.toMillis(1); // 默认重新构建时间间隔为1天\n        lastRebuildTime = System.currentTimeMillis();\n    }\n\n    public void setRebuildInterval(long intervalInMillis) {\n        this.rebuildInterval = intervalInMillis;\n    }\n\n    public void add(String value) {\n        for (HashFunction hashFunction : hashFunctions) {\n            int hash = hashFunction.hash(value);\n            bitSet.set(hash, true);\n        }\n    }\n\n    // 判断一个元素是否可能存在于布隆过滤器中\n    public boolean contains(String value) {\n        for (HashFunction hashFunction : hashFunctions) {\n            int hash = hashFunction.hash(value);\n            if (!bitSet.get(hash)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void remove(String value) {\n        if (!contains(value)) {\n            return;\n        }\n        for (HashFunction hashFunction : hashFunctions) {\n            int hash = hashFunction.hash(value);\n            bitSet.set(hash, false);\n        }\n    }\n\n    public void rebuild() {\n        bitSet.clear();\n        lastRebuildTime = System.currentTimeMillis();\n    }\n\n    public void periodicallyRebuild() {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastRebuildTime >= rebuildInterval) {\n            rebuild();\n        }\n    }\n\n    private static class HashFunction {\n        private int size;\n        private int seed;\n\n        public HashFunction(int size, int seed) {\n            this.size = size;\n            this.seed = seed;\n        }\n\n        public int hash(String value) {\n            int result = 0;\n            int len = value.length();\n            for (int i = 0; i < len; i++) {\n                result = seed * result + value.charAt(i);\n            }\n            return (size - 1) & result;\n        }\n    }\n}\n\n```\n\n\n\n### redis实现布隆过滤器\n\n```java\nimport redis.clients.jedis.Jedis;\n\npublic class RedisBloomFilter {\n    private final Jedis jedis;\n    private final String filterKey;\n    private final int size;\n    private final int hashFunctions;\n\n    public RedisBloomFilter(String host, int port, String filterKey, int size, int hashFunctions) {\n        jedis = new Jedis(host, port);\n        this.filterKey = filterKey;\n        this.size = size;\n        this.hashFunctions = hashFunctions;\n    }\n\n    public void add(String value) {\n        for (int i = 0; i < hashFunctions; i++) {\n            long index = hash(value, i);\n            jedis.setbit(filterKey, index, true);\n        }\n    }\n\n    public boolean contains(String value) {\n        for (int i = 0; i < hashFunctions; i++) {\n            long index = hash(value, i);\n            if (!jedis.getbit(filterKey, index)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private long hash(String value, int seed) {\n        long result = 0;\n        int len = value.length();\n        for (int i = 0; i < len; i++) {\n            result = seed * result + value.charAt(i);\n        }\n        return (size - 1) & result;\n    }\n}\n\n```\n\n\n\n\n\n## 6 总结\n\n-   **布隆过滤器** 是一个很长的**二进制向量** 和一系列**随机映射函数** ，用于**检索一个元素是否在一个集合中** 。\n\n-   它的**空间效率** 和**查询时间** 都**远远超过一般的算法** ，但是有一定的误判率 （函数返回 true , 意味着元素可能存在，函数返回 false ，元素必定不存在）。\n\n-   布隆过滤器的四个核心属性：\n\n    -   k :  哈希函数个数\n\n    -   m : 位数组长度\n\n    -   n :  插入的元素个数\n\n    -   p :  误判率\n\n\n-   Java 世界里 ，通过 Guava 和 Redisson 创建和使用布隆过滤器非常简单。\n\n-   布隆过滤器无法删除元素，但我们可以通过**计数布隆过滤器** 和**定时重新构建布隆过滤器** 两种方案实现删除元素的效果。\n\n-   为什么这么多的开源项目中使用布隆过滤器 ？\n\n    ```\n    因为它的设计精巧且简洁，工程上实现非常容易，效能高，虽然有一定的误判率，但软件设计不就是要 trade off 吗 ？\n    ```\n\n    \n\n\n\n## 7 疑问\n\n布隆过滤器无法删除元素，如何解决？\n\n```\n计数布隆过滤器 & 定时重构布隆过滤器\n```\n\n定时重构布隆过滤器过程中有其他方法在使用怎么办？\n\n```\n加锁\n```\n\n除了布隆过滤器 还有什么方法解决缓存穿透问题？\n\n```\n缓存空对象：当一个查询请求发现数据库中不存在对应的结果时，可以将空对象（如null或空列表）缓存起来。这样，下次同样的查询请求到来时，可以直接从缓存中获取结果，而不需要查询数据库。这种方式可以避免频繁查询数据库，但需要注意更新数据库时也要更新对应的缓存。\n\n延迟加载：将缓存中不存在的数据标记为\"正在加载\"状态，然后再次进行查询的时候等待加载完成。这样可以避免同时大量请求穿透缓存到达数据库，而是只有一个请求去查询数据库，其他请求等待结果即可。一旦数据加载完成，后续的查询请求就可以从缓存中获取到数据。\n\n限制请求频率：通过限制请求的频率，例如使用令牌桶算法或限流器，可以有效控制请求的并发量，减轻数据库的压力。这种方式可以防止缓存穿透问题的恶意攻击或异常情况下的大量请求。\n\n热点数据预加载：对于预先知道的热点数据，可以在系统启动或者定时任务中提前加载到缓存中。这样可以确保热点数据在缓存中存在，避免缓存穿透问题。\n\n异步加载：对于缓存中不存在的数据，可以通过异步方式从数据库中加载，并将加载完成的数据更新到缓存中。这样可以避免请求阻塞，提高系统的并发能力。\n```\n\n\n\n## 参考\n\n-   [品味布隆过滤器的设计之美](https://mp.weixin.qq.com/s/0TSPT5PgFG_0pxklkcM3OA)（主要）\n-   其他\n    -   [BloomFilter 布隆过滤器思想原理和代码实现](https://cloud.tencent.com/developer/article/2196903)\n    -   [布隆过滤器解决Redis缓存穿透](https://juejin.cn/post/7125236226189164575)\n    -   [布隆过滤器原理及使用场景](https://shaoyl.com/archives/bloome-filter)\n    -   [springboot中使用布隆过滤器BloomFilter](https://www.bmabk.com/index.php/post/80034.html)\n    -   [大数据处理 - Bitmap & Bloom Filter](https://www.pdai.tech/md/algorithm/alg-domain-bigdata-bloom-filter.html)\n        -   布隆过滤器的其他应用\n\n","timestamp":1691335064136},{"name":"04-springboot中使用布隆过滤器.md","path":"001-JAVA/001-Redis/04-springboot中使用布隆过滤器.md","content":"\n\n`pom.xml`引入\n\n```xml\n<dependency>\n    <groupId>com.google.guava</groupId>\n    <artifactId>guava</artifactId>\n    <version>27.0.1-jre</version>\n</dependency>\n```\n\n初始化布隆过滤器\n\n```java\npackage com.weteam.portal.config;\n\nimport com.google.common.hash.BloomFilter;\nimport com.google.common.hash.Funnels;\nimport com.weteam.common.util.RedisKeyUtil;\nimport com.weteam.common.util.RedisUtil;\nimport com.weteam.portal.dao.WtGameDao;\nimport com.weteam.portal.modal.entity.WtGame;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.stereotype.Component;\n\nimport java.nio.charset.Charset;\nimport java.util.List;\n\n/**\n * 布隆过滤器配置\n */\n@Component\npublic class BloomFilterConfig {\n    @Autowired\n    private WtGameDao gameDao;\n    @Autowired\n    private RedisUtil redisUtil;\n\n    /**\n     * 期望添加的数据个数\n     */\n    @Value(\"${bf.game.expected-insertions}\")\n    private Long gameExpectedInsertions ;\n\n    /**\n     * 误判率（大于0，小于1.0）,期望的误判率，期望的误判率越低，布隆过滤器计算时间越长\n     */\n    @Value(\"${bf.game.fpp}\")\n    private Double gameFpp;\n\n\n    /**\n     * 初始化game布隆过滤器\n     * @return\n     */\n    @Bean\n    public BloomFilter<String> gameBloomFilter() {\n        BloomFilter<String> bloomFilter = createBloomFilter();\n        loadBloomFilterGameData(bloomFilter);\n        return bloomFilter;\n    }\n\n    /**\n     * 创建一个布隆过滤器\n     * @return\n     */\n    public BloomFilter<String> createBloomFilter() {\n        return BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()),\n                gameExpectedInsertions, gameFpp);\n    }\n\n    /**\n     * 将数据添加到布隆过滤器 & redis\n     * @param bloomFilter\n     */\n    public void loadBloomFilterGameData(BloomFilter<String> bloomFilter) {\n        List<WtGame> games = gameDao.selectList(null);\n        for(WtGame game : games) {\n            String key = RedisKeyUtil.getGameKey(game.getId());\n            redisUtil.set(key, game);\n\n            // 存储到布隆过滤器\n            bloomFilter.put(String.valueOf(game.getId()));\n        }\n    }\n}\n\n```\n\n定时刷新重置，解决布隆过滤器无法删除元素的问题\n\n```java\npackage com.weteam.portal.task;\n\nimport com.google.common.hash.BloomFilter;\nimport com.google.common.hash.Funnels;\nimport com.weteam.common.exception.DefaultExceptionHandler;\nimport com.weteam.portal.config.BloomFilterConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n\n/**\n * 布隆过滤器定时任务\n */\n@Component\npublic class BloomFilterTasks {\n\n    private static Logger log = LoggerFactory.getLogger(DefaultExceptionHandler.class);\n\n    @Autowired\n    private BloomFilterConfig bloomFilterConfig;\n    @Autowired\n    private BloomFilter<String> gameBloomFilter;\n\n    @Scheduled(cron = \"0 0 0 * * ?\") // 每天凌晨0点执行\n    public void resetBloomFilter() {\n        log.info(\"===resetBloomFilter===\");\n        // 创建一个新的布隆过滤器实例来替代旧的过滤器对象\n        BloomFilter<String> newBloomFilter = bloomFilterConfig.createBloomFilter();\n        bloomFilterConfig.loadBloomFilterGameData(newBloomFilter);\n        gameBloomFilter = newBloomFilter;\n    }\n}\n\n```\n\n业务中使用布隆过滤器\n\n```java\n@RestController\n@RequestMapping(\"/games\")\npublic class WtGameController implements WeTeamConstant {\n    @Autowired\n    private BloomFilter<String> gameBloomFilter;\n  \n    @GetMapping(\"/testGameBloomFilter/{id}\")\n    public CommonResult<?> testGameBloomFilter(@PathVariable int id) {\n        // 用布隆判断缓存是否存在\n        boolean flag = gameBloomFilter.mightContain(String.valueOf(id));\n      \n        // 存在则去缓存中查， 不存在则去数据库中查\n      \tif(flag) {\n          \n        } else {\n          \n        }\n        return CommonResult.success(b);\n    }\n}\n```\n\n\n\n参考\n\n-   [SpringBoot中布隆过滤器的使用](https://blog.csdn.net/m0_52256357/article/details/126386755)\n-   [SpringBoot + Redis实现布隆过滤器](https://juejin.cn/post/7075115527219183646)\n-   [如何在springboot项目中redis使用布隆过滤器防止缓存穿透](https://blog.csdn.net/weixin_43748936/article/details/110225696?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-110225696-blog-115405043.235%5Ev36%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-110225696-blog-115405043.235%5Ev36%5Epc_relevant_default_base3&utm_relevant_index=5)","timestamp":1691335064136},{"name":"05-redis实践.md","path":"001-JAVA/001-Redis/05-redis实践.md","content":"[参考](https://mp.weixin.qq.com/s/I3fKeerhggozvx9FOUchpA)\n\nhttps://www.bmabk.com/index.php/post/126637.html\n\n\n\n### 1、缓存\n\nString类型\n\n例如：热点数据缓存（例如报表、明星出轨），对象缓存、全页缓存、可以提升热点数据的访问数据。\n\n### 2、数据共享分布式\n\nString 类型，因为 Redis 是分布式的独立服务，可以在多个应用之间共享\n\n例如：分布式Session\n\n```\n<dependency> \n\n <groupId>org.springframework.session</groupId> \n\n <artifactId>spring-session-data-redis</artifactId> \n\n</dependency>\n```\n\n### 3、分布式锁\n\nString 类型setnx方法，只有不存在时才能添加成功，返回true\n\n```\npublic static boolean getLock(String key) {\n\n    Long flag = jedis.setnx(key, \"1\");\n\n    if (flag == 1) {\n\n        jedis.expire(key, 10);\n\n    }\n\n    return flag == 1;\n\n}\n\n\n\n\npublic static void releaseLock(String key) {\n\n    jedis.del(key);\n\n}\n```\n\n### 4、全局ID\n\nint类型，incrby，利用原子性\n\nincrby userid 1000\n\n分库分表的场景，一次性拿一段\n\n### 5、计数器\n\nint类型，incr方法\n\n例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库\n\n### 6、限流\n\nint类型，incr方法\n\n以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false\n\n### 7、位统计\n\nString类型的bitcount（1.6.6的bitmap数据结构介绍）\n\n字符是以8位二进制存储的\n\n```\nset k1 a\n\nsetbit k1 6 1\n\nsetbit k1 7 0\n\nget k1 \n\n/* 6 7 代表的a的二进制位的修改\n\na 对应的ASCII码是97，转换为二进制数据是01100001\n\nb 对应的ASCII码是98，转换为二进制数据是01100010\n\n\n\n\n因为bit非常节省空间（1 MB=8388608 bit），可以用来做大数据量的统计。\n\n*/\n```\n\n例如：在线用户统计，留存用户统计\n\n```\nsetbit onlineusers 01 \n\nsetbit onlineusers 11 \n\nsetbit onlineusers 20\n```\n\n支持按位与、按位或等等操作\n\n```\nBITOPANDdestkeykey[key...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。       \n\nBITOPORdestkeykey[key...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 \n\nBITOPXORdestkeykey[key...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 \n\nBITOPNOTdestkeykey ，对给定 key 求逻辑非，并将结果保存到 destkey 。\n```\n\n计算出7天都在线的用户\n\n```\nBITOP \"AND\" \"7_days_both_online_users\" \"day_1_online_users\" \"day_2_online_users\" ...  \"day_7_online_users\"\n```\n\n### 8、购物车\n\nString 或hash。所有String可以做的hash都可以做\n\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/19345116857056911685705691915fwYL7h-640.png)\n\n-   key：用户id；field：商品id；value：商品数量。\n-   +1：hincr。-1：hdecr。删除：hdel。全选：hgetall。商品数：hlen。\n\n### 9、用户消息时间线timeline\n\nlist，双向链表，直接作为timeline就好了。插入有序\n\n### 10、消息队列\n\nList提供了两个阻塞的弹出操作：blpop/brpop，可以设置超时时间\n\n-   blpop：blpop key1 timeout 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n-   brpop：brpop key1 timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n\n上面的操作。其实就是java的阻塞队列。学习的东西越多。学习成本越低\n\n-   队列：先进先出：rpush blpop，左头右尾，右边进入队列，左边出队列\n-   栈：先进后出：rpush brpop\n\n### 11、抽奖\n\n自带一个随机获得值\n\n```\nspop myset\n```\n\n### 12、点赞、签到、打卡\n\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/193520168570572016857057209263ZKRq8-640-20230602193520841.png)图\n\n假如上面的微博ID是t1001，用户ID是u3001\n\n用 like:t1001 来维护 t1001 这条微博的所有点赞用户\n\n-   点赞了这条微博：sadd like:t1001 u3001\n-   取消点赞：srem like:t1001 u3001\n-   是否点赞：sismember like:t1001 u3001\n-   点赞的所有用户：smembers like:t1001\n-   点赞数：scard like:t1001\n\n是不是比数据库简单多了。\n\n### 13、商品标签\n\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/19355116857057511685705751784N4FgCX-640-20230602193551696.png)图片\n\n老规矩，用 tags:i5001 来维护商品所有的标签。\n\n-   sadd tags:i5001 画面清晰细腻\n-   sadd tags:i5001 真彩清晰显示屏\n-   sadd tags:i5001 流程至极\n\n### 14、商品筛选\n\n```\n// 获取差集\n\nsdiff set1 set2\n\n// 获取交集（intersection ）\n\nsinter set1 set2\n\n// 获取并集\n\nsunion set1 set2\n```\n\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/19355916857057591685705759629O9bgvR-640-20230602193559540.png)\n\n假如：iPhone11 上市了\n\n```\nsadd brand:apple iPhone11\n\n\n\n\nsadd brand:ios iPhone11\n\n\n\n\nsad screensize:6.0-6.24 iPhone11\n\n\n\n\nsad screentype:lcd iPhone 11\n```\n\n筛选商品，苹果的、ios的、屏幕在6.0-6.24之间的，屏幕材质是LCD屏幕\n\n```\nsinter brand:apple brand:ios screensize:6.0-6.24 screentype:lcd\n```\n\n### 15、用户关注、推荐模型\n\nfollow 关注 fans 粉丝\n\n相互关注：\n\n-   sadd 1:follow 2\n-   sadd 2:fans 1\n-   sadd 1:fans 2\n-   sadd 2:follow 1\n\n我关注的人也关注了他(取交集)：\n\n-   sinter 1:follow 2:fans\n\n可能认识的人：\n\n-   用户1可能认识的人(差集)：sdiff 2:follow 1:follow\n-   用户2可能认识的人：sdiff 1:follow 2:follow\n\n### 16、排行榜\n\nid 为6001 的新闻点击数加1：\n\n```\nzincrby hotNews:20190926 1 n6001\n```\n\n获取今天点击最多的15条：\n\n```\nzrevrange hotNews:20190926 0 15 withscores\n```\n\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/193635168570579516857057951871prZUh-640-20230602193635086.png)","timestamp":1691335064136},{"name":"06-数据库和缓存双写一致性问题.md","path":"001-JAVA/001-Redis/06-数据库和缓存双写一致性问题.md","content":"\n\n## 问题背景\n\n使用缓存的常见方式\n\n```\n用户请求过来之后，先查缓存有没有数据，如果有则直接返回。\n如果缓存没数据，再继续查数据库。\n如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。\n如果数据库也没数据，则直接返回空。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/10015016860169101686016910255xZYvGL-640.png\" alt=\"图片\" style=\"zoom:50%;\" />\n\n存在的问题：\n\n```\n如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？\n\n不更新缓存行不行？\n答：当然不行，如果不更新缓存，在很长的一段时间内（决定于缓存的过期时间），用户请求从缓存中获取到的都可能是旧值，而非数据库的最新值。这不是有数据不一致的问题？\n```\n\n更新缓存的4种方案\n\n```\n先写缓存，再写数据库\n先写数据库，再写缓存\n先删缓存，再写数据库\n先写数据库，再删缓存\n```\n\n## 更新缓存方式\n\n### 1 先写缓存，再写数据库\n\n#### 问题1：写数据库失败\n\n```\n某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了，缓存就变成脏数据了\n```\n\n### 2 先写数据库，再写缓存\n\n#### 问题1：写缓存失败\n\n```\n在写缓存过程中，出现网络异常导致写缓存失败\n数据库数据已更新，但缓存中还是旧值\n```\n\n#### 问题2：高并发下的问题\n\n假设在高并发的场景中，针对同一个用户的同一条数据，有两个写数据请求：a和b，它们同时请求到业务系统。\n\n其中请求a获取的是旧数据，而请求b获取的是新数据，如下图所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/101057168601745716860174573311V2LXi-640-20230606101057189.png\" alt=\"图片\" style=\"zoom:50%;\" />\n\n1.  请求a先过来，刚写完了数据库。但由于网络原因，卡顿了一下，还没来得及写缓存。\n2.  这时候请求b过来了，先写了数据库。\n3.  接下来，请求b顺利写了缓存。\n4.  此时，请求a卡顿结束，也写了缓存。\n\n很显然，在这个过程当中，请求b在缓存中的`新数据`，被请求a的`旧数据`覆盖了。\n\n也就是说：在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。\n\n#### 问题3：浪费系统资源\n\n```\n对于写多读少的业务，每次写操作都需要写缓存，比较浪费系统资源。\n```\n\n### 3 先删缓存，再写数据库\n\n#### 问题1：高并发下的问题\n\n假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求c，还有另一个写数据请求d（一个更新操作），同时请求到业务系统。如下图所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/10193316860179731686017973114G7KgaY-image-20230606101932996.png\" alt=\"image-20230606101932996\" style=\"zoom:50%;\" />\n\n```\n请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。\n这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。\n请求c将数据库中的旧值，更新到缓存中。\n此时，请求d卡顿结束，把新值写入数据库。\n\n总结：d删完缓存没写完数据库c就已经读数据了，读的就是mysql的旧值并存到缓存中\n```\n\n\n\n#### 改进：延迟双删\n\n```\n写数据库之前删除一次，写完数据库后，延迟再删除一次。\n\n流程：\n请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。\n这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。\n请求c将数据库中的旧值，更新到缓存中。\n此时，请求d卡顿结束，把新值写入数据库。\n一段时间之后，比如：500ms，请求d将缓存删除。\n```\n\n为什么一定要间隔一段时间之后，才能删除缓存呢？\n\n```\n请求d卡顿结束，把新值写入数据库后，请求c将数据库中的旧值，更新到缓存中。\n此时，如果请求d删除太快，在请求c将数据库中的旧值更新到缓存之前，就已经把缓存删除了，这次删除就没任何意义。必须要在请求c更新缓存之后，再删除缓存，才能把旧值及时删除了。\n所以需要在请求d中加一个时间间隔，确保请求c，或者类似于请求c的其他请求，如果在缓存中设置了旧值，最终都能够被请求d删除掉。\n```\n\n#### 问题2: 第二次删除缓存失败\n\n```\n\n```\n\n\n\n### 4 先写数据库，再删缓存\n\n在高并发的场景中，有一个读数据请求，有一个写数据请求，更新过程如下：\n\n1.  请求e先写数据库，由于网络原因卡顿了一下，没有来得及删除缓存。\n2.  请求f查询缓存，发现缓存中有数据，直接返回该数据。\n3.  请求e删除缓存。\n\n在这个过程中，只有请求f读了一次旧数据，后来旧数据被请求e及时删除了，看起来问题不大。\n\n但如果是读数据请求先过来呢？\n\n1.  请求f查询缓存，发现缓存中有数据，直接返回该数据。\n2.  请求e先写数据库。\n3.  请求e删除缓存。\n\n这种情况看起来也没问题呀？\n\n#### 问题1: 缓存到期\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/10274616860184661686018466845Io7rgq-640-20230606102746713.png\" alt=\"图片\" style=\"zoom:50%;\" />\n\n1.  缓存过期时间到了，自动失效。\n2.  请求f查询缓存，发缓存中没有数据，查询数据库的旧值，但由于网络原因卡顿了，没有来得及更新缓存。\n3.  请求e先写数据库，接着删除了缓存。\n4.  请求f更新旧值到缓存中。\n\n\n\n这时，缓存和数据库的数据同样出现不一致的情况了。\n\n但这种情况还是比较少的，需要同时满足以下条件才可以：\n\n1.  缓存刚好自动失效。\n2.  请求f从数据库查出旧值，更新缓存的耗时，比请求e写数据库，并且删除缓存的还长。\n\n我们都知道查询数据库的速度，一般比写数据库要快，更何况写完数据库，还要删除缓存。所以绝大多数情况下，写数据请求比读数据情况耗时更长。\n\n由此可见，系统同时满足上述两个条件的概率非常小。\n\n#### 问题2: 缓存删除失败\n\n```\n\n```\n\n\n\n### 缓存删除失败\n\n增加重试机制\n\n```\n在接口中如果更新了数据库成功了，但更新缓存失败了，可以立刻重试3次。如果其中有任何一次成功，则直接返回成功。如果3次都失败了，则写入数据库，准备后续再处理。\n当然，如果你在接口中直接同步重试，该接口并发量比较高的时候，可能有点影响接口性能。\n```\n\n改进：异步重试\n\n```\n每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统OOM问题，不太建议使用。\n将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。\n将重试数据写表，然后使用elastic-job等定时任务进行重试。\n将重试的请求写入mq等消息中间件中，在mq的consumer中处理。\n订阅mysql的binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。\n```\n\n### 参考\n\n-   [如何保证数据库和缓存双写一致性？](https://mp.weixin.qq.com/s/DsZgnwIqW3jrE5KxShGKeg)\n-   [江南一点雨：如何保证缓存和数据库的一致性？](https://mp.weixin.qq.com/s/7-vUDQGj8mZIeryZA3gEiw)","timestamp":1691335064136},{"name":"07-缓存穿透、缓存击穿、缓存雪崩.md","path":"001-JAVA/001-Redis/07-缓存穿透、缓存击穿、缓存雪崩.md","content":"\n\n| 概念 |    **关键**     | **含义**                                                     | **解决方案**                                                 |\n| :--------: | :-------------: | :----------------------------------------------------------- | :----------------------------------------------------------- |\n|  缓存雪崩  |   Key集体失效   | 某个时间点，缓存中的Key集体发生过期失效致使大量查询数据库的请求都落在DB上，导致DB负载过高 | 不同时失效：为Key设置不同的、随机TTL，错开缓存中的Key的失效时间点，减少DB压力 |\n|  缓存穿透  | 缓存查询不到Key | 缓存中查询不到Key，导致直接查询DB                            | 缓存空值+过期时间                                            |\n|  缓存击穿  |   热点Key失效   | 热点Key（被频繁访问的Key）突然失效，持续的高并发击穿缓存，直接请求DB，导致DB压力在瞬间暴增。 | 热点数据不过期互斥锁                                         |\n\n![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/11304716860222471686022247235rQCYgd-640-20230606113047113.png)\n\n## 缓存穿透\n\n### 是什么\n\n```\n缓存中无法缓存某个key值，但大量请求访问这个key值，导致这些请求绕过缓存系统，直接访问数据库\n比如请求 id < 0 的数据\n\n（与缓存击穿的区别是：缓存穿透中，这个key永远也不会存在）\n```\n\n### 出现场景\n\n```\n（1）缓存失效，大量请求访问同一个数据，此时缓存为空，所以会直接访问数据库\n（2）查询不存在的数据：比如查询id<1的数据，或者数据库中不存在的数据\n```\n\n### 解决方案：\n\n```\n（1）布隆过滤器：使用布隆过滤器来过滤掉非法或无效的请求，如果请求数据不存在于布隆过滤器中，则直接拦截该请求，避免绕过缓存。\n（2）缓存空值：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。\n（3）接口校验、限流：对频繁访问不存在数据的请求进行限流，防止大量请求同时访问后端系统。\n```\n\n#### 实现：缓存空值\n\n```java\n @GetMapping(\"/penetrate\")\n    public String cachePenetrate(Integer id) {\n        String cacheKey = \"penetrate:\" + id;\n        long cacheTime = 30L;\n\n        //缓存查询\n        String cacheValue = (String) redisTemplate.opsForValue().get(cacheKey);\n        if (cacheValue == null) {\n            //缓存没有，查询数据库\n            Product product = productService.getById(id);\n            if (product == null) {\n                //数据库没有，设置空值或默认值\n                cacheValue = \"\";\n            } else {\n                cacheValue = product.getName();\n            }\n            redisTemplate.opsForValue().set(cacheKey, cacheValue, cacheTime, TimeUnit.SECONDS);\n        }\n\n        return cacheValue;\n    }\n```\n\n缓存空值的时间如何设置\n\n```\n一般来说，空值缓存的时间可以设置为一个较短的时间，但也要根据业务的实际情况来调整。\n（1）较短时间。\n（2）与实际数据有效期相同\n（3）永久有效：这样做可以避免频繁地查询后端系统，但需要注意及时处理实际数据的更新，避免因为数据的变动而导致缓存的不一致。\n```\n\n缓存空值明显比使用布隆过滤器要简单得多，所以为什么不都用缓存空值方法呢？\n\n```\n使用缓存空值来解决缓存穿透问题确实是一种简单有效的方法，但它并不适用于所有场景。下面是一些考虑因素：\n\n  1 缓存空值会占用一定的内存空间。如果缓存的键空间非常大或者频繁出现缓存穿透的情况，可能会导致大量的空值占用内存，从而浪费资源。\n  2 缓存空值可能引起数据不一致。如果在缓存中存储了空值，并且在数据库中实际上存在该数据，那么在缓存失效之前，应用程序仍然会获取到空值，从而导致数据不一致的问题。\n  3 缓存空值可能增加了开发和维护的复杂性。在实现缓存空值的处理逻辑时，需要特别注意维护缓存和数据库的一致性。如果在业务逻辑中存在复杂的查询和更新操作，可能需要更复杂的处理方式来保证数据的一致性。\n\n相比之下，布隆过滤器是一种更通用和可靠的解决方案，可以有效地过滤掉不存在于数据库中的数据，从而减轻数据库的压力。虽然布隆过滤器的实现和维护可能相对复杂一些，但它具有较低的内存占用和较高的查询效率，适用于大规模的数据集和高并发场景。\n\n选择使用缓存空值还是布隆过滤器，需要根据具体的业务需求和系统特点进行综合考虑。如果系统数据量较小，且缓存穿透问题较为频繁且明显，可以考虑使用缓存空值。如果系统数据量较大，或者需要更精确地控制缓存的一致性和效率，布隆过滤器是更好的选择。\n```\n\n一般什么样的业务才需要考虑缓存穿透问题？\n\n```\n【答缓存穿透出现的场景，同上方】\n\n缓存穿透问题通常在以下情况下需要考虑：\n\n查询不存在的数据：当频繁查询一些不存在的数据时，如果每次都直接查询数据库，会对数据库造成无谓的压力，同时还会占用系统资源。例如，用户输入错误的ID进行查询、恶意攻击等。\n\n数据库中无效的数据：某些数据在数据库中被标记为无效或已删除状态，但仍然频繁查询这些数据，会浪费数据库资源。通过缓存来避免频繁查询无效数据，可以提高系统性能和资源利用率。\n\n高并发场景：在高并发场景下，如果大量请求同时查询同一份数据，而该数据不在缓存中，会导致这些请求都穿透到数据库，增加数据库的负载压力。在这种情况下，需要防止缓存穿透，避免对数据库造成过大压力。\n\n总之，当存在频繁查询不存在的数据、查询无效数据或高并发场景下，就需要考虑缓存穿透问题。通过合理的缓存策略和技术手段，如布隆过滤器、缓存空值等，可以有效地避免缓存穿透问题，提高系统性能和资源利用率。\n```\n\n\n\n## 缓存击穿\n\n### 是什么\n\n```\n缓存中存在某个key值，在过期时有大量并发请求访问这个key，发现过期后直接访问数据库，从而给数据源造成巨大压力，甚至导致数据源崩溃的情况。\n\n（与缓存穿透的区别是：缓存穿透中，这个key永远也不会存在）\n```\n\n### 出现场景\n\n```\n（1）热点数据：热点数据过期，大量并发请求访问\n（2）请求穿透：缓存不存在，大量并发请求访问\n```\n\n### 解决方案\n\n```\n防过期：\n（1）设置key永不过期（或者逻辑过期）。对于一些热点数据，可以将其缓存的过期时间设置为永不过期。这样即使缓存失效，也能够在下一次请求中重新加载到缓存中，减轻数据源的压力。\n（2）互斥锁。在缓存失效的时候，通过互斥锁来保证只有一个线程可以访问数据源并重新加载缓存。其他线程等待锁释放后，直接从缓存中获取数据。这种方式可以避免多个线程同时访问数据源，减少数据源的压力。\n\n防数据不存在：\n（1）提前预加载：可以在系统启动时或者低峰期预先加载一部分热门数据到缓存中，提前占位，避免大量请求同时访问缓存失效的情况。\n（2）校验接口：使用布隆过滤器，判断请求的数据是否存在于缓存中，从而避免对于不存在的数据频繁访问后端数据库。\n（3）限流\n```\n\n设置热点数据永不过期，为什么还会出现缓存失效?\n\n```\n当我们将热点数据的缓存设置为永不过期时，意味着该数据在缓存中将一直存在，不会因为过期时间而被自动删除。但是，仍然有可能出现缓存失效的情况，这可能是由于以下原因：\n\n1 服务器重启或缓存系统重启：当服务器或缓存系统重启时，缓存数据会被清空，包括热点数据。即使设置了永不过期，重启后仍然需要重新加载数据到缓存中。\n\n2 内存不足或缓存溢出：如果缓存系统的内存不足，可能会导致部分数据被淘汰或清除，包括热点数据。在这种情况下，即使数据设置为永不过期，仍然可能出现缓存失效的情况。\n\n3 数据变更或过期检查错误：有些缓存系统可能会对缓存数据进行过期检查，并在一定时间内重新加载数据。如果过期检查的逻辑有误，可能会错误地将热点数据标记为过期，并清除缓存。\n\n4 分布式缓存环境下的数据同步问题：在分布式缓存环境中，多个缓存节点可能存在数据不一致的情况。即使设置了永不过期，如果数据在某个节点上被删除或更新，其他节点可能无法感知，导致缓存失效。\n\n综上所述，尽管将热点数据设置为永不过期可以延长其在缓存中的存储时间，但仍然需要注意上述情况可能导致缓存失效的情况。因此，在实际应用中，除了设置永不过期外，还需要考虑缓存的持久性、容错性和一致性等因素，结合具体的业务场景和缓存系统的特点，制定合适的缓存策略和失效处理机制。\n```\n\n一般什么样的业务才需要考虑缓存击穿问题？\n\n```\n缓存击穿问题通常在以下情况下需要考虑：\n\n热点数据访问频繁：某些数据在系统中被频繁访问，例如热门商品、热门新闻等。由于大量并发请求同时访问该数据，可能导致缓存失效，从而导致数据库被频繁查询，增加数据库压力。\n\n数据库性能较低：如果数据库性能较低或存在较高的延迟，频繁查询数据库可能会导致系统响应变慢。在这种情况下，使用缓存可以显著提升系统的响应速度。\n\n大规模数据查询：当进行大规模数据查询时，如数据报表生成、数据分析等，如果每次都直接查询数据库，会对数据库造成较大压力。通过缓存可以减轻数据库的负载，提高查询性能。\n\n外部接口调用：如果系统依赖外部接口，而外部接口的响应时间较长，频繁调用可能会导致系统的响应变慢。通过缓存可以缓解对外部接口的频繁调用，提高系统的性能和可靠性。\n\n总之，任何访问频繁且对性能要求较高的业务都可能面临缓存击穿问题。在这些情况下，合理地使用缓存策略可以提高系统性能和可靠性，并降低数据库压力。\n```\n\n\n\n#### 逻辑过期：双缓存\n\n缓存标记：记录缓存数据是否过期，如果过期就去更新实际key的缓存；\n缓存数据：它的过期时间比缓存标记的时间延长1倍。这样，当缓存标记过期后，实际缓存还能把旧数据返回给调用端，直到新的key值更新完成后，才会返回新缓存\n\n```java\n    @GetMapping(\"/avalanche2\")\n    public String cacheAvalanche2(Integer id) {\n        String cacheKey = \"avalanche:\" + id;\n        String signKey = \"avalanche:sign\" + id;\n        long cacheTime = 60L;\n\n        //缓存查询\n        String cacheValue = (String) redisTemplate.opsForValue().get(cacheKey);\n        //缓存标记\n        String signValue = (String) redisTemplate.opsForValue().get(signKey);\n        if (signValue == null) {\n            //缓存标记过期\n            //设置成功的去查询数据库并更新缓存，其余的返回旧的缓存值(缓存值的时间是缓存标记的2倍)\n            if (redisTemplate.opsForValue().setIfAbsent(signKey, \"1\", cacheTime, TimeUnit.SECONDS)) {\n                //查询数据库\n                Product product = productService.getById(id);\n                cacheValue = product.getName();\n                redisTemplate.opsForValue().set(cacheKey, cacheValue, cacheTime * 2, TimeUnit.SECONDS);\n            }\n        }\n\n        return cacheValue;\n    }\n```\n\n参考\n\n-   [springboot：整合redis解决缓存击穿，缓存雪崩，缓存穿透](https://blog.csdn.net/weixin_43296313/article/details/125447527)\n\n\n\n#### 逻辑过期 + 互斥锁\n\n设置较长的过期时间替代永不过期，过期时通过加锁查询\n\n```java\n@GetMapping(\"/testRedisLock/{id}\")\npublic CommonResult<?> testRedisLock(@PathVariable int id) {\n    WtGame game = gameService.findById(id);\n    return CommonResult.success(game);\n}\n```\n\n```java\n  @Override\n    public WtGame findById(int gameId) {\n        WtGame game = null;\n        // 尝试从缓存中获取\n        String gameKey = RedisKeyUtil.getGameKey(gameId);\n        game = (WtGame) redisUtil.get(gameKey);\n        if(game != null) {\n            if(game.getId() == null) {\n                System.out.println(\"缓存为空\");\n                return null;\n            }\n            System.out.println(\"从缓存中获取\");\n            return game;\n        }\n\n        // 无缓存, 加锁查询\n        String requestId = String.valueOf(gameId + Thread.currentThread().getId());\n        String lockKey = LOCK_GAME_KEY + gameId;\n        boolean isLock = redisLock.tryLock(lockKey, requestId, Duration.ofSeconds(1));\n        try {\n            // 获取锁失败：休眠，重试\n            if(!isLock) {\n                Thread.sleep(100);\n                return findById(gameId);\n            }\n\n            // 获取成功, 查询数据库\n            game = gameDao.selectById(gameId);\n            System.out.println(\"从数据库中获取\" + game);\n            if(game == null) {\n                redisUtil.set(gameKey, new WtGame(), 30);\t\t// 存短期空值，避免其他阻塞请求查询数据库\n            } else {\n                redisUtil.set(gameKey, game);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            // 释放锁\n            redisLock.unlock(lockKey, requestId);\n        }\n\n        return game;\n    }\n```\n\n\n\n参考\n\n-   [Redis缓存击穿解决方案之互斥锁](https://juejin.cn/post/7096734273210122253)\n-   [高性能缓存实践-解决缓存击穿-单应用互斥锁](https://blog.csdn.net/qq_28817739/article/details/108973154)\n\n## 缓存雪崩\n\n### 是什么\n\n```\n缓存中大量数据失效，导致大量请求直接访问后端数据库，给数据库带来巨大压力，甚至崩溃\n\n跟缓存击穿不一样，雪崩是大量key集体过期\n```\n\n### 出现场景\n\n```\n（1）缓存服务器宕机\n（2）缓存集体失效\n```\n\n### 解决方案\n\n```\n缓存集体失效：\n（1）key不集体失效。在原有的失效时间基础上增加一个随机值，减少集体失效\n（2）二级缓存：引入多级缓存架构\n\n过期如何处理\n（3）加锁排队\n（4）限流\n```\n\n方案：实现加锁排队\n\n采用加锁排队有可能还要解决分布式锁的问题，线程还会被阻塞，用户体验很差\n\n```java\n@GetMapping(\"/avalanche\")\n    public String cacheAvalanche(Integer id) {\n        String cacheKey = \"avalanche:\" + id;\n        long cacheTime = 30L;\n\n        //缓存查询\n        String cacheValue = (String) redisTemplate.opsForValue().get(cacheKey);\n        if (cacheValue == null) {\n            //缓存没有，使用互斥锁查询数据库更新缓存，其余阻塞排队\n            synchronized (cacheKey) {\n                //此时可能有缓存数据了\n                cacheValue = (String) redisTemplate.opsForValue().get(cacheKey);\n                if (cacheValue == null) {\n                    //缓存还是没有，查询数据库\n                    Product product = productService.getById(id);\n                    cacheValue = product.getName();\n                    //回设缓存\n                    redisTemplate.opsForValue().set(cacheKey, cacheValue, cacheTime * 10, TimeUnit.SECONDS);\n                }\n            }\n        }\n\n        return cacheValue;\n    }\n```\n\n\n\n## 参考\n\n-   [Redis：缓存雪崩，缓存穿透，缓存击穿](https://mp.weixin.qq.com/s/T_AxoAwCbzKGhvjiluMxQw)\n-   [springboot：整合redis解决缓存击穿，缓存雪崩，缓存穿透](https://blog.csdn.net/weixin_43296313/article/details/125447527)\n-   [SpringBoot中如何解决Redis的缓存穿透、缓存击穿、缓存雪崩？](https://juejin.cn/post/7210212440670945335)","timestamp":1691335064136},{"name":"02-基础.md","path":"001-JAVA/002-计算机网络/02-基础.md","content":"## 计算机网络基础\n\n### 网络分层模型\n\n#### OSI七层模型是什么？每一层的作用是什么？\n\n```\n（1）应用层：为计算机用户提供服务，比如Dns、http、\n（2）表示层：数据处理（编解码、加密解密、压缩解压缩）\n（3）会话层：管理（建立、维护、重连）应用程序之间的会话\n（4）传输层：为两台主机之间的通信提供通用的数据传输服务，如TCP、UDP\n（5）网络层：路由和寻址（决定数据在网络的游走路径），如IP协议\n（6）数据链路层：将网络层传下来的IP数据包组装成帧，并在相邻节点的链路上传送帧\n（7）物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异\n```\n\n#### TCP/IP四层模型是什么？每一层的作用是什么？\n\n```\n是目前被广泛采用的一种模型，可以看作是OSI七层模型的精简版\n\n（1）应用层：\n（2）传输层：\n（3）网络层：\n（4）网络接口层：\n```\n\n#### 为什么网络要分层？\n\n```\n（1）模块化和解耦：每个层次负责特定的功能，各层之间通过定义好的接口进行通信，使得网络的设计更加模块化和解耦。一旦某个层次发生变化，不会对其他层次产生影响。\n（2）可靠性和灵活性：分层结构使得网络功能相互独立，可以根据需要灵活地增加、删除或修改某个层次的功能，而不会对整个网络产生影响。\n（3）可拓展性：可以新增新的层次或协议，以满足不断增长的网络需求，而无需对已有层次进行修改。\n（4）通用性：可以通过使用标准的协议和接口，不同厂商的设备和应用可以更容易地进行互操作，实现通用性和互联互通\n```\n\n\n\n\n\n\n\n\n\n\n\n## PING\n\n### PING 命令的作用是什么？\n\n```\n是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟\n```\n\n### PING 命令的工作原理是什么？\n\n```\nICMP\n\nTODO：https://javaguide.cn/cs-basics/network/other-network-questions.html#ping-命令的作用是什么\n```\n\n\n\n## DNS\n\n### DNS 的作用是什么？\n\n```\nDNS是应用层协议，即域名管理系统，主要解决的是域名和ip地址的映射\n```\n\n### DNS工作流程\n\n```\ndns的查询解析过程分为两种模式：\n（1）迭代\n（2）递归\n```\n\n（1）迭代\n\n```\n（1）主机向本地dns服务器发送dns请求\n（2）本地dns服务器查询本机缓存，如果没有记录，则向根服务器发送请求\n（3）根服务器解析，告诉本地dns去查询顶级域名服务器\n（4）本地dns去查询顶级域名服务器，让它去查权威dns服务器\n\nhttps://javaguide.cn/cs-basics/network/dns.html#dns-记录\n```\n\n","timestamp":1691335064136},{"name":"03-HTTP.md","path":"001-JAVA/002-计算机网络/03-HTTP.md","content":"## HTTP\n\n### 从输入 URL 到页面展示到底发生了什么？\n\n```\n（1）DNS解析：浏览器将URL中的主机名发送给本地DNS服务器，以获取对应的IP地址。本地DNS服务器查询全球分布的根DNS服务器，并逐步向下查询，直到查到目标域名对应的ip地址。\n（2）TCP连接：浏览器根据获取到的IP地址，与服务器建立TCP连接\n（3）发送HTTP请求：TCP建立连接后，浏览器会发送一个HTTP请求到服务器，请求获取网页的资源。HTTP请求包括请求方法、URL、请求头、请求体等。\n（4）服务器处理请求并返回HTTP报文：服务器处理请求，并将生成的HTTP响应发送回浏览器。响应包括了状态码、响应头、响应体等信息。响应体中包含了请求的资源，比如html、css、图片等\n（5）浏览器解析渲染页面\n（6）连接结束\n\nhttps://javaguide.cn/cs-basics/network/other-network-questions.html#从输入-url-到页面展示到底发生了什么-非常重要\n```\n\n### HTTP 状态码有哪些？\n\n![常见 HTTP 状态码](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/01/14241516908710551690871055846D6MmiG-11280716905148871690514887827Ypzds9-http-status-code.png)\n\n### HTTP 和 HTTPS 有什么区别？\n\n```\n（1）安全性：\n\t\t- http是明文传输协议，传输的所有数据都是以明文形式发送，容易被窃听和篡改\n\t\t- https是通过SSL/TLS协议进行加密传输，可以保证数据的安全性\n（2）端口\n\t\t- http使用80端口进行通信\n\t\t- https使用443端口进行通信\n（3）证书：\n\t\t- 使用https的网站需要使用ssl证书，用于验证服务器的身份。这样客户端可以确保自己的连接是正确的服务器，而不是伪造的服务器。\n（4）SEO（搜索引擎优化）：搜索引擎更青睐使用https协议的网站，因为https能提供更高的安全性和用户体验。\n```\n\n###  HTTP/1.0 和 HTTP/1.1 有什么区别？TODO\n\n```\n（1）连接方式\n\t\t- http1.0是短链接，即每次请求都需要建立一个新的tcp连接，请求完后立即关闭连接\n\t\t- http1.1是长连接，即在一个tcp连接上可以发送多个请求和响应，减少连接建立和关闭的开销，提高了性能。\n（2）缓存处理：\n\t\t- \n\n\nhttps://javaguide.cn/cs-basics/network/http1.0-vs-http1.1.html\n```\n\n### HTTP/1.0 和 HTTP/1.1 有什么区别？\n\n### HTTP/1.1 和 HTTP/2.0 有什么区别？\n\n###  HTTP/2.0 和 HTTP/3.0 有什么区别？\n\n\n\n### HTTP 是不保存状态的协议, 如何保存用户状态?\n\n```\nhttp是一种无状态协议，http协议自身不对请求和响应之间的通信状态进行保存。\n\n保存状态的方法：\n（1）cookies：通过在客户端浏览器上设置cookies，可以将一些用户信息存储在客户端，每次请求时，将这些信息发送到服务器。服务器可以读取这些cookies，从而实现用户状态的跟踪和管理。\n（2）session：服务器可以在用户登录之后创建一个session，将用户相关的信息保存在服务器上，然后将sessionID发送给客户端浏览器，通过cookies来保存，客户端在后续的请求中通过这个sessionID与服务器建立关联，从而维护用户状态。\n（3）Token：在一些前后端分离的应用中，通过token来保存用户信息，用户登录之后，服务器颁发一个带有有效期的令牌，客户端将令牌存储起来，在后续请求中携带这个token，服务器可以根据token来验证用户的身份和权限\n\nchatgpt\n```\n\n### Cookie 被禁用怎么办?\n\n```\n将sessionID附在url路径后面\n```\n\n###  Cookie 和 Session 有什么区别？\n\n```\n都是用户维护用户状态的方法\n- cookie将用户信息存储在客户端，存储容量较小，相对较不安全\n- session将用户信息存储在服务器，存储容量较大，用户无法直接访问和修改，相对比较安全\n```\n\n### URI 和 URL 的区别是什么?\n\n```\nURI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。\nURL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。当url可以唯一表示一个资源时，它就是uri\n\nURI 的作用像身份证号一样，URL 的作用更像家庭住址一样。\n```\n\n\n\n","timestamp":1691335064136},{"name":"04-TCP.md","path":"001-JAVA/002-计算机网络/04-TCP.md","content":"## TCP基本认识\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/01/14301816908714181690871418304qhbr63-format,png-20230309230534096.png\" alt=\"TCP 头格式\" style=\"zoom:50%;\" />\n\n\n\n### 什么是TCP？\n\n```\nTCP 是面向连接的、可靠的、基于字节流的传输层通信协议。\n\n（1）面向连接：在传输数前，TCP会建立一个连接，然后在连接上传输数据，传输完后关闭连接。\n（2）可靠的：通过序列号、确认、重传、流量控制、拥塞控制和校验和等机制，确保TCP的可靠传输。无论网络链路出现了怎么样变化，TCP都可以保证一个报文，一定能够到达接收端。\n（3）字节流：如何理解TCP是面向字节流协议的？\n```\n\n### 如何理解TCP是面向字节流协议的？？？？\n\n```\n用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。\n```\n\n### 如何唯一确定一个 TCP 连接呢？\n\n```\n源地址\n源端口\n目标地址\n目标端口\n```\n\n\n\n## TCP和UDP\n\n### TCP 与 UDP 的区别？\n\n```\n（1）连接性\n\t\t- TCP是面向连接的协议，传输数据之前需要建立连接，结束后需要释放连接\n\t\t- UDP是无连接协议，连接前不需要建立连接\n（2）可靠性：\n\t\t- TCP保证数据的可靠传输。通过序列号、确认、重传、流量控制、拥塞控制、校验和等机制来保证数据的完整性和顺序性。如果数据包丢失或损坏，TCP会自动重传数据。\n\t\t- UDP不保证数据的可靠传输。远程主机接受报文不需要确认，并不关心数据是否到达目的地\n（3）传输效率\n\t\t- TCP需要连接、确认、重传等机制，所以TCP比UDP慢很多\n（4）传输形式\n\t\t- TCP是面向字节流的，首部开销20-60字节\n\t\t- UDP是面向报文的，首部开销8字节\n（5）广播、多播\n\t\t- TCP只支持点对点通信\n\t\t- UDP支持一对一、一对多、多对一、多对多\n\t\t\nhttps://javaguide.cn/cs-basics/network/other-network-questions2.html#tcp-与-udp-的区别-重要\n```\n\n### 什么时候选择 TCP，什么时候选 UDP?\n\n```\n（1）TCP用于对传输准确性要求特别高的场景，如文件传输、发送和接收邮件、远程登录等\n（2）UDP一般用于即时通信，比如语音、视频、直播，对传输数据的准确性要求不是特别高\n```\n\n###  HTTP 基于 TCP 还是 UDP？TODO\n\n```\nHTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。\n\nhttps://javaguide.cn/cs-basics/network/other-network-questions2.html#什么时候选择-tcp-什么时候选-udp\n```\n\n### 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?\n\n```\ntcp:\n（1）HTTP：超文本传输协议\n（2）https\n（3）ftp\n（4）SMTP\n（5）ssh\n\nudp\n（1）dhcp\n（2）dns\n```\n\n## 三次握手 & 四次挥手\n\nhttps://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html\n\nhttps://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-三次握手过程是怎样的\n\n### TCP 三次握手\n\n#### 三次握手流程\n\n <img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/28/201503169054650316905465032715kjBPy-tcp-shakes-hands-three-times.png\" alt=\"TCP 三次握手图解\" style=\"zoom:50%;\" />\n\n```\n（1）一次握手：客户端发送带有SYN（seq=x）标志的数据包->服务端，然后客户端进入SYN_SEND状态，等待服务器确认；\n（2）二次握手：服务端发送带有SYN+ACK(seq=y, ack=x+1)标志的数据包->客户端，然后服务端进入SYN_RECV状态\n（3）三次握手：客户端发送带有ACK（seq=y+1）标志的数据包->服务端，然后客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。\n\nSYN+ACK报文指的是SYN和ACK字段置为1\nseq=y表示序列号为y\nack=x+1表示确认应答号为x+1\n```\n\n#### 为什么要三次握手？不是两次、四次？\n\n```\n最基本的原因：三次握手的目的是为了建立可靠的通信信道，让双方确认确认自己与对方的发送和接收都是正常的。\n（1）第一次握手：client什么也不能确认；server确认了自己接收正常，对方发送正常\n（2）第二次握手：client确认自己发送和接收正常，对方发送接收正常；server不能确认自己发送是否正常、对方接收是否正常\n（3）第三次握手：让server确认自己发送和接收正常，对方发送和接收正常\n\n分析三次握手的原因：\n（1）避免历史连接，浪费资源（主要原因）\n（2）三次握手才可以同步双方的初始序列号\n```\n\n避免历史连接，浪费资源\n\n```\n三次握手如何阻止历史连接：\n（1）先发送一个连接请求（seq=90）阻塞在网络中，超时后发送新的连接请求（seq=100）\n（2）「旧的SYN报文」比「新的SYN」报文到达服务端。此时服务器就会回复一个SYN+ACK报文（ack=91）\n（3）客户端收到后发现期望的ack是100+1，于是就会回复一个RST报文终止连接\n（4）客户端收到后序新的SYN报文后正常完成三次握手\n\n两次握手的问题：\n（1）收到旧的SYN报文后，就建立连接，回复一个ack=91\n（2）客户端收到消息后发现不是自己期望的确认号，就回复一个RST报文终止连接。但是服务端已经初始化连接了，就会白白浪费资源\n（3）收到新的SYN则正常建立连接\n```\n\n同步双方的初始序列号\n\n```\n序列号的作用：\n（1）接收方可以去重\n（2）排序\n（3）告诉发送方哪些已经被接收\n\n两次握手的问题：\n只能保证发送方的初始序列号被服务端接收\n\n四次握手：\n可以保证双方同步初始序列号，但是第二第三步可以合并优化\n```\n\n#### 第 2 次握手传回了 ACK，为什么还要传回 SYN？\n\n```\n（1）回传ACK，是为了告诉客户端，接收到的信息就是客户端发送的信号，表明客户端到服务端的通信是正常的。\n（2）回传SYN是为了建立并确认服务端到客户端的通信。\n```\n\n#### 第一次握手丢失了，会发生什么？\n\n```\n第一次握手，客户端发送一个SYN报文，然后进入SYN_SEND状态\n如果丢失，一直收不到服务端的SYN+ACK（第二次握手），就会触发「超时重传」机制，重传SYN报文，重传的SYN报文序列号都是一样的。\n每次超时的时间都是上一次的2倍，超过「最大重传次数」后，如果还是没有回应，就会断开TCP连接，不再发生SYN报文\n```\n\n#### 第二次握手丢失了，会发生什么？\n\n```\n（1）第二次握手是什么？\n（2）第二次握手的ACK是对第一次握手的确认，由于第二次丢失后，客户端迟迟收不到，就会认为自己发送的SYN丢失，客户端就会触发超时重传机制，重传SYN报文\n（3）第二次握手的SYN需要客户端回复ACK确认，由于第二次丢失，客户端收不到也就不会回传，所以服务端会触发超时重传机制，重传SYN-ACK报文\n（4）超过最大重传次数后就不再发送，断开连接\n```\n\n#### 第三次握手丢失了，会发生什么？\n\n```\n（1）什么次第三次握手\n（2）第三次丢失，服务端迟迟收不到ACK报文，就会触发超时重传机制，重发SYN-ACK报文\n（3）超过最大重传次数后就不再发送，断开连接\n```\n\n#### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？\n\n```\n（1）为了防止历史报文被下一个相同四元组的连接接收（主要方面）；\n假设客户端和服务端的初始序列号都为0\n- 建立连接后，客户端发送第一个报文被网络阻塞，随后进行超时重传。此时服务器宕机重启了，连接已经断开，所以服务器收到重传的报文后回复一个RST报文\n- 接着，客户端又与服务器建立与上一个连接相同四元组的连接\n- 新连接建立后，被阻塞的数据包刚好到达服务器，此时的序列号刚好在接收窗口内，就会被正常接收，造成数据错乱\n\n（2）为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；\n```\n\n\n\n\n\n### TCP四次挥手\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/03/16164516910506051691050605249Z7due6-format,png-20230309230614791.png\" alt=\"客户端主动关闭连接 —— TCP 四次挥手\" style=\"zoom:50%;\" />\n\n```\n（1）第一次挥手：客户端发送一个FIN（seq=x）标志的数据包到服务器，用来关闭客户端到服务器的数据传输。然后客户端进入FIN-WAIT-1状态\n（2）第二次挥手：服务端接收后发送一个ACK（ACK=x+1）标志的数据包到客户端。服务器进入CLOSE-WAIT状态，客户端收到后进入FIN-WAIT-2状态\n（3）第三次挥手：服务端发送一个FIN（seq=y）标志的数据包到客户端，请求关闭连接，然后服务端进入LAST-ACK状态。\n（4）第四次挥手：客户端发送ACK（ACK=y+1）标志的数据包到服务器，然后客户端进入TIME-WAIT状态。服务器接收到后进入CLOSE状态。\n如果客户端等待2MSL后依旧没有收到回复，证明服务端已经正常关闭，随后客户端也可以关闭连接。\n\nMSL（Maximum Segment Lifetime）是指TCP数据报文在网络中的最长生存时间，通常为2分钟\n```\n\n#### 为什么要四次挥手？\n\n```\nTCP连接是全双工的，客户端和服务器可以同时发送和接收数据。所以在关闭TCP连接时，一般需要四次挥手来确保双方都能完成数据的传输后在关闭连接\n\n第一次挥手，只能表示客户端不在发送数据但还可以接受数据\n服务端在收到FIN报文后，回复一个ACK应答报文，表示已经接受到FIN报文，这是第二次挥手。\n但是服务端可能还存在未发送完的数据，所以需要等待发送完后再发送FIN报文，这是第三次挥手\n客户端收到FIN报文后，还需要回复一个ACK报文表示收到，这是第四次挥手\n\n【但是在特定情况下，四次挥手是可以变成三次挥手的】\n```\n\n#### 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？\n\n```\n因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。\n\n【但是在特定情况下，四次挥手是可以变成三次挥手的】\n```\n\n#### TCP 四次挥手，可以变成三次吗？\n\n```\n关闭过程中，服务端「没有数据要发送」且「开启了TCP延迟确认机制」，那么第二和第三次就会合并传输，这样就会出现三次握手。\n\nhttps://xiaolincoding.com/network/3_tcp/tcp_three_fin.html#什么情况会出现三次挥手\n```\n\n#### 什么是TCP延迟确认机制？\n\n```\n当发送没有携带数据的ACK时，它的网络效率是很低的，因为它也有40个字节的IP头和TCP头，但没有携带数据报文。\n为了解决ACK传输效率低的问题，所以就衍生出了「TCP延迟确认」\n\nTCP延迟确认策略：\n- 当有响应数据要发送时，ACK会随着响应数据一起立刻发送给对方\n- 当没有响应数据发送时，ACK会延迟一段时间，以等待是否有响应数据可以一起发送\n- 如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，这时会立刻发送ACK\n```\n\n#### 第一次挥手丢失了，会发生什么？\n\n```\n（1）第一次挥手是什么？\n（2）会触发超时重传机制重发，每次超时时间是上次的两倍。\n（3）如果超过最大重传次数，再等待一段时间仍未收到，则直接进入close状态\n```\n\n#### 第二次挥手丢失了，会发生什么？\n\n```\n（1）第二次挥手是什么？\n（2）ACK是不会触发超时重传的，所以客户端没有收到 ACK 确认，会重新发送 FIN 报文。\n（3）如果超过最大重传次数，再等待一段时间仍未收到，就会断开连接\n```\n\n#### 第三次挥手丢失了，会发生什么？\n\n```\n（1）第三次挥手是什么？\n（2）第三次丢失，则服务端收不到ACK报文，就会超时重传FIN报文\n（3）如果超过最大重传次数，再等待一段时间仍未收到，服务端就会断开连接\n（4）客户端是通过close函数来关闭连接的，处于FIN_WAIT_2状态是有时常限制的，超过指定时间未收到第三次握手，则客户端会断开连接\n```\n\n#### 第四次挥手丢失了，会发生什么？\n\n```\n（1）第四次挥手是什么？\n（2）服务端会重传FIN，超过最大重传次数，再等待一段时间后仍未收到ACK，服务端就会断开连接\n（3）客户端在收到第三次挥手时，进入TIME_WAIT状态，开启时常2MSL的定时器。如果中途收到FIN，则重置定时器。超时2MSL后客户端就会断开连接\n```\n\n####  为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？\n\n```\nMSL是报文最大生存时间。\n\n第四次挥手时，客户端发送的ACK有可能丢失，如果服务端因为某些原因没有收到ACK，服务端就会重发FIN。\n如果客户端在2MSL的事件内收到FIN，就会重新发送ACK并再次等待2MSL，防止server没有收到ack而不断重发fin\n\nMSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。\n```\n\n\n\n### TIME_WAIT\n\n#### 为什么需要 TIME_WAIT 状态？\n\n```\n主动发起关闭连接的一方才会有TIME_WAIT状态\n\n主要原因：\n（1）防止历史连接中的数据，被后面相同四元组的连接错误的接收\n（2）保证「被动关闭连接」的一方，能被正确关闭\n\n四元组：原地址、源端口、目标地址、目标端口\n```\n\n防止历史连接中的数据，被后面相同四元组的连接错误的接收\n\n```\n（1）序列号和初始序列号并不是无限递增的，会发生会绕为初值的情况，所以无法根据序列号来判断新老数据。\n（2）如果不等待就结束，第三次握手发送的FIN网络延迟了，触发超时重传，用新的FIN进行正常关闭连接。\n（3）接着，服务端又以相同的四元组重建打开的新的连接，而前面被延迟的报文到达客户端，恰好又在接收窗口范围，那么客户端就会接收，就会产生数据错乱蹬严重问题。\n```\n\n保证「被动关闭连接」的一方，能被正确关闭\n\n```\n第四次握手的ACK丢失，服务端会重传FIN，假如没有TIME_WAIT状态，那么服务端就无法收到ACK，无法正常关闭连接\n```\n\n#### TIME_WAIT 过短有什么危害？\n\n```\n同【为什么需要 TIME_WAIT 状态？】\n```\n\n#### TIME_WAIT 过多有什么危害？\n\n```\n（1）客户端TIME_WAIT过多：占满了所有端口资源，就无法对【目标ip + 目标端口】一样的服务器发起连接，但可以想其他服务器发起连接（端口是可以复用的）\n（2）服务端TIME_WAIT过多：并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等\n\n```\n\n#### 服务器出现大量 TIME_WAIT 状态的原因有哪些？\n\n```\n首先要知道 TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。\n\n什么场景下服务端会主动断开连接呢？\n第一个场景：HTTP 没有使用长连接\n第二个场景：HTTP 长连接超时\n第三个场景：HTTP 长连接的请求数量达到上限\n```\n\n\n\n#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？\n\n```\n发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 ESTABLISH 状态，占用着系统资源。\n\n为了避免这种情况，TCP 搞了个「保活机制」。这个机制的原理是这样的：\n定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。\n```\n\n#### 如果已经建立了连接，但是服务端的进程崩溃会发生什么？\n\n```\nTCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。\n```\n\n\n\n\n\n\n\n\n\n###  TCP 如何保证传输的可靠性？\n\n```\n（1）连接控制：建立连接时通过三次握手建立可靠的传输信道；关闭连接时四次挥手，确保双方完成数据传输和连接关闭。\n（2）序列号：TCP将数据分割成小的数据块进行传输，每个数据包中包含序列号，接收方可以根据序列号进行排序以及去重。\n（3）确认和超时重传：TCP使用确认机制来保证数据的可靠传输。发送方在发送数据后会等待接收方的确认，如果一段时间内没有收到确认，则认为数据丢失，进行超时重传。\n（4）流量控制和拥塞控制：TCP通过流量控制和拥塞控制等机制控制数据的发送速率，避免数据丢失和网络拥塞。\n（5）校验和：TCP每个数据包的头部会包含一个校验和，接收方在接收后会再次计算校验和，如果两者不匹配，则说明数据在传输过程中发生了错误，接收方会要求发送发重新发送数据。\n```\n\n### 重传机制\n\n#### 超时重传\n\n##### 是什么？\n\n```\n在发送数据时，设定一个定时器，当超过指定时间后，没有收到对方的ACK确认应答报文，就会重发该数据\n\n+ 「什么时候会超时重传？」\n```\n\n##### 什么情况下会超时重传\n\n```\n（1）数据包丢失\n（2）确认应答丢失\n\n+ 【需要设置合理的超时重传时间】\n```\n\n##### 超时时间应该设置为多少？\n\n```\nRTT：数据发送时刻 到 接收到确认的时刻 的差值，即包的往返时间\n超时重传时间 RTO 的值应该略大于报文往返 RTT 的值，是一个动态变化的值。\n\n+ 「过长/过短的问题？」\n```\n\n##### 超时重传时间RT0，较长/较短会有什么问题？\n\n```\n（1）RT0较长：重发慢，丢包很丢才重发，没有效率，性能差\n（2）RT0较小：会导致并没有丢就重发，于是重发的就很快，会增加网络的拥塞，导致更多的超时，更多的超时就会导致更多的重发\n```\n\n#### 快速重传\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/30/114645169068880516906888051215oteeh-10.jpg\" alt=\"快速重传机制\" style=\"zoom:50%;\" />\n\n```\n连续收到三个相同的ack就重传\n\n快速重传解决了超时时间的问题，但是引入了另一个问题：就是重传时重传一个，还是重传所有\n（1）重传一个：重传效率低。假如发送seq1-seq6，seq2和seq3都丢失了，收到三个ack2时重传seq2，然后需要再收到三个ack3才会重传seq3\n（2）重传所有：传输过的数据需要再重传，浪费资源。发送seq1-seq6，seq2和seq3丢失，seq4-seq6都成功，如果收到三个ack2，重传seq2和后面所有的报文，那么之前传输成功的seq4-seq6就白浪费资源。\n```\n\n#### 选择重传 SACK\n\n```\n需要再头部【选项】字段里添加SACK，它可以将已经接收到的数据的信息发送给发送发，这样发送方就可以知道哪些数据收到了，哪些数据没收到，通过这些信息，就可以只重传丢失的数据。\n```\n\n#### 冗余ACK重传\n\n```\nhttps://www.xiaolincoding.com/network/3_tcp/tcp_feature.html#duplicate-sack\n```\n\n\n\n###  TCP 如何实现流量控制？\n\n```\n主要是通过滑动窗口来控制发送方的发送速率，确保接收方来得及接收。\n\n发送方和接收方在建立连接时会协商窗口大小（Window Size），即允许接收方缓冲的数据量。这个窗口大小是根据接收方的接收能力和发送方的发送能力进行调整的。\n接收方收到数据后，会发送确认（ACK）给发送方，并通知发送方当前的接收窗口大小，表示接收方的缓冲区还有多少可用空间。发送方根据接收方的窗口大小调整发送窗口的大小。\n如果发送窗口大小为0，表示接收方的缓冲区已满，发送方会暂停发送数据，等待接收方释放缓冲区空间。\n\n```\n\n### 为什么要流量控制？\n\n```\n（1）防止数据丢失：在双方通信时，发送发的速率和接收方的速率不一定相等。\n如果发送方发送的太快，会导致接收方处理不过来，从而造成数据丢失\n（2）防止网络拥塞：如果发送方过度发送数据，可能会造成网络拥塞，通过控制发送方的速率，来避免这种情况。让发送方和 接收方处于一种动态平衡\n```\n\n### 滑动窗口\n\n#### 窗口大小由哪一方决定？\n\n```\n通常窗口的大小由接收方的窗口大小来决定。发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。\n\nTCP头里有一个字段叫window，也就是窗口大小。\n这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送方就根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。\n```\n\n#### 发送窗口\n\n```\n包含四个部分\n（1）发送已确认。已发送并收到 ACK确认的数据\n（2）发送未确认。已发送但未收到 ACK确认的数据\n（3）可发送。未发送但总大小在接收方处理范围内（接收方还有空间）\n（4）不可发送。未发送但总大小超过接收方处理范围（接收方没有空间）\n```\n\n#### 接收窗口\n\n```\n（1）接收已确认\n（2）可接收\n（3）不可接收\n```\n\n#### 接收窗口和发送窗口的大小是相等的吗？\n\n```\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n\n滑动窗口大小是动态变化的。会根据接收方的读取数据的速度进行调整，通过TCP报文告诉发送方，这个传输过程是存在延迟的，所以接收窗口和发送窗口是约等于的关系。\n\n```\n\n#### 窗口关闭\n\n```\n指发送方的窗口为0，发送方不能在给接收方发送数据\n```\n\n#### 窗口关闭潜在的危险\n\n```\n接收方处理完数据后，向发送发通告窗口大小，假如ACK报文丢失，那么发送方窗口将一直为0，无法发送数据，双方进入死锁\n```\n\n#### TCP 是如何解决窗口关闭时，潜在的死锁现象呢？\n\n```\nTCP为每个连接设定一个持续计时器，只要收到零窗口通知，就会启动这个定时器。\n如果定时器超时，就会发送窗口探测报文，接收方会在确认报文中给出接收窗口的大小。\n如果为0就重启计时器\n如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。\n```\n\n\n\n### 拥塞控制\n\n#### 是什么？\n\n```\n是为了保护整个网络，控制整个网络的数据流量，避免网络拥塞。主要是由发送方根据网络状态来调整发送速率，以控制整个网络中的数据流量。\n```\n\n#### 为什么要有拥塞控制呀，不是有流量控制了吗？\n\n```\n拥塞控制和流量控制都涉及调整数据传输的速率，但它们的目标和作用是不同的。\n\n流量控制：是为了保护接收方，控制发送方的发送速率，防止发送方发送过多数据，接收方来不及处理而丢失数据。通常由接收方来控制，通过确认消息来告诉发送方自己有多少缓冲区可以接收数据，发送方由此动态调整窗口大小\n\n拥塞控制：是为了保护整个网络，控制整个网络的数据流量，避免网络拥塞。主要是由发送方根据网络状态来调整发送速率，以控制整个网络中的数据流量。\n```\n\n#### 什么是拥塞窗口？和发送窗口有什么关系呢？\n\n```\n拥塞窗口是发送方维护的一个状态变量，是根据网络的拥塞程度动态变化的。\n发送方窗口大小 约等于 接收窗口\n有了拥塞窗口，发送方的发送窗口大小就是【接收】 和 【拥塞窗口】的最小值\n\n拥塞窗口 cwnd 变化的规则：\n- 只要网络中没有出现拥塞，cwnd 就会增大；\n- 但网络中出现了拥塞，cwnd 就减少；\n```\n\n#### 那么怎么知道当前网络是否出现了拥塞呢？\n\n```\n发送方在规定时间内没有收到ACK应答报文，发生了超时重传，就认为网络出现了拥塞\n```\n\n#### 拥塞控制有哪些控制算法？\n\n```\n慢启动\n拥塞避免\n拥塞发生\n快速恢复\n```\n\n#### 慢启动\n\n```\nTCP在刚建立完成后，首先有个慢启动的过程，慢启动就是当发送方没收到一个ACK，拥塞窗口cwnd的大小就会+1。\n\ncwnd = 慢启动门限ssthresh，慢启动 或者 拥塞避免\n当cwnd > 慢启动门限ssthresh（（slow start threshold））时，就会使用「拥塞避免算法」\n\n指数增长\n```\n\n#### 拥塞避免算法\n\n```\n拥塞窗口超过慢启动门限，就会进入拥塞避免算法。\n他的规则是：每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1\n随着持续增长，会导致网络拥塞，出现丢包触发重传机制，进入【拥塞发生】阶段\n\n线性增加\n```\n\n#### 拥塞发生\n\n```\n网络拥塞时的重传机制有两种：\n（1）超时重传\n（2）快速重传\n```\n\n#### 超时重传\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/01/112348169086022816908602289542JKWSB-29.jpg\" alt=\"拥塞发送 —— 超时重传\" style=\"zoom:50%;\" />\n\n```\n发生超时重传时，\nssthresh设置cwnd/2\ncwnd重制为初始值\n进入慢启动\n\n\n问题：\n偶然的丢包，网络不一定发生拥塞，这时慢启动没有必要。\n```\n\n#### 快速重传\n\n```\n收到三个相同的ACK就会触发快速重传\n```\n\n#### 快速恢复\n\n小林coding图：（12直接变成了9，不太理解，跟教材上有区别）\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/01/11291116908605511690860551213fDbe8a-%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png\" alt=\"快速重传和快速恢复\" style=\"zoom:50%;\" />\n\n教材上的图：[参考](https://fasionchan.com/network/tcp/congestion-control/)\n\n![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/01/14133816908704181690870418577PSZWX9-8690627fbee083b1be2cb88eee249f36ee2a9b21.png)\n\n```\n将ssthresh设为当前窗口的一半\n将当前窗口设置为ssthresh\n执行拥塞避免，窗口大小线性增长\n```\n\n","timestamp":1691335064136},{"name":"01-Java基础.md","path":"001-JAVA/01-Java基础.md","content":"# Java基础\n\n## 基本数据类型\n\nJava 中的几种基本数据类型有哪些？\n\n```\n6 种数字类型：\n  4 种整数型：byte、short、int、long\n  2 种浮点型：float、double\n1 种字符类型：char\n1 种布尔型：boolean。\n```\n\n包装类型\n\n```\n包装类型：Byte，Short，Integer，Long，Float，Double，Character，Boolean\n```\n\n基本类型 vs 包装类型\n\n```\n\n```\n\n## 变量\n\n### 字符型常量和字符串常量的区别?\n\n```\n（1）形式：字符型常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符\n（2）含义：字符常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值\n（3）内存：字符型常量只占2个字节；字符串常量占用若干字节\n```\n\n\n\n### 成员变量与局部变量的区别？\n\n```\n（1）作用域：\n\t\t- 成员变量：属于类的一部分，在整个类中都可以访问。可以被public、private、protected、static修饰\n\t\t- 局部变量：定在方法、构造函数和代码块内部，只能在其定义的范围内使用。没有修饰符\n（2）生命周期\n\t\t- 成员变量：随着对象的创建而创建，在对象销毁时销毁\n\t\t- 局部变量：在声明时被创建，并在其作用域结束后被销毁。\n（3）默认值：\n\t\t- 成员变量: 如果没有显式初始化，会被赋予默认值，如数值类型为0，布尔类型为false，引用类型为null。\n\t\t- 局部变量：没有默认值，必须在使用之前进行显式初始化。\n\n```\n\n### 静态变量？\n\n```\n（1）是什么\n静态变量就是被static关键值修饰的变量。它可以被类的所有实例共享，无论创建多个个对象，都共享同一份静态变量。也就是说，静态变量只会分配一次内存，可以节省内存。\n\n（2）访问方法\n\t\t- 通过类名直接访问。ClassName.staticVariable;\n\t\t- 通过对象引用访问。objectReference.staticVariable;\n```\n\n### 静态变量和实例变量的区别？\n\n```java\npublic class A {\n\n    private int x;         // 实例变量\n    private static int y;  // 静态变量\n\n    public static void main(String[] args) {\n        // int x = A.x;  // Non-static field \'x\' cannot be referenced from a static context\n        A a = new A();\n        int x = a.x;\n        int y = A.y;\n    }\n}\n\n（1）实例变量是属于实例的，与实例变量同生共死\n（2）访问方法不同\n```\n\n### 静态方法\n\n```\n使用static修饰的方法，静态方式也成类方法，是属于类的\n\n特点\n（1）无需实例化，通过类名调用\n（2）不能访问非静态成员\n（3）不能使用this关键值。静态方法中不能使用this关键字，因为this表示当前对象实例，而静态方法没有对象实例。\n（4）具有全局性：类的所有实例共享\n```\n\n### 静态代码块\n\n```java\nstatic {\n    // 静态代码块的代码逻辑\n}\n\n使用static修饰的一段代码块\n  \n特点\n（1）在类加载时执行，只执行一次\n（2）无需调用，自动执行\n（3）用于初始化静态成员\n（4）无法访问非静态变量\n```\n\n### 静态内部类\n\n```\n静态内部类是定义在另一个类中的内部类，被声明为静态的。\n\n特点：\n（1）可以直接访问外部类的静态方法和静态变量，无需创建外部类的对象。但不能直接访问外部类的非静态成员（包括实例变量和实例方法，需要通过创建外部类对象来访问）\n（2）可以在没有外部类对象的情况下被实力化和访问\n（3）生命周期独立于外部类，即使外部类被销毁，静态内部类仍然存在\n（4）静态内部类可以拥有静态成员和实例成员，包括静态变量、静态方法和实例变量、实例方法\n```\n\n```java\n// 静态内部类的声明方式如下：\npublic class OuterClass {\n    // 外部类的成员和方法\n    \n    public static class StaticInnerClass {\n        // 静态内部类的成员和方法\n    }\n}\n\n// 静态内部类可以通过以下方式实例化和访问：\nOuterClass.StaticInnerClass innerObject = new OuterClass.StaticInnerClass();\n// 访问静态内部类的成员和方法\ninnerObject.staticMethod();\ninnerObject.staticVariable;\n```\n\n### 静态内部类与非静态内部类的区别\n\n```\n（1）声明方式：有无static\n（2）实例化方式：静态内部类可以直接实例化；非静态内部类需要外部类的实例来创建\n（3）访问范围：\n\t\t- 静态内部类：只能访问外部类的静态成员，要访问非静态成员可以通过创建外部类的实例\n\t\t- 非静态内部类：可以直接访问外部类的静态与非静态成员\n（4）声明周期：\n\t\t- 静态内部类：独立于外部类，即使外部类被销毁，静态内部类的实例仍然存在\n\t\t- 非静态内部类：声明周期同外部类，共享一个实例\n```\n\n### 静态方法为什么不能调用非静态成员?\n\n```\n（1）静态方法是属于类的，在类加载时就会分配内存，可以通过类名直接访问；而非静态成员是属于实例对象的，只有在对象实例化之后才存在，需要通过类的实例对象去访问。\n（2）类中非静态成员不存在的时候，静态方法就已经存在了，此时调用内存中还不存在的非静态成员，属于非法操作\n```\n\n### 静态方法和实例方法有何不同？\n\n```\n（1）调用方式\n\t\t- 外部调用静态方法时，可以通过【类名.方法名】的方式，也可以通过【对象.方法名】的方式。\n\t\t- 实例方法只能通过【对象.方法名】\n（2）访问类成员是否存在限制\n\t\t- 静态方法只能反问类的静态成员（静态变量和静态方法），不允许访问实例成员\n```\n\n### 为什么静态变量不能在方法中定义\n\n```\n静态变量属于类的成员，生命周期与类相同，在类加载时就被初始化，类销毁时才会被销毁。\n定义在方法中的变量是局部变量，如果定义在方法中，那么只有方法被初始化，方法执行后就会销毁。\n```\n\n### 初始化顺序\n\n```\n静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。\n\n父类（静态变量、静态语句块）\n子类（静态变量、静态语句块）\n父类（实例变量、普通语句块）\n父类（构造函数）\n子类（实例变量、普通语句块）\n子类（构造函数）\n```\n\n\n\n### 重载和重写有什么区别？\n\n```\n（1）重载：同一个类中多个同名方法根据不同的参数执行不同的逻辑\n\n（2）重写：运行期间，子类对父类的相同方法的重新改造\n“两同两小一大”：\n- “两同”即方法名相同、形参列表相同；\n- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；\n- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。\n\n关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。\n\njavaguide\n```\n\n| 区别点     | 重载方法 | 重写方法                                                     |\n| :--------- | :------- | :----------------------------------------------------------- |\n| 发生范围   | 同一个类 | 子类                                                         |\n| 参数列表   | 必须修改 | 一定不能修改                                                 |\n| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |\n| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |\n| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |\n| 发生阶段   | 编译期   | 运行期                                                       |\n\n\n\n## Java集合\n\n### Java 集合概览\n\n```\nJava 集合， 也叫作容器，主要是由两大接口派生而来：\n1. 一个是 Collection接口，主要用于存放单一元素；\n\t- 下面又有三个主要的子接口：List、Set 和 Queue。\n2. 另一个是 Map 接口，主要用于存放键值对。\n\n```\n\n![Java 集合框架概览](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/02/11464016882696001688269600418RyFb8U-java-collection-hierarchy.png)\n\n### List, Set, Queue, Map 四者的区别？\n\n```\nList: 有序、可重复\nSet： 无需、不重复\nQueue: 有序可重复，先进先出\nMap: 使用键值对存储。key是无序、不重复； value：无序、可重复\n```\n\n### 为什么要使用集合？\n\n```\n数组的缺点：\n当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用数组存储对象存在一些不足之处，因为在实际开发中，存储的数据类型多种多样且数量不确定。\n\n集合的优点：\n与数组相比，Java 集合提供了更灵活、更有效的方法来存储多个数据对象。Java 集合框架中的各种集合类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。\n相较于数组，Java 集合的优势在于它们的大小可变、支持泛型、具有内建算法等。\n总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。\n```\n\n### List\n\n#### ArrayList 和 Array（数组）的区别？\n\n```\n（1）大小可变性：数组的长度在创建时就确定，并且不能改变。而 ArrayList 的大小是可以动态调整的，可以根据需要自动扩容或缩减。\n（2）对象类型：数组可以存储任何类型的对象，包括基本数据类型和引用类型。而 ArrayList 只能存储引用类型的对象，不能直接存储基本数据类型，需要使用对应的包装类型。\n（3）功能和灵活性：ArrayList 提供了丰富的方法和操作，可以方便地进行元素的插入、删除、查找等操作，以及获取列表的大小、遍历元素等。而数组的功能相对较少，需要手动实现这些操作。\n（4）性能：由于 ArrayList 内部使用数组实现，它在动态扩容和元素移动等操作时会引入一些性能开销。而数组在访问元素时更加高效，因为它们在内存中是连续存储的。\n（5）多维数据结构：数组可以轻松地表示多维数据结构，而 ArrayList 并不直接支持多维数据结构。\n\n综上所述，ArrayList 相对于数组具有更大的灵活性和功能，可以自动调整大小并提供方便的操作方法。但在性能要求较高、固定长度或多维数据结构等特定场景下，数组可能更适合使用。在选择使用 ArrayList 还是数组时，需要根据具体的需求和情况做出选择。·\n\nchatgpt\n```\n\n#### ArrayList和Array相比有很多优点，那为什么不都是用ArrayList，还要使用Array？\n\n```\n（1）性能：数组在访问元素时更加高效，因为它们在内存中是连续存储的。相比之下，ArrayList 内部使用数组实现，但它还需要进行动态扩容和元素移动等操作，可能会引入一些性能开销。\n（2）固定长度：如果数据集的大小是固定的，不会发生变化，那么使用数组是更合适的选择。数组的长度在创建时确定，之后不能改变，这可以提供更好的性能和内存利用率。\n（3）多维数组：数组可以轻松地表示多维数据结构，而 ArrayList 并不直接支持多维数据结构。在需要处理矩阵、图形、二维表等数据时，使用数组可以更自然地表示和操作。\n（4）直接访问索引：有时候我们需要直接访问数组的特定位置，而不需要进行插入、删除等操作。使用数组可以直接通过索引进行快速访问，而不需要进行额外的查找操作。\n\nArrayList 和数组都有各自的优势和适用场景。在大多数情况下，ArrayList 提供了更多的便利性和灵活性，可以自动调整大小，并提供了丰富的方法和操作。但对于一些特定的场景，如性能要求较高、固定长度或多维数据等，使用数组可能更为合适。\n\nchatgpt\n```\n\n#### ArrayList 可以添加 null 值吗？\n\n```\nArrayList 中可以存储任何类型的对象，包括 null 值。不过，不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常\n\njavaguide\n```\n\n#### ArrayList 插入和删除元素的时间复杂度？\n\n```\n对于插入：\n- 头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。\n- 尾部插入：当 ArrayList 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。\n- 指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。\n\n对于删除：\n- 头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。\n- 尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。\n- 指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。\n\njavaguide\n```\n\n#### LinkedList 插入和删除元素的时间复杂度？\n\n```\n- 头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。\n- 尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。\n- 指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。\n\njavaguide\n```\n\n#### LinkedList 为什么不能实现 RandomAccess 接口？\n\n```\nRandomAccess 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 LinkedList 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 RandomAccess 接口。\n\njavaguide\n```\n\n#### ArrayList 与 LinkedList 区别?\n\n```\n（1）线程安全：都是不同步的，不保证线程安全\n（2）底层实现：\n\t- ArrayList使用Object数组实现，\n\t- LinkedList使用双向链表实现\n（3）插入和删除操作：\n\t- ArrayList 需要移动元素来保持连续存储的特性，因此对于大量的插入和删除操作，性能可能较低\n\t- LinkedList 的插入和删除操作只需要调整链表中的指针，因此对于频繁的插入和删除操作，性能可能更好\n（4）随即访问：\n\t- ArrayList支持\n\t- LinkedList不支持\n（5）内存占用：\n\t- ArrayList 在存储元素时需要预留一定的连续内存空间，因此它的内存占用比较高\n\t- LinkedList 的每个节点只需要存储元素值和指向前后节点的指针，因此内存占用相对较低\n\t\n如果需要频繁进行插入和删除操作，可以选择 LinkedList；如果需要频繁进行随机访问操作，可以选择 ArrayList。\n\nchatgpt\n```\n\n#### ArrayList 的扩容机制\n\n```java\n（1）初始容量：ArrayList 在创建时会分配一个初始容量，通常为 10（可以通过构造函数指定初始容量）。\n（2）扩容时机：向ArrayList添加元素时，如果当前元素个数超过了当前容量，ArrayList 将会进行扩容\n（3）扩容策略：ArrayList 扩容时会创建一个新的内部数组（当前容量的1.5倍），并将原来的元素复制到新数组中。\n\nArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。默认情况下，新的容量会是原容量的1.5倍。\n\n以JDK1.8为例说明:\npublic boolean add(E e) {\n    //判断是否可以容纳e，若能，则直接添加在末尾；若不能，则进行扩容，然后再把e添加在末尾\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    //将e添加到数组末尾\n    elementData[size++] = e;\n    return true;\n    }\n\n// 每次在add()一个元素时，arraylist都需要对这个list的容量进行一个判断。通过ensureCapacityInternal()方法确保当前ArrayList维护的数组具有存储新元素的能力，经过处理之后将元素存储在数组elementData的尾部\nprivate void ensureCapacityInternal(int minCapacity) {\n      ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n        //如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            return Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        return minCapacity;\n    }\n    \n  private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n        // 若ArrayList已有的存储能力满足最低存储要求，则返回add直接添加元素；如果最低要求的存储能力>ArrayList已有的存储能力，这就表示ArrayList的存储能力不足，因此需要调用 grow();方法进行扩容\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n\n\nprivate void grow(int minCapacity) {\n        // 获取elementData数组的内存空间长度\n        int oldCapacity = elementData.length;\n        // 扩容至原来的1.5倍\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //校验容量是否够\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //若预设值大于默认的最大值，检查是否溢出\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // 调用Arrays.copyOf方法将elementData数组指向新的内存空间\n         //并将elementData的数据复制到新的内存空间\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\nchatgpt\n面试小抄：https://www.javalearn.cn/#/doc/Java集合/面试题?id=_5-说一说arraylist-的扩容机制？\n其他：javaguide: ArrayList 源码分析：https://javaguide.cn/java/collection/arraylist-source-code.html#arraylist-简介\n```\n\nArrayList 的构造函数\n\n```\n（1）默认构造函数，使用初始容量10构造一个空列表。\n\t\t实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。\n（2）带初始容量参数的构造函数。\n（3）构造包含指定collection元素的列表\n```\n\n\n\n### Set\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/03/22325016883947701688394770256dipO8b-image-20230703223250082.png\" alt=\"image-20230703223250082\" style=\"zoom:50%;\" />\n\n#### 什么是Set？\n\n```\nSet 是 Java 中的一种集合（Collection）类型，Set 接口继承自 Collection 接口，它是一个不允许包含重复元素的集合。\n\n主要特点：\n（1）不可重复性。Set 中不能包含相同的元素，如果试图添加重复元素，则添加操作会失败。\n（2）无序性：Set 中的元素没有固定的顺序，即元素的顺序是不可预测的。\n（3）提供高效的查找操作：Set 提供了高效的查找操作，可以快速判断一个元素是否存在于 Set 中。\n\n常见实现类：\n（1）HashSet：基于哈希表实现，插入和查找操作的时间复杂度为 O(1)，不保证元素的顺序。\n（2）TreeSet：基于红黑树实现，插入和查找操作的时间复杂度为 O(logN)，元素按照自然排序或自定义排序进行排序。\n（3）LinkedHashSet：基于哈希表和链表实现，插入和查找操作的时间复杂度为 O(1)，元素按照插入顺序排序。\n\n常见用途：\n（1）去重：可以使用 Set 来去除集合中重复的元素，只保留不重复的元素。\n（2）判断元素是否存在：可以通过 Set 来快速判断一个元素是否存在于集合中。\n（3）数学集合运算：Set 支持集合的交集、并集、差集等运算，方便进行集合操作。\n\nchatgpt\n```\n\n#### 什么是HashSet？\n\n```\n（1）底层实现：基于哈希表（HashMap）实现，通过哈希函数将元素映射到桶中\n（2）无序性：不保证元素的插入顺序和存储顺序一致。\n（3）唯一性：每个元素都是唯一的。元素的唯一性是通过HashMap中键的唯一性来实现的，通过hashCode()和equals()方法来判断的。\n（4）允许空元素：HashSet可以存储空元素（null），但只能存储一个空元素，因为元素的唯一性要求。\n（5）性能高效：查找、插入和删除元素的时间复杂度是常数时间O(1)。\n\nchatgpt\n```\n\n#### HashSet是如何保证唯一性的？\n\n```\nHashSet通过HashMap来实现唯一性。\n\n当向HashSet中添加元素时，首先会计算元素的HashCode，找到对应的桶。\n然后遍历这个桶中的元素，比较它们的哈希code值，如果不想等则直接加入。\n如果哈希码相等，则用equals方法比较两个元素，如果返回true则表示重复元素，添加失败。否则添加成功\n```\n\n#### 什么是LinkedHashSet？\n\n```\n（1）底层实现：继承自HashSet，通过哈希表+双向链表实现。哈希表提供了快速的查找和删除操作，链表则用于维护元素的插入顺序。\n（2）有序性：可以保持元素的插入顺序和存储顺序一致\n（3）唯一性：每个元素都是唯一的。\n（4）允许空元素：与HashSet一样，LinkedHashSet可以存储空元素（null），但只能存储一个空元素。\n（5）性能：LinkedHashSet的性能与HashSet相当，查找、插入和删除操作的平均时间复杂度为常数时间O(1)。\n\nchatgpt\n```\n\n#### 什么是TreeSet?\n\n```\n（1）底层实现：TreeSet内部使用红黑树（Red-Black Tree）数据结构来存储元素。红黑树是一种自平衡的二叉查找树，可以保持元素的有序性，并提供高效的插入、删除和查找操作。\n（2）有序性：TreeSet会根据元素的比较规则对元素进行排序。如果元素实现了Comparable接口，将使用元素自身的比较逻辑来进行排序（对于整数类型的元素，默认的升序排序将会从小到大排列元素）；如果没有实现Comparable接口，可以在构造TreeSet时传入自定义的比较器来指定元素的排序规则。\n（3）唯一性：与Set接口一样，TreeSet不允许存储重复的元素，每个元素都是唯一的。\n（4）允许空元素：TreeSet可以存储空元素（null），但在比较元素时需要注意，因为空元素无法进行比较。\n（5）性能方面：TreeSet的插入、删除和查找操作的时间复杂度为O(log n)，其中n表示集合中的元素个数。由于红黑树的自平衡特性，TreeSet在大部分情况下具有良好的性能。\n\nTreeSet适用于需要元素有序并且需要高效的插入、删除和查找操作的场景。它常用于排序、范围查找等场景，也可以通过自定义比较器来指定特定的排序规则。\n\nchatgpt\n```\n\n#### TreeSet是如何保证有序性的？TODO\n\n```\n\n```\n\n\n\n#### 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\n\n```\nHashSet、LinkedHashSet和TreeSet都是Java集合框架中的Set接口的实现类\n\n（1）底层实现：HashSet和LinkedHashSet都是基于哈希表实现的，TreeSet是基于红黑树实现的\n（2）有序性：HashSet无序，LinkedHashSet保留了插入顺序，TreeSet根据元素的比较规则对元素进行排序，或者在构造TreeSet时自定义比较器。\n（3）唯一性：都保证了元素的唯一性\n（4）都允许空元素\n（5）性能：HashSet的插入和查找操作的性能较好，而TreeSet的有序性和范围查询是其特点，LinkedHashSet则在保持插入顺序的同时提供了较好的性能。\n\nchatgpt\n```\n\n#### TreeSet的两种方式\n\n元素实现Comparable接口\n\n```java\npublic class Person implements Comparable<Person> {\n    private String name;\n    private int age;\n\n    @Override\n    public int compareTo(Person other) {\n        // 比较逻辑，按照年龄进行比较\n        return this.age - other.age;\n    }\n}\n\n如果当前元素小于传入的元素，应返回负整数。\n如果当前元素等于传入的元素，应返回零。\n如果当前元素大于传入的元素，应返回正整数。\n  \nchatgpt\n```\n\n自定义比较器\n\n```java\npublic class PersonComparator implements Comparator<Person> {\n    @Override\n    public int compare(Person p1, Person p2) {\n        // 比较逻辑，按照年龄进行比较\n        return p1.getAge() - p2.getAge();\n    }\n}\n\n// 使用自定义比较器构造 TreeSet 对象\nTreeSet<Person> treeSet = new TreeSet<>(new PersonComparator());\n\nchatgpt\n```\n\n### Queue\n\n![image-20230704162733908](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/04/16273416884592541688459254135NeEAbK-image-20230704162733908.png)\n\n####  Queue 与 Deque 的区别\n\n```\nQueue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO）规则。\nQueue 扩展了 Collection 的接口，根据因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。\n```\n\n| `Queue` 接口 | 抛出异常  | 返回特殊值          |\n| ------------ | --------- | ------------------- |\n| 插入队尾     | add(E e)  | offer(E e): boolean |\n| 删除队首     | remove()  | poll()：null        |\n| 查询队首元素 | element() | peek(): null        |\n\n```\nDeque 是双端队列，在队列的两端均可以插入或删除元素。\nDeque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：\n```\n\n| `Deque` 接口 | 抛出异常      | 返回特殊值      |\n| ------------ | ------------- | --------------- |\n| 插入队首     | addFirst(E e) | offerFirst(E e) |\n| 插入队尾     | addLast(E e)  | offerLast(E e)  |\n| 删除队首     | removeFirst() | pollFirst()     |\n| 删除队尾     | removeLast()  | pollLast()      |\n| 查询队首元素 | getFirst()    | peekFirst()     |\n| 查询队尾元素 | getLast()     | peekLast()      |\n\n#### ArrayDeque 与 LinkedList 的区别\n\n```\nArrayDeque 和 LinkedList 都是 Java 中常用的双端队列（Deque）的实现，它们在实现方式和性能上有一些区别。\n\n（1）内部实现方式\n\t\t- ArrayDeque：内部使用循环数组实现，可以自动扩容和缩容，具有较高的访问和操作性能\n\t\t- LinkedList：内部使用双向链表实现，每个节点包含前后节点的引用，支持快速插入和删除\n（2）访问和操作性能\n\t\t- ArrayDeque：头尾增删性能好O(1)。使用了循环数组，有较好的空间利用率\n\t\t- LinkedList：头尾增删性能好O(1)。随机访问和搜索差O(n)\n（3）内存占用\n\t\t- ArrayDeque 的内存占用比 LinkedList 少，因为它不需要为每个元素额外存储前后节点的引用。\n（4）适用场景\n\t\t- ArrayDeque：适用于头尾增删，随机访问性能要求高的\n\t\t- LinkedList：适用于任意位置增删，随机访问性能要求不高的\n\nchatgpt\n```\n\n#### 什么是PriorityQueue\n\n```\n是Java中优先级队列的实现，与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。\n\n（1）底层实现：利用二叉堆的数据结构实现，底层使用可变长的数组来存储数据\n（2）有序性：不保证有序性，保证每次取出的元素是优先级最高的\n（3）唯一性：允许插入相同的元素，取出时优先级顺序不定\n（4）空元素：是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象\n（5）性能：插入和删除操作的时间复杂度为 O(log n)，查找O(n)\n\nchatgpt\n```\n\n\n\n### Map\n\n![image-20230705204107476](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/05/20410716885608671688560867635aqltK5-image-20230705204107476.png)\n\n\n\n####  HashMap\n\n```\n是Java中的一种散列表实现，用于存储键值对数据，基于哈希表实现，可以快速增删查\n\n\n（1）底层实现：底层通过数组和链表（或红黑树）实现。每个键值对被封装为一个Entry对象，其中包含了键和值的信息。通过对键进行哈希计算，确定该键值对在内部数组中的存储位置。\n（2）有序性：不保证有序\n（3）唯一性：键是唯一的，不允许重复，键和值可以是任意类型的对象\n（4）空元素：允许存储null键和null值（除了Hashtable）\n（5）性能：通过键来进行快速的插入、删除和查找操作，时间复杂度为O(1)\n\nchatgpt\n```\n\n####  一般用什么作为HashMap的key?\n\n```\n一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。\n\n（1）不可变：这些类是不可变的，一旦创建就不能被修改。这使得在哈希计算时保持稳定，不会发生改变。确保相同的内容始终具有相同的哈希值，保证hashmap键的唯一性\n（2）hashcode()和equals()的正确实现。所有类都继承至Object，提供了默认的hashcode()和equals(),但并不一定适用于所有类。而String类已经对这两个方法进行了正确的重写，从而保证了相同内容的字符串具有相同的哈希码。\n（3）高度优化的哈希函数：Java 的 String 类内部实现了高度优化的哈希函数，可以快速计算出字符串的哈希码。这有助于提高 HashMap 在处理 String 类型的键时的性能。\n```\n\n#### 用可变类当 HashMap 的 key 有什么问题?\n\n```\nhashcode 可能发生改变，导致 put 进去的值，无法 get 出。如下所示\n\nHashMap<List<String>, Object> changeMap = new HashMap<>();\nList<String> list = new ArrayList<>();\nlist.add(\"hello\");\nObject objectValue = new Object();\nchangeMap.put(list, objectValue);\nSystem.out.println(changeMap.get(list));\nlist.add(\"hello world\");//hashcode发生了改变\nSystem.out.println(changeMap.get(list));\n\n输出值如下：\njava.lang.Object@74a14482\nnull\n```\n\n#### [HashMap的底层数据结构是什么？](https://www.javalearn.cn/#/doc/Java集合/面试题?id=_7-hashmap的底层数据结构是什么？)\n\n```\n在 JDK 1.7 中，\nHashMap 使用了数组+链表的组合来实现。具体来说，它使用了一个 Entry 数组来存储键值对，每个数组元素是一个链表的头节点。当发生哈希冲突时，新的键值对会被添加到链表的末尾。这种实现方式称为\"拉链法\"（Chaining）。\n\n当链表过长，则会严重影响 HashMap 的性能，链表是糟糕的 O(n)\n在JDK1.8 中，进行了优化，引入了红黑树\n插入元素时\n- 当链表超过 8 且数据总量超过 64 时，hashmap会将链表转换为红黑树\n- 当红黑树的节点数量小于等于6时，红黑树会重新转换为链表。\t？？？\n这种优化能够更好地平衡存储空间和执行效率。\n\nchatgpt\n面试小抄\n```\n\n#### [解决hash冲突的办法有哪些？HashMap用的哪种？](https://www.javalearn.cn/#/doc/Java集合/面试题?id=_8-解决hash冲突的办法有哪些？hashmap用的哪种？)\n\n```\n解决Hash冲突方法有:开放定址法、再哈希法、链地址法（拉链法）、建立公共溢出区。HashMap中采用的是 链地址法 。\n\n（1）开放定址法：也称为再散列法，基本思想就是，如果p=H(key)出现冲突时，则以p为基础，再次hash，p1=H(p),如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址pi。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以只能在删除的节点上做标记，而不能真正删除节点。\n（2）再哈希法(双重散列，多重散列)：提供多个不同的hash函数，当R1=H1(key1)发生冲突时，再计算R2=H2(key1)，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。\n（3）链地址法(拉链法)，将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。\n（4）建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。\n\n面试小抄\n```\n\n#### 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?\n\n```\n（1）时间复杂度：链表的增删查是O(n)，红黑树是O(logn)。链表的复杂度相对较高，但是在链表较短的情况下，仍然可以保持较好的性能。\n\n（2）空间复杂度：链表节点只需要存储键值对的引用 & 下一个节点引用，相对来说占用空间较小。红黑树节点需要存储键值对的引用、左右节点的引用、以及额外的颜色标记，占用空间较大\n\nchatgpt\n```\n\n#### 如果不用红黑树，用二叉查找树可以么?\n\n```\n可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢\n```\n\n#### 为什么阈值是8？\n\n```\n是因为泊松分布，作者在源码中的注释：\n\n理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循泊松分布。链表中元素个数为 8 时的概率已经非常小\n```\n\n[参考](https://www.javalearn.cn/#/doc/Java集合/面试题?id=hashmap面试小抄)\n\n#### 为什么hashmap 查找的时间复杂度是O(1), 通过红黑树或者链表存储，是怎么找到元素的？需要遍历吗\n\n```\nTODO\n```\n\n#### hashmap的加载因子是什么？\n\n```\n加载因子（load factor）是指在哈希表中元素数量与桶（数组的每个元素）数量之间的比率关系\nhashmap的默认加载因子是0.75，当哈希表中的元素达到容量的75%时，会触发哈希表的扩容操作，将哈希表的容量增加一倍。\n\nchatgpt\n```\n\n#### hashmap的加载因子默认是多少？为什么是0.75，不是0.6或0.8?\n\n```\n数组长度是16，加载因子是0.75\n加载因子是一个权衡考虑的结果。\n（1）较低的加载因子会使得哈希表占用的空间更少，但会增加哈希冲突的概率，导致查找和插入操作的性能下降。\n（2）较高的加载因子会使得哈希表占用的空间更多 但会减少哈希冲突。\n0.75 被认为是一个较好的加载因子，它在时间和空间效率之间取得了一个平衡。\n\n使用场景\n低加载因子：内存多、时间效率高\n高加载因子：内存少、时间效率不高\n\nchatgpt\n```\n\n#### 为什么小加载因子会是哈希表占用空间更少，哈希冲突概率增加？\n\n```\n数组长度默认是16的条件下，在扩容之前\n（1）低加载因子：每个桶存的元素较少（因为超过一定数量就扩容了），因此占用的空间相对较小，但桶之间的空闲空间较多，会导致其他键映射到同一个桶中的可能性，增加哈希冲突的概率。\n（2）高加载因子：相比之下，较高的加载因子可以使每个桶中存储的元素较多，减少了空间浪费，同时也降低了多个键映射到同一个桶的可能性。桶中元素较多会增加查询时间\n\nchatgpt\n```\n\n#### [ HashMap 中 key 的存储索引是怎么计算的？](https://www.javalearn.cn/#/doc/Java集合/面试题?id=_11-hashmap-中-key-的存储索引是怎么计算的？)\n\n```\n在hashmap中，key的存储索引是通过哈希函数计算得到的。当插入一个键值对时，会根据key的哈希值进行计算，然后映射到数组的索引位置上。\n\n具体计算过程：\n（1）取key的hashcode值：使用 key 的 hashCode() 方法获取 key 的哈希码值，即一个整数\n（2）根据 hashcode 计算出hash值：使用 HashMap 的内部哈希函数将 hashCode 值转换为 hash 值。哈希函数的实现会对 hashCode 进行一系列的计算和变换操作，以生成一个更分散的 hash 值。\n（3）通过取模计算下标：使用取模运算将 hash 值映射到数组的索引位置。HashMap 内部维护了一个数组（通常称为 table 或 bucket），该数组的长度是固定的。通过 hash 值与数组长度进行取模运算，可以将 hash 值映射到数组的一个索引位置，从而确定 key 在数组中的存储位置。\n\nchatgpt\n```\n\n#### [HashMap 的put方法流程？](https://www.javalearn.cn/#/doc/Java集合/面试题?id=_12-hashmap-的put方法流程？)\n\n图转转红黑树前要判断数组长度是否>=64\n\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/06/17423116886365511688636551075KyBqgM-watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546E5piOSGFua28=,size_20,color_FFFFFF,t_70,g_se,x_16.png)\n\n```\n（1）判断数组是否为空，为空就初始化\n（2）根据键的hashcode计算哈希值，计算出键值对在数组中的索引\n（3）位置不存在元素则直接插入, 判断是否扩容，直接返回null。\n（4）如果存在元素（发生冲突）\n\t\t- key存在，则覆盖，直接返回旧值\n\t\t- key不存在，则尾插法插入链表 / 红黑树\n（5）如果是链表,判断是否要转红黑树 还是 扩容\n（6）如果是红黑树，判断是否要扩容\n\nhttps://javaguide.cn/java/collection/hashmap-source-code.html#put-方法\nhttps://blog.csdn.net/citywu123/article/details/122125093\n```\n\n#### Jdk7 和Jdk8 的put方法区别是什么？\n\n```\n（1）解决哈希冲突时，jdk7只用链表，jdk8使用链表+红黑树，满足一定条件时，链表会转为红黑树\n（2）链表插入元素时，\n\t\t- jdk7使用头插法，多线程条件下，扩容会造成环形链或数据丢失，出现死循环\n\t\t- jdk8使用尾插法，扩容时会保持链表原本的顺序，就不会出现链表成环的问题，但多线程环境下，会出现数据覆盖的情况，导致数据不一致。\n\t\t\nhttps://xiaoniuhululu.com/2022-04-18_interview-about-hashmap/#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-%E4%BD%A0%E8%BF%98%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9Bhash%E7%AE%97%E6%B3%95%EF%BC%9F\n```\n\n#### 为什么会出现死循环\n\n```\nhttps://www.cnblogs.com/developer_chan/p/10450908.html\n```\n\n\n\n#### jdk8 中 HashMap 链表和红黑树的转化条件\n\n```\n插入元素后，链表的个数大于8，且长<于64时进行扩容\n如果>=64,则转为红黑树\n\n扩容完成后，如果某个节点是树，且节点个数<= 6则转换为链表？？？\n```\n\n\n\n#### HashMap 怎么设定初始容量大小的？\n\n```\n不传值默认为16，\n传入初始值n，则为大于n的2的最小次方\n如果传10，则大小为16\n```\n\n#### HashMap 的长度为什么是 2 的幂次方\n\n```\n（1）提高运算效率：当长度为 2 的幂次方时，通过取模运算可以使用位运算来替代，即 hash & (length - 1)，这比使用取模运算 hash % length 效率更高。\n（2）使数据均匀分布，减少碰撞：长度为 2 的幂次方可以保证哈希值在取模运算时能够更加均匀地分布到不同的桶中，减少哈希冲突的概率，提高 HashMap 的性能和效率。\n```\n\n#### 为什么“长度为 2 的幂次方可以保证哈希值在取模运算时能够更加均匀地分布到不同的桶中”？\n\n```\n2 的幂次方的二进制为 10000\nlength - 1的二进制为01111\n\n取模运算是hash & (length - 1)\n&运算：同1为1，其余为0\n\n当数组的长度为 2 的幂次方时，数组的长度减一的二进制表示形式中的所有位都是 1，这样就可以通过与操作（AND）来保留 hash 值的较低位，舍弃较高位。由于哈希函数的结果是一个较大的整数，而数组的长度相对较小，取模运算就可以将较大的整数映射到较小的范围内，使得哈希值能够均匀地分布到不同的桶中。\n```\n\n#### HashMap如何扩容？TODO\n\n```\nHashmap 在容量超过负载因子所定义的容量之后，就会扩容。扩容时会新建一个两倍大小的数组，将原来的对象放入新的数组中\n\n\nhttps://xiaoniuhululu.com/2022-04-18_interview-about-hashmap/#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-jdk8%E4%B8%AD%E7%9A%84%E6%89%A9%E5%AE%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E6%9B%B4%E7%AE%80%E5%8D%95\n\nhttps://www.javalearn.cn/#/doc/Java集合/面试题?id=hashmap面试小抄\n```\n\n\n\n####  jdk8对HashMap的优化\n\n```\njdk7->jdk8的优化：\n\n（1）数组+链表改成了数组+链表+红黑树\n（2）链表的插入方式从头插法改成了尾插法\n（3）扩容的时候7需要对原数组中的元素进行重新hash定位在新数组的位置，8采用更简单的判断逻辑，位置不变或索引+旧容量大小；\n（4）在插入时，7先判断是否需要扩容，再插入；而 8先进行插入，插入完成再判断是否需要扩容；\n```\n\n[参考](https://xiaoniuhululu.com/2022-04-18_interview-about-hashmap/#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A-jdk8%E4%B8%AD%E7%9A%84%E6%89%A9%E5%AE%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E6%9B%B4%E7%AE%80%E5%8D%95)\n\n\n\n\n\n#### [HashMap为什么线程不安全？](https://www.javalearn.cn/#/doc/Java集合/面试题?id=_15-hashmap为什么线程不安全？)\n\n```\n（1）多线程下扩容死循环。jdk7中的hashmap使用头插法插入元素，在多线程下，扩容的时候可能导致环形链表，形成死循环。jdk8时改用尾插法，扩容时会保证链表原有顺序。\n（2）多线程put可能导致元素丢失。计算出来的索引位置可能一直，会造成前一个key会被后一个key覆盖，导致元素丢失。jdk7和jdk8都存在\n（3）put和get并发时，get可能为null。线程1执行put时，超出容量需要rehash，线程2此时get，就有可能出现问题。jdk7和jdk8都存在\n```\n\n[具体介绍](https://mp.weixin.qq.com/s?__biz=MzkyMTI3Mjc2MQ==&mid=2247485906&idx=1&sn=64785914b2bc6c53b21d7c62fbb605a7&source=41#wechat_redirect)\n\n\n\n### ConcurrentHashMap\n\n","timestamp":1691335064136},{"name":"00-并发编程相关.md","path":"001-JAVA/010-Java并发编程/00-并发编程相关.md","content":"[采用线程池进行异步任务处理](https://cloud.tencent.com/developer/article/1161221)\n\n[生产实践——线程池与异步任务编排](https://juejin.cn/post/7086351322944913438#heading-12)\n\n-   多文件上传\n\n[Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)\n\n[Javaguide 线程池详解](https://javaguide.cn/java/concurrent/java-thread-pool-summary.html)","timestamp":1691335064136},{"name":"01-Java并发编程基础.md","path":"001-JAVA/010-Java并发编程/01-Java并发编程基础.md","content":"# Java并发编程基础\n\n## 1 线程基础\n\n### 什么是线程\n\n### 为什么要使用多线程\n\n### 线程的优先级\n\n### 线程的状态\n\n* New：新创建的线程，尚未执行；\n* Runnable：运行中的线程，正在执行 `run()`方法的Java代码；\n* Blocked：运行中的线程，因为某些操作被阻塞而挂起；\n* Waiting：运行中的线程，因为某些操作在等待中；\n* Timed Waiting：运行中的线程，因为执行 `sleep()`方法正在计时等待；\n* Terminated：线程已终止，因为 `run()`方法执行完毕。\n\n![image-20230503132121863](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/04/13042416831766641683176664243erV4pC-13212216830912821683091282100jSyioP-image-20230503132121863-20230504130424144.png)\n\n### 线程终止的原因\n\n- 线程正常终止：`run()`方法执行到 `return`语句返回；\n- 线程意外终止：`run()`方法因为未捕获的异常导致线程终止；\n- 对某个线程的 `Thread`实例调用 `stop()`方法强制终止（强烈不推荐使用）。\n\n## 2 创建线程的方式\n\n```\n1.继承Tread类\n2.实现Runnable接口\n3.实现Callable接口\n4.使用线程池\n```\n\n### 继承Tread类\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread();\n        t.start(); // 启动新线程\n    }\n}\n```\n\n执行指定代码\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new MyThread();\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n\n[参考](https://www.liaoxuefeng.com/wiki/1252599548343744/1306580710588449)\n\n### 实现Runnable接口\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n\n简写\n\n```java\nnew Thread(new Runnable() {\n  \t@Override\n  \tpublic void run() {\n    \t//调用卖票方法\n    \tfor (int i = 0; i < 40; i++) {\n      \tticket.sale();\n    \t}\n  \t}\n},\"Thread Name\").start();\n```\n\n使用Java8的lambda语法简写\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> {\n            System.out.println(\"start new thread!\");\n        });\n        t.start(); // 启动新线程\n    }\n}\n```\n\n[参考](https://www.liaoxuefeng.com/wiki/1252599548343744/1306580710588449)\n\n## 3 中断线程\n\n\n\n## 4 线程间通信\n\n### volatile和synchronized关键字\n\n\n\n### 通知/等待机制\n\n#### 通知和等待的相关方法\n\n等待\n\n```\nwait(): 等待无限长的时间，直到其他线程唤醒它。\nwait(long timeout): 等待一定的时间后，自动唤醒当前线程。\nwait(long timeout, int nanos): 等待指定的时间和纳秒数后自动唤醒当前线程。\n```\n\n通知\n\n```\nnotify()方法用于唤醒一个正在等待的线程，如果有多个线程等待，则唤醒其中一个线程。\nnotifyAll()方法则唤醒所有等待的线程。\n```\n\n#### 等待/通知的经典范式\n\n等待方\n\n```java\n1.获取对象的锁\n2.如果条件不满足，则调用对象的wait()方法，被通知后仍要检查条件（即使用wile而不能使用if）\n3.条件满足时则执行对应的逻辑\n\nsynchronized(对象) {\n\twhile(条件不满足时) {\n    对象.wait();\n  }\n  // 处理逻辑\n}\n```\n\n通知方\n\n```java\n1.获取对象的锁\n2.改变条件\n3.通知所有等待在对象上的线程\n  \nsynchronized(对象) {\n\t改变条件\n  对象.notifyAll();\n}\n```\n\n#### 例子\n\n**例子1**\n\n```java\npublic class WaitNotify {\n    static boolean flag = true;\n    static Object  lock = new Object();\n\n    public static void main(String[] args) throws Exception {\n        Thread waitThread = new Thread(new Wait(), \"WaitThread\");\n        waitThread.start();\n        TimeUnit.SECONDS.sleep(1);\n\n        Thread notifyThread = new Thread(new Notify(), \"NotifyThread\");\n        notifyThread.start();\n    }\n\n    static class Wait implements Runnable {\n        public void run() {\n            // 加锁，拥有lock的Monitor\n            synchronized (lock) {\n                // 当条件不满足时，继续wait，同时释放了lock的锁\n                while (flag) {\n                    try {\n                        System.out.println(Thread.currentThread() + \" flag is true. wait @ \"\n                                           + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                    }\n                }\n                // 条件满足时，完成工作\n                System.out.println(Thread.currentThread() + \" flag is false. running @ \"\n                                   + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n            }\n        }\n    }\n\n    static class Notify implements Runnable {\n        public void run() {\n            // 加锁，拥有lock的Monitor\n            synchronized (lock) {\n                // 获取lock的锁，然后进行通知，通知时不会释放lock的锁，\n                // 直到当前线程释放了lock后，WaitThread才能从wait方法中返回\n                System.out.println(Thread.currentThread() + \" hold lock. notify @ \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                lock.notifyAll();\n                flag = false;\n                SleepUtils.second(5);\n            }\n            // 再次加锁\n            synchronized (lock) {\n                System.out.println(Thread.currentThread() + \" hold lock again. sleep @ \"\n                                   + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                SleepUtils.second(5);\n            }\n        }\n    }\n```\n\n**例子2**\n\n通过使用多个线程对0这个值操作，一个线程加1，一个线程减1，交替实现多次\n\n```java\n//第一步 创建资源类，定义属性和操作方法\nclass Share {\n    //初始值\n    private int number = 0;\n    //+1的方法\n    public synchronized void incr() throws InterruptedException {\n        //第二步 判断 干活 通知\n       // 错误写法：\n       // if(number != 0) { //判断number值是否是0，如果不是0，等待\t\t注意：此处写法会导致虚假换新问题，用while\n            // this.wait(); //在哪里睡，就在哪里醒\n        // }\n      \n        // 正确写法\n      \twhile(number != 0) { //判断number值是否是0，如果不是0，等待\n            this.wait(); //在哪里睡，就在哪里醒\n        }\n        //如果number值是0，就+1操作\n        number++;\n        System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n        //通知其他线程\n        this.notifyAll();\n    }\n\n    //-1的方法\n    public synchronized void decr() throws InterruptedException {\n        //判断\n        if(number != 1) {\n            this.wait();\n        }\n        //干活\n        number--;\n        System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n        //通知其他线程\n        this.notifyAll();\n    }\n}\n\npublic class ThreadDemo1 {\n    //第三步 创建多个线程，调用资源类的操作方法\n    public static void main(String[] args) {\n        Share share = new Share();\n        //创建线程\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr(); //+1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr(); //-1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n    }\n}\n\n// 结果\nAA :: 1\nBB :: 0\nAA :: 1\nBB :: 0\n...\n```\n\n不能用if的原因\n\n```\n主要是虚拟唤醒导致：如果一个线程执行完毕后，通知其他线程，该线程又进入等待睡眠，可能会因为某些原因被唤醒后，if结构的语句就不会判断了，一直往下执行，所以需要将if换成while结构，每次都判断。因为wait在哪里睡眠就在哪里被唤醒，结果被某个异常唤醒了后回不去了，if结构不会在判断了，需要更改为while\n```\n\n\n\n### Condition\n\n```java\npackage com.atguigu.lock;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n//第一步 创建资源类，定义属性和操作方法\nclass Share {\n    private int number = 0;\n\n    //创建Lock\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    //+1\n    public void incr() throws InterruptedException {\n        //上锁\n        lock.lock();\n        try {\n            //判断\n            while (number != 0) {\n                condition.await();\n            }\n            //干活\n            number++;\n            System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n            //通知\n            condition.signalAll();\n        }finally {\n            //解锁\n            lock.unlock();\n        }\n    }\n\n    //-1\n    public void decr() throws InterruptedException {\n        lock.lock();\n        try {\n            while(number != 1) {\n                condition.await();\n            }\n            number--;\n            System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n            condition.signalAll();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ThreadDemo2 {\n\n    public static void main(String[] args) {\n        Share share = new Share();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"CC\").start();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"DD\").start();\n    }\n\n}\n```\n\n\n\n### 线程间定制化通信\n\n**所谓定制化通信，需要让线程进行一定的顺序操作**\n\n**案列**：启动三个线程，按照如下要求：\nAA打印5此，BB打印10次，CC打印15次，一共进行10轮\n\n**具体思路**：\n每个线程添加一个标志位，是该标志位则执行操作，并且修改为下一个标志位，通知下一个标志位的线程\n\n```java\n//第一步 创建资源类\nclass ShareResource {\n    //定义标志位\n    private int flag = 1;  // 1 AA     2 BB     3 CC\n\n    //创建Lock锁\n    private Lock lock = new ReentrantLock();\n\n    //创建三个condition\n    private Condition c1 = lock.newCondition();\n    private Condition c2 = lock.newCondition();\n    private Condition c3 = lock.newCondition();\n\n    //打印5次，参数第几轮\n    public void print5(int loop) throws InterruptedException {\n        //上锁\n        lock.lock();\n        try {\n            //判断\n            while(flag != 1) {\n                //等待\n                c1.await();\n            }\n            //干活\n            for (int i = 1; i <=5; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //通知\n            flag = 2; //修改标志位 2\n            c2.signal(); //通知BB线程\n        }finally {\n            //释放锁\n            lock.unlock();\n        }\n    }\n\n    //打印10次，参数第几轮\n    public void print10(int loop) throws InterruptedException {\n        lock.lock();\n        try {\n            while(flag != 2) {\n                c2.await();\n            }\n            for (int i = 1; i <=10; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //修改标志位\n            flag = 3;\n            //通知CC线程\n            c3.signal();\n        }finally {\n            lock.unlock();\n        }\n    }\n\n    //打印15次，参数第几轮\n    public void print15(int loop) throws InterruptedException {\n        lock.lock();\n        try {\n            while(flag != 3) {\n                c3.await();\n            }\n            for (int i = 1; i <=15; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //修改标志位\n            flag = 1;\n            //通知AA线程\n            c1.signal();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ThreadDemo3 {\n    public static void main(String[] args) {\n        ShareResource shareResource = new ShareResource();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print5(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print10(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print15(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"CC\").start();\n    }\n}\n\n```\n\n\n\n### Thread.join()\n\n#### 是什么？\n\n```\nThread.join()是一个线程等待的方法，调用该方法的线程会等待目标线程执行完毕后再继续执行\n\njoin()方法通常用于等待其他线程执行完毕后再继续执行，例如在主线程中启动多个子线程，然后使用join()方法等待所有子线程执行完毕后再统一进行处理。\n```\n\n#### 怎么用？\n\n例子: B等待A执行完后再执行\n\n还可以使用CountDownLatch来实现\n\n```java\n// 创建线程A\nThread threadA = new Thread(() -> {\n    // 线程A要执行的代码\n});\n\n// 创建线程B\nThread threadB = new Thread(() -> {\n    // 等待线程A执行完毕\n    try {\n        threadA.join();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    \n    // 线程B要执行的代码\n});\n\n// 启动线程A和线程B\nthreadA.start();\nthreadB.start();\n\n```\n\n### ThreadLocal\n\n#### 是什么？\n\n```\nThreadLocal，即线程变量，表示线程的“局部变量”, 是一个以ThreadLocal对象为键、任意对象为值的存储结构。\n它确保每个线程的ThreadLocal变量都是各自独立的；\nThreadLocal适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；\n```\n\n#### 怎么用？\n\n```java\nstatic ThreadLocal<User> threadLocalUser = new ThreadLocal<>(); // 通常总是以静态字段初始化\n\nvoid processUser(user) {\n    try {\n        threadLocalUser.set(user);\n        step1();\n        step2();\n    } finally {\n      \t// 一定要在finally中清除\n      \t// 因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果ThreadLocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。\n        threadLocalUser.remove();\n    }\n}\n\nvoid step1() {\n    User u = threadLocalUser.get();\n    log();\n    printUser();\n}\n\nvoid log() {\n    User u = threadLocalUser.get();\n    println(u.name);\n}\n\nvoid step2() {\n    User u = threadLocalUser.get();\n    checkUser(u.id);\n}\n```\n\n**优化：自动释放**\n\n例子：一个保存了当前用户名的`ThreadLocal`可以封装为一个`UserContext`对象：\n\n```java\npublic class UserContext implements AutoCloseable {\n\n    static final ThreadLocal<String> ctx = new ThreadLocal<>();\n\n    public UserContext(String user) {\n        ctx.set(user);\n    }\n\n    public static String currentUser() {\n        return ctx.get();\n    }\n\n    @Override\n    public void close() {\n        ctx.remove();\n    }\n}\n```\n\n使用\n\n```java\ntry (var ctx = new UserContext(\"Bob\")) {\n    // 可任意调用UserContext.currentUser():\n    String currentUser = UserContext.currentUser();\n} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象\n```\n\n\n\n## 5 线程应用实例\n\n### 等待超时模式\n\n调用一个方法时等待一段时间，如果该方法能够在给定的时间之内得到结果，直接返回；反之，超时返回默认结果。\n\n```java\n    public synchronized Object get(long mills) {\n        long future = System.currentTimeMillis() + mills;\n        long remaining = mills;\n        while(result == null && remaining > 0) {\n            wait(remaining);\n            remaining = future - System.currentTimeMillis();\n        }\n\n        return result;\n    }\n```\n\n\n\n### 数据库连接池示例\n\n描述\n\n```\n使用等待超时模式构建一个简单的数据库连接池，模拟从连接池中获取、使用和释放连接的过程。\n客户端获取连接的过程被设定为等待超时的模式，1000ms内无法获取可用连接返回null。\n连接池大小为10，通过调用客户端的连线数来模拟无法获取连接的场景。\n```\n\n连接池 `ConnectionPool.java`\n\n```java\npackage ConnectionPool;\n\nimport java.sql.Connection;\nimport java.util.LinkedList;\n\npublic class ConnectionPool {\n\n    private LinkedList<Connection> pool = new LinkedList<>();\n\n    public ConnectionPool(int initialSize) {\n        if(initialSize <= 0) return;\n        for(int i = 0; i < initialSize; i++) {\n            pool.addLast(ConnectionDriver.createConnection());\n        }\n    }\n\n    public void releaseConnection(Connection connection) {\n        if(connection == null) return;\n        synchronized(pool) {\n            // 添加后需要进行通知，这样其他消费者能够感知到链接池中已经归还了一个链接\n            pool.addLast(connection);\n            pool.notifyAll();\n        }\n    }\n\n    // 在mills内无法获取到连接，将会返回null\n    public Connection fetchConnection(long mills) throws InterruptedException {\n        synchronized(pool) {\n            // 完全超时\n            if(mills <= 0) {\n                while(pool.isEmpty()) {\n                    pool.wait();\n                }\n\n                return pool.removeFirst();\n            } else {\n                long future = System.currentTimeMillis() + mills;\n                long remaining = mills;\n                while(pool.isEmpty() && remaining > 0) {\n                    pool.wait(remaining);\n                    remaining = future - System.currentTimeMillis();\n                }\n\n                Connection result = null;\n                if(!pool.isEmpty()) {\n                    result = pool.removeFirst();\n                }\n                return result;\n            }\n        }\n    }\n}\n```\n\n数据库连接驱动器\n\n```java\npackage ConnectionPool;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.sql.Connection;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 这段代码主要实现了一个Connection的代理类。在Connection的代理类中，如果调用的方法是commit方法，就会休眠100毫秒。最后，代理类返回的结果是null。\n *\n * 这段代码的作用是模拟一个数据库连接的commit操作，以及在commit操作时的休眠效果。\n * 通常情况下，数据库的commit操作需要一定的时间才能完成，因此在实际应用中需要通过代理类来模拟commit操作的耗时。\n * 这样就能更好地测试代码在多线程环境下的可靠性。\n *\n * 这段代码的关键在于使用了代理类来实现Connection的commit操作。\n * 在代理类中，如果调用的方法是commit方法，就会休眠100毫秒。\n * 这种方式可以模拟commit操作需要一定的时间才能完成的情况。\n * 同时，由于代理类返回的结果是null，因此在测试时需要根据实际情况进行判断。\n */\npublic class ConnectionDriver {\n\n    static class ConnectionHandler implements InvocationHandler {\n        // @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if (method.getName().equals(\"commit\")) {\n                TimeUnit.MILLISECONDS.sleep(100);\n            }\n            return null;\n        }\n    }\n\n\n    // 创建一个Connection的代理，在commit时休眠1秒\n    public static final Connection createConnection() {\n        return (Connection) Proxy.newProxyInstance(\n                ConnectionDriver.class.getClassLoader(),\n                new Class<?>[]{Connection.class},\n                new ConnectionHandler()\n        );\n    }\n}\n\n```\n\n测试\n\n```java\npackage ConnectionPool;\n\nimport java.sql.Connection;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n\npublic class ConnectionPoolTest {\n    static ConnectionPool pool = new ConnectionPool(10);\n    static CountDownLatch start = new CountDownLatch(1);    // 相当于一个总开关，线程开启后阻塞在同一个地方，开启后所有线程统一执行\n    static CountDownLatch end;      // 打印日志的总开关，待所有线程执行解释后，再输出日志\n\n    static class ConnetionRunner implements Runnable {\n        int count;                  // 要起的线程数\n        AtomicInteger got;          // 记录获取到连接的数量\n        AtomicInteger notGot;       // 记录获取不到连接的数量\n\n        public ConnetionRunner(int count, AtomicInteger got, AtomicInteger notGot) {\n            this.count = count;\n            this.got = got;\n            this.notGot = notGot;\n        }\n\n        public void run() {\n            try {\n                start.await();  // 线程启动时先统一阻塞到该处，start.countDown();后统一执行\n            } catch (Exception ex) {\n\n            }\n            while (count > 0) {\n                try {\n                    // 从线程池中获取连接，如果1000ms内无法获取到，将会返回null\n                    // 分别统计连接获取的数量got和未获取到的数量notGot\n                    Connection connection = pool.fetchConnection(1000);\n                    if (connection != null) {\n                        try {\n                            connection.createStatement();\n                            connection.commit();\n                        } finally {\n                            pool.releaseConnection(connection);\n                            got.incrementAndGet();\n                        }\n                    } else {\n                        notGot.incrementAndGet();\n                    }\n                } catch (Exception ex) {\n                } finally {\n                    count--;\n                }\n            }\n            end.countDown();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        // 线程数量，可以线程数量进行观察\n        int threadCount = 50;\n        end = new CountDownLatch(threadCount);\n        int count = 20;\n        AtomicInteger got = new AtomicInteger();\n        AtomicInteger notGot = new AtomicInteger();\n        for (int i = 0; i < threadCount; i++) {\n            Thread thread = new Thread(new ConnetionRunner(count, got, notGot), \"ConnectionRunnerThread\");\n            thread.start();\n        }\n        start.countDown();\n        end.await();        // 50个线程执行完之后，才开始输出日志\n        System.out.println(\"total invoke: \" + (threadCount * count));\n        System.out.println(\"got connection:  \" + got);\n        System.out.println(\"not got connection \" + notGot);\n    }\n\n}\n\n```\n\n运行结果\n\n```\ntotal invoke: 1000\ngot connection:  826\nnot got connection 174\n```\n\n### 线程池\n\n`ThreadPool.java`\n\n```java\n/**\n * 线程池接口定义\n * @param <Job>\n */\npublic interface ThreadPool<Job extends Runnable> {\n    // 执行一个Job，这个Job需要实现Runnable\n    void execute(Job job);\n\n    // 关闭线程池\n    void shutdown();\n\n    // 增加工作者线程\n    void addWorkers(int num);\n\n    // 减少工作者线程\n    void removeWorker(int num);\n\n    // 得到正在等待执行的任务数量\n    int getJobSize();\n}\n```\n\n`DefaultThreadPool.java`\n\n```java\npackage ThreadPool;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class DefaultThreadPool <Job extends Runnable> implements ThreadPool<Job> {\n    // 线程池最大限制数\n    private static final int      MAX_WORKER_NUMBERS     = 10;\n    // 线程池默认的数量\n    private static final int      DEFAULT_WORKER_NUMBERS = 5;\n    // 线程池最小的数量\n    private static final int      MIN_WORKER_NUMBERS     = 1;\n    // 这是一个工作列表，将会向里面插入工作\n    private final LinkedList<Job> jobs                   = new LinkedList<Job>();\n    // 工作者列表\n    private final List<Worker> workers                   = Collections.synchronizedList(new ArrayList<Worker>());\n    // 工作者线程的数量\n    private int                   workerNum              = DEFAULT_WORKER_NUMBERS;\n    // 线程编号生成\n    private AtomicLong threadNum                         = new AtomicLong();\n\n    public DefaultThreadPool() {\n        initializeWokers(DEFAULT_WORKER_NUMBERS);\n    }\n\n    public DefaultThreadPool(int num) {\n        workerNum = num > MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num < MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;\n        initializeWokers(workerNum);\n    }\n\n    @Override\n    public void execute(Job job) {\n        if(job != null) {\n            // 添加一个工作，然后进行通知\n            synchronized (jobs) {\n                jobs.addLast(job);\n                jobs.notifyAll();\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        for(Worker worker : workers) {\n            worker.shutdown();\n        }\n    }\n\n    @Override\n    public void addWorkers(int num) {\n        synchronized (jobs) {\n            // 限制新增的Worker数量不能超过最大值\n            if(num + this.workerNum > MAX_WORKER_NUMBERS) {\n                num = MAX_WORKER_NUMBERS - this.workerNum;\n            }\n            initializeWokers(num);\n            this.workerNum += num;\n        }\n    }\n\n    @Override\n    public void removeWorker(int num) {\n        synchronized (jobs) {\n            if(num >= this.workerNum) {\n                throw new IllegalArgumentException(\"beyond workNum\");\n            }\n            // 按照给定的数量停止Worker\n            int count = 0;\n            while (count < num) {\n                workers.get(count).shutdown();\n                count++;\n            }\n            this.workerNum -= count;\n        }\n    }\n\n    @Override\n    public int getJobSize() {\n        return jobs.size();\n    }\n\n    // 初始化线程工作者\n    private void initializeWokers(int num) {\n        for (int i = 0; i < num; i++) {\n            Worker worker = new Worker();\n            workers.add(worker);\n            Thread thread = new Thread(worker, \"ThreadPool-Worker-\" + threadNum.incrementAndGet());\n            thread.start();\n        }\n    }\n\n    // 工作者，负责消费任务\n    class Worker implements Runnable {\n        // 是否工作\n        private volatile boolean running = true;\n\n        public void run() {\n            while(running) {\n                Job job = null;\n                synchronized (jobs) {\n                    while(jobs.isEmpty()) {\n                        try {\n                            jobs.wait();\n                        } catch (InterruptedException e) {\n                            // 感知到外部对WorkerThread的中断操作，返回\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                        // 去除一个job\n                        job = jobs.removeFirst();\n                    }\n                }\n\n                if(job != null) {\n                    try {\n                        job.run();\n                    } catch (Exception e) {\n                        // 忽略Job执行中的Exception\n                    }\n                }\n            }\n        }\n\n        public void shutdown() {\n            running = false;\n        }\n    }\n}\n\n```\n\n","timestamp":1691335064136},{"name":"02-Java中的锁.md","path":"001-JAVA/010-Java并发编程/02-Java中的锁.md","content":"\n\n# Java中的锁\n\n## Lock接口\n\n### 什么是Lock接口\n\n```java\npublic interface Lock {\n    void lock(); \n    void lockInterruptibly() throws InterruptedException; \n    boolean tryLock(); \n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException; \n    void unlock(); Condition newCondition();\n}\n```\n\n```\nLock是Java中提供的一个接口，用于实现【线程同步机制】，它可以替代Synchronized关键字。\nLock接口提供了比Synchronized更灵活、更强大的线程同步功能，可以用于解决多线程中的资源竞争和死锁等问题。\nLock接口的实现类有很多种，其中最常用的是ReentrantLock。\n\nLock接口提供了以下主要方法：\n- lock()：获取锁，如果锁已经被其他线程获取，则当前线程进入等待状态。\n- unlock()：释放锁，如果当前线程持有锁，则释放锁并唤醒等待的线程。\n- tryLock()：尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true，否则立即返回false。\n- tryLock(long time, TimeUnit unit)：尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true，否则等待指定时间后返回false。\n- newCondition()：创建一个Condition对象，用于实现等待/通知机制。\n\n需要注意的是，在使用Lock接口时，需要在finally代码块中释放锁，以确保锁一定会被释放，避免死锁的发生。\n```\n\n#### 什么是线程同步机制？\n\n```\n- 是什么？\n线程同步机制是多线程编程中常用的一种机制，用于控制多个线程对共享资源的访问。\n\n- 为什么？\n在多线程环境中，多个线程同时访问共享资源可能会导致竞争条件和数据不一致等问题，因此需要使用线程同步机制来避免这些问题的发生\n\n- 怎么样？\n1.synchronized\n2.Lock接口\n\n- 基本原理\n线程同步机制的基本原理是在共享资源的访问前获取锁，只有获取锁的线程才能访问共享资源，其他线程需要等待锁的释放。\n在共享资源访问完成后，释放锁，让其他线程可以继续访问共享资源。这样就保证了共享资源在任何时刻只能被一个线程访问，避免了竞争条件和数据不一致等问题的发生。\n\n- 使用时注意的问题\n1.使用线程同步机制时，应该避免死锁、饥饿等问题的发生，以确保程序的正常运行\n2.同时，在使用synchronized关键字时，应该尽量减小同步块的范围，以提高程序的性能。\n3.在使用Lock接口时，需要在finally代码块中释放锁，以确保锁一定会被释放，避免死锁的发生。\n```\n\n##### 在使用synchronized关键字时，为什么要减小同步块的范围？\n\n```\n1.提高性能\n范围越大，需要等待获取锁的线程越多，导致在获取锁的过程中需要等待其他线程释放锁，而其他线程释放锁的时间也会比较长，这就会造成线程的等待时间过长，降低程序的运行效率。\n2.避免死锁\n不同的线程可能会竞争多个锁，释放锁的时间也会比较长，导致相互等待，形成死锁。\n\n因此，为了避免以上问题的发生，应该尽量减小同步块的范围，只在必要的地方进行同步，这样可以提高程序的性能，同时也可以降低出现死锁等问题的概率。\n```\n\n##### 为什么使用lock接口需要在finally代码块中释放锁\n\n```\n- 为什么？\n在使用Lock接口进行线程同步时，需要手动获取和释放锁，这是两个独立的操作，如果在获取锁之后发生异常，就有可能导致锁没有被释放，从而导致死锁等问题的发生。\n- 怎么样？\n因此，将释放锁的操作放在finally代码块中，这样可以确保在任何情况下都会释放锁，避免死锁等问题的发生。\n```\n\n### Lock和Synchronized的区别？\n\n```\n- 是什么 & 作用\nLock和Synchronized都是Java中用于实现线程同步的机制，它们的目的是为了避免线程间的竞争条件和数据不一致等问题。它们的区别如下：\n\n- 区别\n1.锁的获取方式：\n\tSynchronized是在进入同步代码块或同步方法时，自动获取锁，退出同步代码块或方法时自动释放锁；而Lock需要手动获取锁，并且必须手动释放锁。\n2.锁的粒度：\n\tSynchronized只能对整个方法或代码块进行加锁，而Lock可以对代码块进行更细粒度的控制。\n3.可中断性：\n\t在获取锁时，Synchronized是不可中断的，即使该线程在等待锁的过程中被中断，也不会释放锁；而Lock可以根据需要设置锁的可中断性。\n4.公平锁：\n\tSynchronized是非公平锁，不保证等待时间最长的线程最先获取锁；而Lock可以通过参数指定为公平锁或非公平锁。\n5.性能：\n\t相比较而言，Lock的性能比Synchronized好，在高并发的情况下，Lock的吞吐量比Synchronized更高。\n\n需要注意的是，Lock是在JDK 5中引入的，而Synchronized是Java早期就提供的同步机制。由于Lock相比Synchronized更灵活和高效，因此在实际开发中，使用Lock的场景会更多。\n```\n\n### Lock的使用方式\n\n```java\nLock lock = new ReentrantLock();\nlock.lock();\ntry {\n  ...\n} finally {\n  lock.unlock();\n}\n```\n\n\n\n## 队列同步器AQS\n\n\n\n## 重入锁ReentrantLock\n\n### 什么是重入锁？\n\n```\n- 是什么？\n可重入锁是指同一个线程在持有某个锁的情况下，可以继续获取该锁而不会出现死锁的情况\n\n- synchronized关键字实现原理\n每个对象都有一个监视器锁（monitor），线程进入同步块时获取该对象的监视器锁，并在同步块结束时释放该锁，当一个线程在持有该锁的情况下再次进入同步块时，会自动获取该锁，而不会被阻塞。\n\n- ReentrantLock重入锁实现原理\n它使用一个计数器来记录线程获取锁的次数。当一个线程第一次获取锁时，计数器的值为1，当同一个线程再次获取锁时，计数器的值会递增，当线程退出同步块时，计数器的值递减，直到计数器的值为0时，锁被释放。这种机制保证了线程可以多次获取同一个锁而不会出现死锁的情况。\n```\n\n### 什么是ReentrantLock & 特点\n\n```\n- 是什么？\nReentrantLock是Java中实现Lock接口的一个类，它提供了与synchronized关键字类似的线程同步机制\n\n- 特点\n1.可重入性：\n\t与synchronized关键字一样，ReentrantLock支持可重入锁，即同一个线程可以多次获取同一个锁而不会死锁\n2.公平锁与非公平锁：\n\tReentrantLock提供了两种锁的实现方式，即公平锁和非公平锁。公平锁会按照线程的请求顺序来分配锁，而非公平锁则允许线程在竞争时插队，可能会导致某些线程长时间等待。\n3.条件变量：\n\tReentrantLock提供了Condition接口的实现类Condition，它可以将一个锁分为多个条件，使得线程可以在指定条件下等待和唤醒。这使得线程间的通信变得更加灵活。\n3.可中断性：\n\t与synchronized关键字不同，ReentrantLock提供了可中断锁的机制。即当一个线程等待获取锁时，可以通过中断等待的线程来结束等待。\n\nReentrantLock相对于synchronized关键字来说，具有更强的灵活性和可定制性，但需要手动获取和释放锁，使用时也需要注意避免死锁、饥饿等问题的发生。\n```\n\n\n\n### 公平锁与非公平锁\n\n\n\n## 读写锁\n\n### 什么是读写锁？\n\n```\n读写锁（ReadWriteLock）是Java中的一种同步机制，允许多个线程同时读共享资源，但只允许一个线程写共享资源。它是一种悲观锁，因为它默认情况下假设写操作比读操作更加耗时，因此优先考虑写操作的互斥。\n\n读写锁的主要特点是：\n1.在同一时刻可以允许多个线程进行读操作。\n2.写操作时独占锁，只有一个线程可以进行写操作。\n3.写操作和读操作之间互斥，即在一个线程进行写操作的时候，其他线程无法进行读和写操作，直到写操作完成。\n\n读写锁通常分为两种类型：读锁和写锁，写锁是独占锁，读锁是共享锁。在读锁被获取的情况下，其他线程仍然可以获取读锁，但不能获取写锁，因为写锁需要排除所有的读锁和其他的写锁。\n```\n\n\n\n### 读写锁的使用方式\n\n例子：非线程安全的HashMap作为缓存的实现\n\n```java\npublic class Cache {\n    private static final Map<String, Object>    map = new HashMap<String, Object>();\n    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    private static final Lock                   r   = rwl.readLock();\n    private static final Lock                   w   = rwl.writeLock();\n\n    public static final Object get(String key) {\n        r.lock();\t// 获取读锁，并发访问该方法时不会被阻塞\n        try {\n            return map.get(key);\n        } finally {\n            r.unlock();\n        }\n    }\n\n    public static final Object put(String key, Object value) {\n        w.lock();\t// 获取写锁，其他线程获取读、写锁会被阻塞，只有该写锁释放后才能继续操作\n        try {\n            return map.put(key, value);\n        } finally {\n            w.unlock();\n        }\n    }\n\n    public static final void clear() {\n        w.lock();\n        try {\n            map.clear();\n        } finally {\n            w.unlock();\n        }\n    }\n}\n```\n\n\n\n### 读写锁的实现\n\n#### 读写状态的设计\n\n#### 写锁的获取与释放\n\n#### 读锁的获取与释放\n\n#### 锁降级\n\n\n\n### Condition接口\n\n#### 使用方式\n\n##### 例子1\n\n```java\npublic class ConditionUseCase {\n    Lock      lock      = new ReentrantLock();\n    Condition condition = lock.newCondition();\n\n    public void conditionWait() throws InterruptedException {\n        lock.lock();\n        try {\n            condition.await();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void conditionSignal() throws InterruptedException {\n        lock.lock();\n        try {\n            condition.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n##### 例子2： 有界队列\n\n有界队列：是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素；\n\n当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”\n\n```java\npackage Lock;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class BoundedQueue <T> {\n    private Object[] items;\n    // 添加的下标，删除的下标和数组当前数量\n    private int       addIndex, removeIndex, count;\n    private Lock      lock      = new ReentrantLock();\n    private Condition notEmpty  = lock.newCondition();\n    private Condition notFull   = lock.newCondition();\n\n    public BoundedQueue(int size) {\n        items = new Object[size];\n    }\n\n    // 添加一个元素，如果数组满，则添加线程进入等待状态，直到有“空位”\n    public void add(T t) throws InterruptedException{\n        lock.lock();\n        try {\n            while(count  == items.length) {\n                notFull.await();\n            }\n            items[addIndex] = t;\n            if(++addIndex == items.length) {\n                addIndex = 0;\n            }\n            ++count;\n            notEmpty.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素\n    // @SuppressWarnings(\"unchecked\")注解告诉编译器忽略类型转换时的警告信息。Object类型的对象x强制转换为了泛型类型T\n    @SuppressWarnings(\"unchecked\")\n    public T remove() throws InterruptedException {\n        lock.lock();\n        try {\n            while(count == 0) {\n                notEmpty.await();\n            }\n            Object x = items[removeIndex];\n            if(++removeIndex == items.length) {\n                removeIndex = 0;\n            }\n            --count;\n            notFull.signal();\n            return (T) x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n\n\n### Condition的实现原理\n\nTODO\n","timestamp":1691335064136},{"name":"03-Java并发容器和框架.md","path":"001-JAVA/010-Java并发编程/03-Java并发容器和框架.md","content":"# Java并发容器和框架\n\n## ConcurrentHashMap\n\n### HashMap为什么不是线程安全的？\n\n```java\nHashMap 不是线程安全的主要原因是它在进行 put 和 resize 操作时，没有进行同步处理。\n具体来说，在进行 resize 操作时，需要重新计算每个元素的索引位置，并且重新分配数组，如果多个线程同时进行 resize 操作，会导致多个线程在操作同一个数组，产生冲突，进而导致数据丢失或死循环等问题。\n另外，在进行 put 操作时，由于 HashMap 不是线程安全的，因此多个线程可能同时修改同一个链表，从而导致链表数据不一致或链表出现环等问题。\n\npublic class Test {\n    public static void main(String[] args) {\n        final HashMap<String, String> map = new HashMap<String, String>(2);\n        Thread t = Thread(new Runnable() {\n            public void run() {\n                for(int i = 0; i < 10000; i++) {\n                    new Thread(new Runnable() {\n                        @Override\n                        public void run() {\n                            map.put(UUID.randomUUID().toString(), \"\");\n                        }\n                    }, \"ftf\" + i).start();\n                }\n            }\n        }, \"ftf\");\n        t.start();\n        t.join();\n    }\n}\n```\n\n### HashMap的put操作为什么会出现环？原理是什么？\n\n```\n在 HashMap 内部，每个元素都是一个 Entry 对象，包含了键、值以及指向下一个 Entry 的指针，它们被存储在一个数组中。在执行 put 操作时，首先会计算 key 的哈希值，然后根据这个哈希值定位到数组中的一个索引位置。如果该索引位置为空，那么就将 Entry 对象放入该位置；如果该位置已经有了 Entry 对象，那么就顺着链表一直往下遍历，直到找到一个空的位置，并将 Entry 对象放入该位置。\n\n在多线程环境下，如果多个线程同时对 HashMap 进行 put 操作，可能会出现多个线程定位到了同一个索引位置，并且同时在链表头插入新的 Entry 对象，此时就会出现多个线程并发修改同一个链表的情况。这时就有可能出现覆盖的情况，即一个线程的修改被另一个线程覆盖了，导致数据丢失和死循环等问题。\n```\n\n\n\n### 为什么要使用ConcurrentHashMap？优势？\n\n```\n- 现有技术存在的问题\n1.【HashMap是线程非安全的】。\n\t在多线程环境下，使用hashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap\n2.【HashTable线程安全，但效率低下】\n  1）HashTable容器使用synchronized来保证线程安全，同一时刻只有一个线程能够访问哈希表，其他线程会被阻塞。一个线程put时其他线程不能put、get。\n  2）HashTable 在进行扩容时，需要将整个哈希表重新计算，并将数据复制到新的哈希表中，这也会导致性能的下降。\n  \n- ConcurrentHashMap的优势\n1.【线程安全】：ConcurrentHashMap是线程安全的，多个线程可以同时访问和修改ConcurrentHashMap中的元素，而不会导致数据结构的损坏或数据的丢失。\n2.【更高的并发性能】：ConcurrentHashMap的实现采用了分段锁的机制，对不同的数据段采用不同的锁，因此可以支持更高的并发性能，多个线程可以同时读取ConcurrentHashMap中的不同元素，而不会产生锁竞争。\n3.【更高的扩展性】：ConcurrentHashMap在扩容时可以分段进行扩容，只需要锁住当前需要扩容的数据段，而不需要锁住整个HashMap，因此扩容时可以支持更高的并发性能。\n4.【更好的迭代性能】：ConcurrentHashMap提供了一个专门的迭代器ConcurrentHashMap.KeySetView，可以在迭代过程中保证线程安全性和数据的一致性。\n```\n\n\n\n### 实现原理\n\nTodo\n\n\n\n## ConcurrentLinkedQueue\n\n### 实现安全队列的方法\n\n```\n1.使用阻塞算法\n  用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）来实现\n2.使用非阻塞算法\n  使用循环CAS的方式实现。即ConcurrentLinkedQueue的实现方式\n```\n\n### 是什么？\n\n```\nConcurrentLinkedQueue是Java中的一个线程安全的队列数据结构，可以被多个线程同时访问，支持高并发场景下的高效数据存储和访问。\n\n- 实现方式\nConcurrentLinkedQueue是基于链表实现的，它采用了一种叫做\"无锁并发编程\"的技术，利用CAS（Compare And Swap）操作和volatile关键字实现了线程安全。\n- 主要特点\n它的主要特点是在高并发情况下性能比较好，因为它没有使用锁，而是采用了一些比较高级的技术来实现并发控制，避免了因为锁竞争而导致的性能问题。\n\n- 基本操作\nConcurrentLinkedQueue支持队列的基本操作，包括入队（offer()）、出队（poll()）、获取队首元素（peek()）等。除此之外，它还提供了一些扩展操作，如批量添加元素（addAll()）、元素替换（replace()）等。\n- 主要缺点\n它的主要缺点是不支持随机访问，因为它是基于链表实现的，所以无法像ArrayList那样根据下标随机访问元素。\n```\n\n### 实现原理\n\nTODO\n\n\n\n## Java中的阻塞队列\n\n### 什么是阻塞队列？\n\n```\n\n```\n\n\n\n### 为什么使用？使用场景\n\n### Java中的阻塞队列\n\n```\nArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列\nLinkedBlockingQueue: 链表、无界队列\nPriorityBlockingQueue: 优先级排序、无界队列\nDelayQueue: 优先级队列实现的无界阻塞队列\nSynchronousQueue: 不存储元素的阻塞队列\nLinkedTransferQueue: 链表、无界阻塞队列\nLinkedBlockingQUeue: 链表、双向组设队列\n```\n\n### 实现原理\n\nTODO\n\n\n\n## Fork/Join框架\n\n### 是什么？\n\n```\n是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干小任务，最终汇总每个小任务结果后得到大任务结果的框架。\n```\n\n### 工作窃取算法\n\n### Fork/Join框架设计\n\n### 如何使用？\n\n### 实现原理\n\n\n\n","timestamp":1691335064136},{"name":"04-Java中的原子操作类.md","path":"001-JAVA/010-Java并发编程/04-Java中的原子操作类.md","content":"# Java中的13个原子操作类\n\n## 原子更新基本类型类\n\n### 有哪些？\n\n```\nAtomicBoolean: 原子更新布尔类型\nAtomicInteger：原子更新整型\nAtomicLong：原子更新长整型\n```\n\n### 如何使用？\n\n三个类提供的方法几乎一摸一样，以`AtomicInteger`\n\n```\nint addAndGet(int delta)\nboolean compareAndSet(int expect, int update)  如果输入的数值等于预期值，则以原子方式将该值设置为输入的值\nint getAndIncrement() 以原子方式将当前值+1，返回自增前的值\nvoid lazySet(int newValue)\nint getAndSet(int newValue) 以原子方式设置为newValue值，返回旧值\n```\n\n### getAndIncrement实现原理\n\nTODO\n\n## 原子更新数组\n\n### 有哪些\n\n```\nAtomicIntegerArray 原子更新整型数组里的元素\nAtomicLongArray 原子更新长整型数组里的元素\nAtomicReferenceArray 原子更新引用类型数组里的元素\n```\n\n\n\n## 原子更新引用类型\n\n\n\n## 原子更新字段类","timestamp":1691335064136},{"name":"05-Java中的并发工具类.md","path":"001-JAVA/010-Java并发编程/05-Java中的并发工具类.md","content":"# Java中的并发工具类\n\n## CountDownLatch\n\n### 是什么？有什么用？\n\n```\n\n```\n\n\n\n### 使用案例：模拟解析Excel里的多个sheel的数据\n\njoin()实现\n\n```java\npublic class JoinCountDownLatchTest {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread parser1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName());\n            }\n        });\n\n        Thread parser2 = new Thread(()->{\n            System.out.println(Thread.currentThread().getName());\n        }, \"parser2\");\n\n        parser1.start();\n        parser2.start();\n        parser1.join();\n        parser2.join();\n    }\n}\n```\n\nCountDownLatch实现\n\n```java\npublic class CountDownLatchTest {\n\n    static CountDownLatch c = new CountDownLatch(2);\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(()->{\n            System.out.println(1);\n            c.countDown();\n            System.out.println(2);\n            c.countDown();\n        }).start();\n\n        c.wait();\n        System.out.println(3);\n    }\n}\n```\n\n\n\n## 同步屏障CyclicBarrier\n\n### 是什么？\n\n```\nCyclicBarrier是Java中的一个同步辅助类，它可以让一组线程在某个屏障点处相互等待，然后同时继续执行。\n它的主要作用是实现线程间的同步，确保多个线程在某个点上达到同步状态后再同时执行后续操作。\n\nCyclicBarrier的构造函数可以指定一个参与同步的线程数量，当有足够数量的线程调用了CyclicBarrier的await()方法后，所有线程都会被释放，并继续执行后续的任务。\n\nCyclicBarrier适用于需要等待所有线程都到达某个状态后再同时执行后续操作的场景，常见的应用包括多线程计算任务的结果合并、分布式系统中任务的协调与等待等。\n```\n\n### 使用方法\n\n`CyclicBarrier(int parties)`\n\n`parties表示屏障拦截的线程数量`\n\n```java\npublic class CyclicBarrierTest {\n\n    static CyclicBarrier c = new CyclicBarrier(2);\t\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    c.await();\t\t// 调用await告诉CyclicBarrier已经到达屏障，然后阻塞；两个线程执行c.await()才继续执行\n                } catch (Exception e) {\n\n                }\n                System.out.println(1);\n            }\n        }).start();\n\n        try {\n            c.await();\n        } catch (Exception e) {\n\n        }\n        System.out.println(2);\n    }\n}\n```\n\n`CyclicBarrier(int parties, Runnable barrierAction)`\n\n`barrierAction表示到达屏障时优先执行的线程`\n\n```java\npublic class CyclicBarrierTest2 {\n\n    static CyclicBarrier c = new CyclicBarrier(2, new A());\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    c.await();\n                } catch (Exception e) {\n\n                }\n                System.out.println(1);\n            }\n        }).start();\n\n        try {\n            c.await();\n        } catch (Exception e) {\n\n        }\n        System.out.println(2);\n    }\n\n    static class A implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(3);\n        }\n\n    }\n\n}\n```\n\n### 应用场景\n\n```\nCyclicBarrier适用于需要等待所有线程都到达某个状态后再同时执行后续操作的场景，常见的应用包括多线程计算任务的结果合并、分布式系统中任务的协调与等待等。\n```\n\n```\n例子：用一个Excel保存了用户的所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户的日均银行流水：\n1 先用多线程处理每个sheet里的银行流水，都执行完后，得到每个sheet的日均银行流水\n2 barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水\n```\n\n```java\nimport java.util.concurrent.*;\nimport java.util.Map.Entry;\n\npublic class BankWaterService implements Runnable {\n\n    /* 创建4个屏障，处理完之后执行当前类的run方法 */\n    private CyclicBarrier c = new CyclicBarrier(4, this);\n\n    /* 假设有4个sheet， 所以只需要启动4个线程 */\n    private Executor executor = Executors.newFixedThreadPool(4);\n\n    /* 保存每个sheet计算出的银流结果 */\n    private ConcurrentHashMap<String, Integer> sheetBankWaterCount = new ConcurrentHashMap<>();\n\n    private void count() {\n        for(int i = 0; i < 4; i++) {\n            executor.execute(()->{\n                // 计算当前sheet的银流数据，计算代码省略\n                sheetBankWaterCount.put(Thread.currentThread().getName(), 1);\n\n                // 银流计算完成，插入一个屏障\n                try {\n                    c.await();\n                } catch (InterruptedException | BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n    }\n\n    public void run() {\n        int result = 0;\n        // 汇总每个sheet计算出的结果\n        for(Entry<String, Integer> sheet : sheetBankWaterCount.entrySet()) {\n            result += sheet.getValue();\n        }\n\n        // 将结果输出\n        sheetBankWaterCount.put(\"result: \", result);\n        System.out.println(result);\n    }\n\n    public static void main(String[] args) {\n        BankWaterService bankWaterService = new BankWaterService();\n        bankWaterService.count();\n    }\n}\n```\n\n## CountDownLatch和CyclicBarrier的区别\n\n```\n1.使用方式：CyclicBarrier用于一组线程中的多个线程等待彼此达到一个共同的屏障点后再同时继续执行；而CountDownLatch用于一个线程或多个线程等待其他线程完成某个操作后再继续执行。\n\n2.循环使用性：CyclicBarrier是可重用的，可以在多个循环中使用。当所有参与线程都到达屏障点后，CyclicBarrier会重置并可以再次使用；而CountDownLatch是一次性的，一旦计数器归零，就不能再次使用。\n\n3.参与线程数量：CyclicBarrier可以在创建时指定参与同步的线程数量，可以灵活地适应不同的场景需求；而CountDownLatch的计数器是固定的，一旦创建就无法修改。\n\n4.屏障动作：CyclicBarrier可以指定在所有线程到达屏障点时执行一个可选的屏障动作（Runnable）；而CountDownLatch没有提供屏障动作的功能。\n\n5.同步点的性质：CyclicBarrier是同步点，所有线程在此等待，直到所有线程都达到同步点才能继续执行；而CountDownLatch只是一个等待点，线程等待计数器变为0后就可以继续执行。\n```\n\n“一组线程中的多个线程等待彼此达到一个共同的屏障点后再同时继续执行” 和 “一个线程或多个线程等待其他线程完成某个操作后再继续执行”有啥区别\n\n```\n这两个描述之间的区别在于等待的对象和等待的条件。\n\n在CyclicBarrier中，一组线程中的多个线程等待彼此达到一个共同的屏障点后再同时继续执行。这意味着每个线程在达到屏障点之前都会阻塞等待其他线程的到来。只有当所有线程都到达屏障点后，它们才会同时继续执行后续操作。\n\n而在CountDownLatch中，一个线程或多个线程等待其他线程完成某个操作后再继续执行。这意味着某个线程或多个线程会调用CountDownLatch的await()方法进行等待，直到其他线程完成特定操作并调用CountDownLatch的countDown()方法将计数器减少到0，等待的线程才会被唤醒并继续执行。\n\n总的来说，CyclicBarrier用于多个线程之间相互等待达到一个共同的屏障点，而CountDownLatch用于一个或多个线程等待其他线程完成某个操作。CyclicBarrier是多线程间的同步，而CountDownLatch是线程间的等待和通信。\n```\n\n## 控制并线程数的semaphore\n\n### 是什么？使用场景？\n\n```\nSemaphore（信号量）是Java中的一个同步工具类，用于控制同时访问某个资源的线程数量。\n\nSemaphore维护了一组许可（permits），线程在访问资源之前必须先获取许可，如果许可数大于0，则线程可以获取许可并继续执行；如果许可数等于0，则线程必须等待，直到有其他线程释放许可。\n```\n\n### 主要特点\n\n```\nSemaphore的主要特点包括：\n\n1.许可数量：Semaphore可以指定初始化时的许可数量，表示可以同时访问某个资源的线程数量。\n\n2.许可获取和释放：线程可以通过acquire()方法获取许可，如果许可数大于0，则线程可以继续执行；否则，线程会被阻塞等待。线程在使用完资源后，需要通过release()方法释放许可，以供其他线程使用。\n\n3.公平性：Semaphore可以选择是否使用公平的获取许可的策略。如果设置为公平模式，那么等待时间最长的线程将优先获得许可。\n```\n\n### 使用场景\n\n```\nSemaphore适用于控制对某个资源的并发访问数量，例如限制数据库连接数、限制线程池的线程数等场景。通过合理地控制许可数量，可以避免资源过度竞争和线程的过度并发，从而保证系统的稳定性和性能。\n```\n\n### 使用方式\n\n```java\npublic class SemaphoreTest {\n\n    private static final int       THREAD_COUNT = 30;\t\t// 线程数\n\n    private static ExecutorService threadPool   = Executors.newFixedThreadPool(THREAD_COUNT);\n\n    private static Semaphore       s            = new Semaphore(10);\t\t// 最大并发数\n\n    public static void main(String[] args) {\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        s.acquire();\t// 获取许可证\n                        System.out.println(\"save data\");\n                        s.release();\t// 释放许可证\n                    } catch (InterruptedException e) {\n                    }\n                }\n            });\n        }\n\n        threadPool.shutdown();\n    }\n}\n\n```\n\n\n\n## 线程间交换数据的Exchanger\n\n### 是什么？\n\n```\nExchanger（交换器）是Java中的一个同步工具类，用于两个线程之间进行数据交换。\n\nExchanger提供一个点，两个线程可以通过该点交换数据。其中，一个线程会调用exchange()方法来等待另一个线程到达交换点，并将自己的数据传递给另一个线程。当两个线程都到达交换点时，它们会交换数据，并继续执行后续操作。\n```\n\n### 主要特点\n\n```\n1.数据交换：两个线程可以在交换点交换数据，通过exchange()方法来进行数据的发送和接收。\n\n2.线程同步：交换操作是同步的，即当一个线程调用exchange()方法时，如果另一个线程未到达交换点，则会阻塞等待，直到另一个线程到达交换点为止。\n\n3.数据一致性：通过Exchanger交换的数据可以保证在两个线程之间是一致的，即发送方线程传递的数据会被接收方线程接收到。\n```\n\n### 应用场景\n\n```\nExchanger适用于需要两个线程之间进行数据交换的场景，例如线程间的数据传递、协作计算等。通过Exchanger，可以实现线程之间的数据共享和协作，从而提高并发编程的灵活性和效率。\n```\n\n### 使用方式\n\n例子：将纸质银行流水通过人工方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel后，系统需要加载这两个Excel，并对数据进行校对，看录入是否一致。\n\n```java\npublic class ExchangerTest {\n\n    private static final Exchanger<String> exgr       = new Exchanger<String>();\n\n    private static ExecutorService         threadPool = Executors.newFixedThreadPool(2);\n\n    public static void main(String[] args) {\n\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    String A = \"银行流水A\";// A录入银行流水数据\n                    exgr.exchange(A);\n                } catch (InterruptedException e) {\n                }\n            }\n        });\n\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    String B = \"银行流水B\";// B录入银行流水数据\n                    String A = exgr.exchange(\"B\");\n                    System.out.println(\"A和B数据是否一致：\" + A.equals(B) + \"，A录入的是：\" + A + \"，B录入是：\" + B);\n                } catch (InterruptedException e) {\n                }\n            }\n        });\n\n        threadPool.shutdown();\n\n    }\n}\n```\n\n","timestamp":1691335064136},{"name":"06-Java中的线程池.md","path":"001-JAVA/010-Java并发编程/06-Java中的线程池.md","content":"# Java中的线程池\n\n## 线程池概述\n\n### 是什么？\n\n```\nJava中的线程池是一种用于管理和复用线程的机制，它可以有效地管理线程的创建、销毁和复用，从而提高应用程序的性能和资源利用率。\n\nJava中的线程池是通过Executor框架来实现的，主要包括以下几个核心组件：\n1.Executor接口：\n\t定义了线程池的执行方法，用于提交任务。\n2.ExecutorService接口：\n\t继承自Executor接口，提供了更丰富的线程池操作方法，例如任务提交、任务执行状态管理、线程池的关闭等。\n2.ThreadPoolExecutor类：\n\t是Java中默认的线程池实现类，实现了ExecutorService接口。它提供了可配置的线程池，可以根据需要自定义线程池的核心线程数、最大线程数、线程空闲时间等参数。\n```\n\n### 优点\n\n```\n1.重用线程，降低资源消耗：线程池可以重用已创建的线程，避免了频繁创建和销毁线程的开销。\n2.控制并发度：线程池可以限制并发线程的数量，通过控制核心线程数、最大线程数和任务队列的大小来控制线程池的并发度，避免系统资源被过度占用。\n3.提高响应速度：线程池可以通过复用线程，减少线程的创建和销毁时间，从而提高任务的响应速度。\n4.统一管理：线程池可以统一管理线程的生命周期、状态和执行结果，方便任务的提交、取消和获取执行结果。\n```\n\n\n\n## 实现原理\n\n![image-20230513125820492](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/13/12582016839539001683953900698IOTwhM-image-20230513125820492.png)\n\n![image-20230513125913452](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/13/12591316839539531683953953567PnBFMg-image-20230513125913452.png)\n\n工作流程：\n```\n1 创建线程池时，线程池中线程数为0\n2 调用execute()添加一个请求任务时：\n\t2.1 当前运行线程数 < corePoolSize   ==> 创建新线程执行任务（执行这一步需要获取全局锁）\n\t2.2 当前运行线程数 >= corePoolSize  ==> 将任务加入BlockingQueue\n\t2.3 如果BlockingQueue已满 & 正在运行线程数 < maximumPoolSize\t ==> 创建非核心线程处理任务（执行这一步需要获取全局锁）\n\t2.4 如果BlockingQueue已满 & 正在运行线程数 >= maximumPoolSize  ==> 按照饱和拒绝策略执行\n3 当工作线程执行完任务后，会从队列中取出任务执行；如果没有待执行的任务，则线程进入空闲状态，等待新的任务分配。\n4 当一个线程空闲超过一定时间（keepAliveTime）：\n\t4.1 当前运行线程数 >= corePoolSize\t\t==> 停掉线程\n\t4.2 线程池的所有任务执行完成，会收缩到corePoolSize的大小\n```\n\n## 线程池的使用\n\n### 拒绝策略\n\n```\nCallerRunsPolicy: 使用调用者所在线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能上损失较大。\nAbortPolicy（默认）: 丢弃任务，并抛出拒绝执行RejectedExecutionException异常信息。必须处理好抛出的异常，否则会打断当前执行流程，影响后续的任务执行\nDiscardPolicy: 直接丢弃。\nDiscardOldestPolicy: 丢弃阻塞队列中等待时间最久的任务，并加入新任务\n```\n\n### 线程池的创建\n\n```java\nnew ThreadPoolExecutor (\n    corePoolSize, \t\t// 线程池的核心线程数\n    maximumPoolSize,  // 能容纳的最大线程数\n    keepAliveTime, \t\t// 空闲线程存活时间\n    unit, \t\t\t\t\t\t// 存活的时间单位\n    workQueue, \t\t\t\t// 存放提交但未执行任务的队列\n    threadFactory, \t\t// 创建线程的工厂类\n    handler\t\t\t\t\t\t// 等待队列满后的拒绝策略\n  );\n```\n\n\n\n### 向线程池提交任务\n\n#### 方式一：execute()\n\n```java\n// 用于提交不需要返回值的任务，无法判断任务是否被线程池执行成功\nthreadsPool.execute(new Runnable() {\n  public void run() {\n    \n  }\n})\n```\n\n#### 方式二：submit()\n\n```java\n// 用于提交需要返回值的任务。\n// 线程池会返回一个future类型的对象，通过这个对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程知道任务完成; 通过get(long timeout, TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候任务可能没有执行完。\nFuture(Object) future = executor.submit(harReturnValuetask);\ntry {\n\tObject s- future.get();\n} catch (InterruptedExeception e) {\n  // 处理中断异常\n} catch(ExecutionException e) {\n  // 处理无法执行任务异常\n} finally {\n  // 关闭线程池\n  executor.shutdown();\n}\n\n```\n\n### 关闭线程池\n\n```\n可以调用线程池的shutdown或shutdownNow方法来关闭线程池。\n\n原理：\n它们的原理都是遍历线程池中工作线程，逐个调用线程中的interrupt方法来中断，所以无法响应中断的任务可能永远无法停止。\n\n区别：\nshutdownNow先将线程池的状态设置为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。\nshutdown只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行任务的线程\n\n共同点：\n调用任意一个关闭方法，isShutdown方法就会返回true。\n当所有的任务都已经关闭后，才表示线程池关闭成功，调用isTerminaed方法会返回true。\n\n如何选择：\n通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以选择shutdownNow方法。\n```\n\n### 注意事项\n\n```\n1 项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都 有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用 LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE， 容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参 数，自定义线程池\n创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建\n```\n\n3. 为什么不允许适用不允许 Executors.的方式手动创建线程池\n\n![image-20230514202727417](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/14/20272716840672471684067247591WgZgej-image-20230514202727417.png)\n\n### 入门案例\n\n```\n场景：火车站3个售票口，10个用户买票\n```\n\n```java\npackage ThreadPool;\n\nimport java.util.concurrent.*;\n\npublic class ThreadPoolDemo1 {\n\n    public static void main(String[] args) {\n        // 定义线程池，线程数量为3，模拟3个窗口\n        ExecutorService threadService = new ThreadPoolExecutor(\n                3,\n                3,\n                60L,\n                TimeUnit.SECONDS,\n                new LinkedBlockingQueue<>(),\n                Executors.defaultThreadFactory(),\n                new ThreadPoolExecutor.DiscardOldestPolicy()\n        );\n\n        // 10个人买票\n        try {\n            for(int i = 1; i <= 10; i++) {\n                threadService.execute(()->{\n                    try {\n                        System.out.println(Thread.currentThread().getName() + \"窗口，开始卖票\");\n                        Thread.sleep(5000);\n                        System.out.println(Thread.currentThread().getName() + \"窗口，买票结束\");\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                });\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            // 完成后结束\n            threadService.shutdown();\n        }\n    }\n}\n\n// 输出\npool-1-thread-1窗口，开始卖票\npool-1-thread-3窗口，开始卖票\npool-1-thread-2窗口，开始卖票\npool-1-thread-3窗口，买票结束\npool-1-thread-1窗口，买票结束\npool-1-thread-3窗口，开始卖票\npool-1-thread-1窗口，开始卖票\npool-1-thread-2窗口，买票结束\npool-1-thread-2窗口，开始卖票\npool-1-thread-3窗口，买票结束\npool-1-thread-3窗口，开始卖票\npool-1-thread-1窗口，买票结束\npool-1-thread-1窗口，开始卖票\npool-1-thread-2窗口，买票结束\npool-1-thread-2窗口，开始卖票\npool-1-thread-1窗口，买票结束\npool-1-thread-1窗口，开始卖票\npool-1-thread-2窗口，买票结束\npool-1-thread-3窗口，买票结束\npool-1-thread-1窗口，买票结束\n```\n\n","timestamp":1691335064136},{"name":"07-Executor框架.md","path":"001-JAVA/010-Java并发编程/07-Executor框架.md","content":"# Executor框架\n\n## 概述\n\n### 是什么？\n\n```\nExecutor 框架是 Java 并发编程中提供的一个高级工具，用于简化多线程编程中线程的管理和任务的执行。它提供了一组接口和类，用于创建和管理线程池，提交任务，执行任务，并处理任务的完成结果。\n```\n\n### 已经有了线程池，为什么还需要Executor？\n\n```\n我们知道线程池就是线程的集合，线程池集中管理线程，以实现线程的重用，降低资源消耗，提高响应速度等。线程用于执行异步任务，单个的线程既是工作单元也是执行机制，从JDK1.5开始，为了把工作单元与执行机制分离开，Executor框架诞生了，他是一个用于统一创建与运行的接口。Executor框架实现的就是线程池的功能。\n```\n\n## Executor框架的结构\n\n```\nExecutor框架包括3大部分：\n（1）任务。也就是工作单元，包括被执行任务需要实现的接口：Runnable接口或者Callable接口；\n（2）任务的执行。也就是把任务分派给多个线程的执行机制，包括Executor接口及继承自Executor接口的ExecutorService接口。\n（3）异步计算的结果。包括Future接口及实现了Future接口的FutureTask类。\n\n```\n\n### Executor框架的成员及其关系\n\n![Java并发——Executor框架详解_Java并发](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/14/22181516840738951684073895234TFvjIo-resize,m_fixed,w_1184-20230514221815144.jpg)\n\n### Executor框架的使用示意图\n\n![Java并发——Executor框架详解_线程池_02](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/14/22184616840739261684073926767ZzkXVL-resize,m_fixed,w_1184-20230514221846665.jpg)\n\n### 使用步骤\n\n1.**创建 Executor 实例**：\n\n根据需要选择合适的 Executor 实现类来创建 Executor 实例。常见的实现类有 `ThreadPoolExecutor`、`ScheduledThreadPoolExecutor` 等。可以使用它们的构造函数或者工厂方法来创建 Executor 实例。\n\n```java\n// 创建ThreadPoolExecutor示例。 ThreadPoolExecutor可以替换为其父类ExecutorService 或 Executor\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n    2,  // 核心线程数\n    5,  // 最大线程数\n    1,  // 空闲线程存活时间\n    TimeUnit.SECONDS,  // 时间单位\n    new LinkedBlockingQueue<>() // 任务队列\n);\n\n\n// 创建 ScheduledExecutorService 实例\nScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n```\n\n2.**创建任务**：创建待执行的任务，可以实现 `Runnable` 接口或 `Callable` 接口，具体根据业务需求来定义任务的逻辑。\n\n```java\n// Runnable 无返回值\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Hello\")\n    }\n}\n\n// Callable 有返回值\nclass callableTest implements Callable<String >{\n  \t@Override\n  \tpublic String call() {\n      return \"Hello\";\n   }\n}\n```\n\n3.**提交任务**：使用 Executor 实例的 `execute(Runnable)` 方法或 `submit(Callable)` 方法将任务提交给 Executor 执行。`execute` 方法适用于不需要获取任务执行结果的情况，而 `submit` 方法适用于需要获取任务执行结果的情况。\n\n```java\n// 提交Runnable任务\nexecutor.execute(runnaleTask);\n\n// 提交Callable任务\nexecutor.submit(callableTask);\n```\n\n4.**等待任务执行完成**（可选）：根据需要，可以使用 `Future` 对象来等待任务执行完成并获取任务的执行结果。`submit` 方法返回一个 `Future` 对象，可以使用它的 `get()` 方法来阻塞等待任务执行完成并获取结果。\n\n```java\n// 提交任务给 Executor 执行，并获取 Future 对象\nFuture<String> future = executor.submit(callableTask);\n\n// 等待任务执行完成并获取结果\ntry {\n    String result = future.get();\t\t// get会阻塞等人任务完成\n    System.out.println(\"Task Result: \" + result);\n} catch (Exception e) {\n    e.printStackTrace();\n}\n```\n\n5.**关闭 Executor**：在不再需要执行新任务时，需要显式地关闭 Executor。可以调用 Executor 的 `shutdown()` 方法来平滑地关闭 Executor，它会等待所有已提交的任务执行完成后再关闭 Executor。也可以调用 `shutdownNow()` 方法来立即关闭 Executor，它会尝试中断正在执行的任务并返回尚未执行的任务列表。\n\n```java\n// 方式1\nexecutor.shutdown();\n\n// 方式2\nexecutor.shutdownNow();\n```\n\n### Executor框架成员\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/15/131438168412767816841276789411OIKxd-20180318215737261.jpeg\" alt=\"img\" style=\"zoom: 67%;\" />\n\n#### ThreadPoolExecutor\n\n##### FixedThreadPool\n\n作用 & 场景\n\n```\n创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这 些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线 程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中 等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线 程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池 中的线程将一直存在。\n\n适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严 格限制的场景\n```\n\n特点\n\n```\n特征：\n• 线程池中的线程处于一定的量，可以很好的控制线程的并发量\n• 线程可以重复被使用，在显示关闭之前，都将一直存在\n• 超出一定量的线程被提交时候需在队列中等待\n```\n\n创建方式\n\n```java\nExecutorService executor = Executors.newFixedThreadPool(nThreads);\n```\n\n源码\n\n```java\npublic static ExecutorService newFixedThreadPool() { \n    return new ThreadPoolExecutor(\n      10, \n      10, \n      0L, \n      TimeUnit.SECONDS, \n      new LinkedBlockingQueue<>(), \n      Executors.defaultThreadFactory(), \n      new ThreadPoolExecutor.AbortPolicy()\n    );\n}\n```\n\n##### SingleThreadExecutor\n\n作用 & 场景\n\n```\n创建一个使用单个worker线程的 Executor，以无界队列方式来运行该 线程。\n（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程， 那么如果需要，一个新线程将代替它执行后续的任务）。\n可保证顺序地执行各 个任务，并且在任意给定的时间不会有多个线程是活动的。\n与其他等效的 newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。\n\n适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个 线程的场景\n```\n\n特点\n\n```\n线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此 执行\n```\n\n创建方式\n\n```java\nExecutorService executor = Executors.newSingleThreadExecutor();\n```\n\n源码\n\n```java\npublic static ExecutorService newSingleThreadExecutor() { \n    return new ThreadPoolExecutor(\n        1, \n        1, \n        0L, \n        TimeUnit.SECONDS, \n        new LinkedBlockingQueue<>(), \n        Executors.defaultThreadFactory(), \n        new ThreadPoolExecutor.AbortPolicy()\n    );\n}\n```\n\n\n\n##### CachedThreadPool\n\n作用 & 场景\n\n```\n创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空 闲线程，若无可回收，则新建线程\n\n适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景\n```\n\n特点\n\n```\n线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）\n线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）\n当线程池中，没有可用线程，会重新创建一个线程\n```\n\n创建方式\n\n```\nExecutorService executor = Executors.newCachedThreadPool();\n```\n\n源码\n\n```java\npublic static ExecutorService newCachedThreadPool(){ \n  return new ThreadPoolExecutor(\n    0, \n    Integer.MAX_VALUE, \n    60L, \n    TimeUnit.SECONDS, \n    new SynchronousQueue<>(), \n    Executors.defaultThreadFactory(), \n    new ThreadPoolExecutor.AbortPolicy()\n  );\n}\n```\n\n\n\n#### ScheduledThreadPoolExecutor\n\n##### ScheduledThreadPoolExecutor\n\n##### SingleThreadScheduledExecutor\n\n\n\n#### Future接口 & FutureTask类\n\n\n\n#### Runnable接口和Callable接口\n\n\n\n#### Executors工厂类\n\n```\n提供了常见配置线程池的方法，因为ThreadPoolExecutor的参数众多且意义重大，为了避免配置出错，才有了Executors工厂类。\n```\n\n","timestamp":1691335064136},{"name":"001-JUC.md","path":"001-JAVA/011-JUC/001-JUC.md","content":"# JUC高并发编程\n\n## 1 JUC概述\n\n## 2 LOCK接口\n\n### 什么是Lock接口\n\n```java\npublic interface Lock {\n    void lock(); \n    void lockInterruptibly() throws InterruptedException; \n    boolean tryLock(); \n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException; \n    void unlock(); Condition newCondition();\n}\n```\n\n```\nLock是Java中提供的一个接口，用于实现【线程同步机制】，它可以替代Synchronized关键字。\nLock接口提供了比Synchronized更灵活、更强大的线程同步功能，可以用于解决多线程中的资源竞争和死锁等问题。\nLock接口的实现类有很多种，其中最常用的是ReentrantLock。\n\nLock接口提供了以下主要方法：\n- lock()：获取锁，如果锁已经被其他线程获取，则当前线程进入等待状态。\n- unlock()：释放锁，如果当前线程持有锁，则释放锁并唤醒等待的线程。\n- tryLock()：尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true，否则立即返回false。\n- tryLock(long time, TimeUnit unit)：尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true，否则等待指定时间后返回false。\n- newCondition()：创建一个Condition对象，用于实现等待/通知机制。\n\n需要注意的是，在使用Lock接口时，需要在finally代码块中释放锁，以确保锁一定会被释放，避免死锁的发生。\n```\n\n#### 什么是线程同步机制？\n\n```\n- 是什么？\n线程同步机制是多线程编程中常用的一种机制，用于控制多个线程对共享资源的访问。\n\n- 为什么？\n在多线程环境中，多个线程同时访问共享资源可能会导致竞争条件和数据不一致等问题，因此需要使用线程同步机制来避免这些问题的发生\n\n- 怎么样？\n1.synchronized\n2.Lock接口\n\n- 基本原理\n线程同步机制的基本原理是在共享资源的访问前获取锁，只有获取锁的线程才能访问共享资源，其他线程需要等待锁的释放。\n在共享资源访问完成后，释放锁，让其他线程可以继续访问共享资源。这样就保证了共享资源在任何时刻只能被一个线程访问，避免了竞争条件和数据不一致等问题的发生。\n\n- 使用时注意的问题\n1.使用线程同步机制时，应该避免死锁、饥饿等问题的发生，以确保程序的正常运行\n2.同时，在使用synchronized关键字时，应该尽量减小同步块的范围，以提高程序的性能。\n3.在使用Lock接口时，需要在finally代码块中释放锁，以确保锁一定会被释放，避免死锁的发生。\n```\n\n##### 在使用synchronized关键字时，为什么要减小同步块的范围？\n\n```\n1.提高性能\n范围越大，需要等待获取锁的线程越多，导致在获取锁的过程中需要等待其他线程释放锁，而其他线程释放锁的时间也会比较长，这就会造成线程的等待时间过长，降低程序的运行效率。\n2.避免死锁\n不同的线程可能会竞争多个锁，释放锁的时间也会比较长，导致相互等待，形成死锁。\n\n因此，为了避免以上问题的发生，应该尽量减小同步块的范围，只在必要的地方进行同步，这样可以提高程序的性能，同时也可以降低出现死锁等问题的概率。\n```\n\n##### 为什么使用lock接口需要在finally代码块中释放锁\n\n```\n- 为什么？\n在使用Lock接口进行线程同步时，需要手动获取和释放锁，这是两个独立的操作，如果在获取锁之后发生异常，就有可能导致锁没有被释放，从而导致死锁等问题的发生。\n- 怎么样？\n因此，将释放锁的操作放在finally代码块中，这样可以确保在任何情况下都会释放锁，避免死锁等问题的发生。\n```\n\n### Lock和Synchronized的区别？\n\n```\n- 是什么 & 作用\nLock和Synchronized都是Java中用于实现线程同步的机制，它们的目的是为了避免线程间的竞争条件和数据不一致等问题。它们的区别如下：\n\n- 区别\n1.锁的获取方式：\n\tSynchronized是在进入同步代码块或同步方法时，自动获取锁，退出同步代码块或方法时自动释放锁；而Lock需要手动获取锁，并且必须手动释放锁。\n2.锁的粒度：\n\tSynchronized只能对整个方法或代码块进行加锁，而Lock可以对代码块进行更细粒度的控制。\n3.可中断性：\n\t在获取锁时，Synchronized是不可中断的，即使该线程在等待锁的过程中被中断，也不会释放锁；而Lock可以根据需要设置锁的可中断性。\n4.公平锁：\n\tSynchronized是非公平锁，不保证等待时间最长的线程最先获取锁；而Lock可以通过参数指定为公平锁或非公平锁。\n5.性能：\n\t相比较而言，Lock的性能比Synchronized好，在高并发的情况下，Lock的吞吐量比Synchronized更高。\n\n需要注意的是，Lock是在JDK 5中引入的，而Synchronized是Java早期就提供的同步机制。由于Lock相比Synchronized更灵活和高效，因此在实际开发中，使用Lock的场景会更多。\n```\n\n### Synchronized实现卖票例子\n\n```java\npackage com.atguigu.sync;\n\n//第一步  创建资源类，定义属性和和操作方法\nclass Ticket {\n    //票数\n    private int number = 10;\n    //操作方法：卖票\n    public synchronized void sale() {\n        //判断：是否有票\n        if(number > 0) {\n            System.out.println(Thread.currentThread().getName()+\" : 卖出：\"+(number--)+\" 剩下：\"+number);\n        }\n    }\n}\n\npublic class SaleTicket {\n    //第二步 创建多个线程，调用资源类的操作方法\n    public static void main(String[] args) {\n        //创建Ticket对象\n        Ticket ticket = new Ticket();\n        //创建三个线程\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                //调用卖票方法\n                for (int i = 0; i < 40; i++) {\n                    ticket.sale();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                //调用卖票方法\n                for (int i = 0; i < 40; i++) {\n                    ticket.sale();\n                }\n            }\n        },\"BB\").start();\n\n        // lambda表达式写法\n        new Thread(() -> {\n            //调用卖票方法\n            for (int i = 0; i < 40; i++) {\n                ticket.sale();\n            }\n        },\"CC\").start();\n    }\n}\n\n// 输出\nAA : 卖出：30 剩下：29\n...\nAA : 卖出：7 剩下：6\nBB : 卖出：6 剩下：5\n...\nBB : 卖出：1 剩下：0\n```\n\n### Lock实现卖票例子\n\n```java\n\n//第一步  创建资源类，定义属性和和操作方法\nclass LTicket {\n    //票数量\n    private int number = 30;\n\n    //创建可重入锁\n    private final ReentrantLock lock = new ReentrantLock(true);\n    //卖票方法\n    public void sale() {\n        //上锁\n        lock.lock();\n        try {\n            //判断是否有票\n            if(number > 0) {\n                System.out.println(Thread.currentThread().getName()+\" ：卖出\"+(number--)+\" 剩余：\"+number);\n            }\n        } finally {\n            //解锁\n            lock.unlock();\n        }\n    }\n}\n\npublic class LSaleTicket {\n    //第二步 创建多个线程，调用资源类的操作方法\n    //创建三个线程\n    public static void main(String[] args) {\n\n        LTicket ticket = new LTicket();\n\n        new Thread(()-> {\n            for (int i = 0; i < 40; i++) {\n                ticket.sale();\n            }\n        },\"AA\").start();\n\n        new Thread(()-> {\n            for (int i = 0; i < 40; i++) {\n                ticket.sale();\n            }\n        },\"BB\").start();\n\n        new Thread(()-> {\n            for (int i = 0; i < 40; i++) {\n                ticket.sale();\n            }\n        },\"CC\").start();\n    }\n}\n\n```\n\n\n\n### 什么是可重入锁\n\n```\n- 是什么？\n可重入锁是指同一个线程在持有某个锁的情况下，可以继续获取该锁而不会出现死锁的情况\n\n- synchronized关键字实现原理\n每个对象都有一个监视器锁（monitor），线程进入同步块时获取该对象的监视器锁，并在同步块结束时释放该锁，当一个线程在持有该锁的情况下再次进入同步块时，会自动获取该锁，而不会被阻塞。\n\n- ReentrantLock重入锁实现原理\n它使用一个计数器来记录线程获取锁的次数。当一个线程第一次获取锁时，计数器的值为1，当同一个线程再次获取锁时，计数器的值会递增，当线程退出同步块时，计数器的值递减，直到计数器的值为0时，锁被释放。这种机制保证了线程可以多次获取同一个锁而不会出现死锁的情况。\n```\n\n### 什么是ReentrantLock & 特点\n\n```\n- 是什么？\nReentrantLock是Java中实现Lock接口的一个类，它提供了与synchronized关键字类似的线程同步机制\n\n- 特点\n1.可重入性：\n\t与synchronized关键字一样，ReentrantLock支持可重入锁，即同一个线程可以多次获取同一个锁而不会死锁\n2.公平锁与非公平锁：\n\tReentrantLock提供了两种锁的实现方式，即公平锁和非公平锁。公平锁会按照线程的请求顺序来分配锁，而非公平锁则允许线程在竞争时插队，可能会导致某些线程长时间等待。\n3.条件变量：\n\tReentrantLock提供了Condition接口的实现类Condition，它可以将一个锁分为多个条件，使得线程可以在指定条件下等待和唤醒。这使得线程间的通信变得更加灵活。\n3.可中断性：\n\t与synchronized关键字不同，ReentrantLock提供了可中断锁的机制。即当一个线程等待获取锁时，可以通过中断等待的线程来结束等待。\n\nReentrantLock相对于synchronized关键字来说，具有更强的灵活性和可定制性，但需要手动获取和释放锁，使用时也需要注意避免死锁、饥饿等问题的发生。\n```\n\n### ReentrantLock和synchronized例子\n\n```java\n// 可重入锁\npublic class SyncLockDemo {\n\n    public synchronized void add() {\n        add();\n    }\n\n    public static void main(String[] args) {\n        //Lock演示可重入锁\n        Lock lock = new ReentrantLock();\n        //创建线程\n        new Thread(()->{\n            try {\n                //上锁\n                lock.lock();\n                System.out.println(Thread.currentThread().getName()+\" 外层\");\n\n                try {\n                    //上锁\n                    lock.lock();\n                    System.out.println(Thread.currentThread().getName()+\" 内层\");\n                }finally {\n                    //释放锁\n                    lock.unlock();\n                }\n            }finally {\n                //释放做\n                lock.unlock();\n            }\n        },\"t1\").start();\n\n        //创建新线程\n        new Thread(()->{\n            lock.lock();\n            System.out.println(\"aaaa\");\n            lock.unlock();\n        },\"aa\").start();\n\n       // new SyncLockDemo().add();\n       // synchronized\n       Object o = new Object();\n       new Thread(()->{\n           synchronized(o) {\n               System.out.println(Thread.currentThread().getName()+\" 外层\");\n\n               synchronized (o) {\n                   System.out.println(Thread.currentThread().getName()+\" 中层\");\n\n                   synchronized (o) {\n                       System.out.println(Thread.currentThread().getName()+\" 内层\");\n                   }\n               }\n           }\n\n       },\"t1\").start();\n    }\n}\n\n// 输出\nt1 外层\nt1 内层\naaaa\nt1 外层\nt1 中层\nt1 内层\n```\n\n### 创建线程的多种方式\n\n```\n1.继承Tread类\n2.实现Runnable接口\n3.实现Callable接口\n4.使用线程池\n```\n\n#### 继承Tread类\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread();\n        t.start(); // 启动新线程\n    }\n}\n```\n\n执行指定代码\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new MyThread();\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n\n[参考](https://www.liaoxuefeng.com/wiki/1252599548343744/1306580710588449)\n\n#### 实现Runnable接口\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n简写\n```java\nnew Thread(new Runnable() {\n  \t@Override\n  \tpublic void run() {\n    \t//调用卖票方法\n    \tfor (int i = 0; i < 40; i++) {\n      \tticket.sale();\n    \t}\n  \t}\n},\"Thread Name\").start();\n```\n\n使用Java8的lambda语法简写\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> {\n            System.out.println(\"start new thread!\");\n        });\n        t.start(); // 启动新线程\n    }\n}\n```\n\n[参考](https://www.liaoxuefeng.com/wiki/1252599548343744/1306580710588449)\n\n## \n\n\n\n## 3 线程间通信\n\n线程间通信的模型有两种：共享内存和消息传递\n\n**线程间的通信具体步骤：**\n\n1.  创建资源类，在资源类中创建属性和操作方法\n\n2.  在资源类操作方法：判断、操作、通知\n\n3.  创建多个线程，调用资源类的操作方法\n\n4.  防止虚拟唤醒问题\n\n    \n\n**案例**\n\n假设有两个线程，该线程在执行过程中，判断值（不是该值等待，让其他线程抢），操作值，通知另外一个线程的调度\n\n通过使用两个线程对0这个值操作，一个线程加1，一个线程减1，交替实现多次\n\n#### synchronized实现\n\n```java\n//第一步 创建资源类，定义属性和操作方法\nclass Share {\n    //初始值\n    private int number = 0;\n    //+1的方法\n    public synchronized void incr() throws InterruptedException {\n        //第二步 判断 干活 通知\n       // 错误写法：\n       // if(number != 0) { //判断number值是否是0，如果不是0，等待\t\t注意：此处写法会导致虚假换新问题，用while\n            // this.wait(); //在哪里睡，就在哪里醒\n        // }\n      \n        // 正确写法\n      \twhile(number != 0) { //判断number值是否是0，如果不是0，等待\n            this.wait(); //在哪里睡，就在哪里醒\n        }\n        //如果number值是0，就+1操作\n        number++;\n        System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n        //通知其他线程\n        this.notifyAll();\n    }\n\n    //-1的方法\n    public synchronized void decr() throws InterruptedException {\n        //判断\n        if(number != 1) {\n            this.wait();\n        }\n        //干活\n        number--;\n        System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n        //通知其他线程\n        this.notifyAll();\n    }\n}\n\npublic class ThreadDemo1 {\n    //第三步 创建多个线程，调用资源类的操作方法\n    public static void main(String[] args) {\n        Share share = new Share();\n        //创建线程\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr(); //+1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr(); //-1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n    }\n}\n\n// 结果\nAA :: 1\nBB :: 0\nAA :: 1\nBB :: 0\n...\n```\n\n问题：线程数多了之后，使用if来判断标志位会出现虚假唤醒问题\n\n```java\n// 在上述代码的基础上再添加线程\nnew Thread(()->{\n    for (int i = 1; i <=10; i++) {\n        try {\n            share.incr(); //+1\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n},\"CC\").start();\n\nnew Thread(()->{\n    for (int i = 1; i <=10; i++) {\n        try {\n            share.decr(); //-1\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n},\"DD\").start();\n\n// 结果\nAA :: 1\nBB :: 0\nAA :: 1\nBB :: 0\n...\nCC :: 1\nBB :: 0\nCC :: 1\nBB :: 0\nDD :: -1\n```\n\n主要是虚拟唤醒导致：如果一个线程执行完毕后，通知其他线程，该线程又进入等待睡眠，可能会因为某些原因被唤醒后，if结构的语句就不会判断了，一直往下执行，所以需要将if换成while结构，每次都判断。因为wait在哪里睡眠就在哪里被唤醒，结果被某个异常唤醒了后回不去了，if结构不会在判断了，需要更改为while\n\n```java\nwhile(number != 0) { //判断number值是否是0，如果不是0，等待\n    this.wait(); //在哪里睡，就在哪里醒\n}\n```\n\n#### lock实现\n\n```java\npackage com.atguigu.lock;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n//第一步 创建资源类，定义属性和操作方法\nclass Share {\n    private int number = 0;\n\n    //创建Lock\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    //+1\n    public void incr() throws InterruptedException {\n        //上锁\n        lock.lock();\n        try {\n            //判断\n            while (number != 0) {\n                condition.await();\n            }\n            //干活\n            number++;\n            System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n            //通知\n            condition.signalAll();\n        }finally {\n            //解锁\n            lock.unlock();\n        }\n    }\n\n    //-1\n    public void decr() throws InterruptedException {\n        lock.lock();\n        try {\n            while(number != 1) {\n                condition.await();\n            }\n            number--;\n            System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n            condition.signalAll();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ThreadDemo2 {\n\n    public static void main(String[] args) {\n        Share share = new Share();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"CC\").start();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"DD\").start();\n    }\n\n}\n\n```\n\n\n\n## 4 线程间定制化通信\n\n**所谓定制化通信，需要让线程进行一定的顺序操作**\n\n**案列**：启动三个线程，按照如下要求：\nAA打印5此，BB打印10次，CC打印15次，一共进行10轮\n\n**具体思路**：\n每个线程添加一个标志位，是该标志位则执行操作，并且修改为下一个标志位，通知下一个标志位的线程\n\n```java\n//第一步 创建资源类\nclass ShareResource {\n    //定义标志位\n    private int flag = 1;  // 1 AA     2 BB     3 CC\n\n    //创建Lock锁\n    private Lock lock = new ReentrantLock();\n\n    //创建三个condition\n    private Condition c1 = lock.newCondition();\n    private Condition c2 = lock.newCondition();\n    private Condition c3 = lock.newCondition();\n\n    //打印5次，参数第几轮\n    public void print5(int loop) throws InterruptedException {\n        //上锁\n        lock.lock();\n        try {\n            //判断\n            while(flag != 1) {\n                //等待\n                c1.await();\n            }\n            //干活\n            for (int i = 1; i <=5; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //通知\n            flag = 2; //修改标志位 2\n            c2.signal(); //通知BB线程\n        }finally {\n            //释放锁\n            lock.unlock();\n        }\n    }\n\n    //打印10次，参数第几轮\n    public void print10(int loop) throws InterruptedException {\n        lock.lock();\n        try {\n            while(flag != 2) {\n                c2.await();\n            }\n            for (int i = 1; i <=10; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //修改标志位\n            flag = 3;\n            //通知CC线程\n            c3.signal();\n        }finally {\n            lock.unlock();\n        }\n    }\n\n    //打印15次，参数第几轮\n    public void print15(int loop) throws InterruptedException {\n        lock.lock();\n        try {\n            while(flag != 3) {\n                c3.await();\n            }\n            for (int i = 1; i <=15; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //修改标志位\n            flag = 1;\n            //通知AA线程\n            c1.signal();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ThreadDemo3 {\n    public static void main(String[] args) {\n        ShareResource shareResource = new ShareResource();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print5(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print10(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print15(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"CC\").start();\n    }\n}\n\n```\n\n\n\n## 5 集合的线程安全\n\n向集合中边读边写，导致java.util.ConcurrentModificationException异常\n\n```java\nList<String> list = new ArrayList<>();\n\nfor (int i = 0; i <30; i++) {\n    new Thread(()->{\n        //向集合添加内容\n       list.add(UUID.randomUUID().toString().substring(0,8));\n        //从集合获取内容\n        System.out.println(list);\n    },String.valueOf(i)).start();\n}\n\n```\n\n原因\n\n```\nboolean add(E e); \t没有synchronized声明，是线程非安全的\n```\n\n### 如何解决 ArrayList 类型的线程安全问题?\n\n#### 方法一：Vector\n\n#### 方法二：Collections\n\nCollections类中的很多方法都是static静态\n其中有一个方法是返回指定列表支持的同步（线程安全的）列表为`synchronizedList(List <T> list)`\n\n```java\nList<String> list = Collections.synchronizedList(new ArrayList<>());\n```\n\n\n\n#### 方法三：CopyOnWriteArrayList\n\n##### 实现\n\n```java\npublic class NotSafeDemo {\n\n/** 多个线程同时对集合进行修改 **/ \n  public static void main(String[] args) { \n    List list = new CopyOnWriteArrayList();\n    for (int i = 0; i < 100; i++) { \n      new Thread(() ->{ \n        list.add(UUID.randomUUID().toString()); \n        System.out.println(list); \n      }, \"线程\" + i).start(); \n    }\n\t}\n}\n```\n\n##### CopyOnWriteArrayList为什么能解决线程安全问题\n\n```\n实现原理：写时复制技术\n- 写过程：\n当需要对CopyOnWriteArrayList进行修改时，它会先将原始数组进行复制，然后再进行修改操作，最后将修改后的数组替换原始数组，这样就保证了修改操作的线程安全性。\n\n- 读过程\n在读取CopyOnWriteArrayList中的元素时，不需要加锁，因为读取时不会对原始数组进行修改，而是返回一个快照副本，多个线程同时进行读操作时不会出现线程安全问题。\n```\n\n##### CopyOnWriteArrayList缺点 & 适用场景\n\n```\n底层实现采用了复制数组的方式来保证线程安全，因此每次修改操作都需要对原始数组进行复制，这会带来一定的性能开销。\n【适用】于【读多写少】的场景，在需要高并发读取的场景中表现较好。\n【不适用】于【实时性】的场景，不能保证数据的实时一致性\n```\n\n\n\n### 如何解决 HashSet 类型的线程安全问题?\n\n#### 方法：CopyOnWriteArraySet\n\n```java\njava Set<String> set = new HashSet<>();\t\t\t\t\t  // 非安全\nSet<String> set = new CopyOnWriteArraySet<>();\t\t// 安全\n```\n\n\n\n### 如何解决 HashMap 类型的线程安全问题?\n\n```java\nMap<String,String> map = new HashMap<>();\t\t\t\t\t\t\t// 非安全\nMap<String,String> map = new ConcurrentHashMap<>();\t\t// 安全\n```\n\n#### TODO： ConcurrentHashMap实现原理\n\n\n\n\n\n## 6 多线程锁\n\n### 公平锁和非公平锁\n\n-   **公平锁**：效率相对低\n-   **非公平锁**：效率高，但是线程容易饿死\n\n实现\n\n```java\n// 公平锁\nReentrantLock lock = new ReentrantLock(true);\n// 非公平锁\nReentrantLock lock = new ReentrantLock(false);\n```\n\n\n\n### 可重入锁\n\nsynchronized和lock都是可重入锁\n\n-   sychronized是隐式锁，不用手工上锁与解锁，而lock为显示锁，需要手工上锁与解锁\n-   可重入锁也叫递归锁\n\n而且有了可重入锁之后，破解第一把之后就可以一直进入到内层结构\n\n\n\n### 死锁\n\n**产生死锁的原因：**\n\n1.  系统资源不足\n2.  系统资源分配不当\n3.  进程运行顺序不当\n\n\n\n## Callable接口\n\n### 有Runnable为什么还要callable？\n\n```\nRunnable 缺少的一项功能是，当线程终止时（即 run（）完成时），我们无法使线程返回结果。为了支持此功能，Java 中提供了 Callable 接口\n```\n\n\n\n### **比较Runnable接口和Callable接口**\n\n```java\n//实现Runnable接口\nclass MyThread1 implements Runnable {\n    @Override\n    public void run() {\n\n    }\n}\n\n//实现Callable接口\nclass MyThread2 implements Callable {\n\n    @Override\n    public Integer call() throws Exception {\n        return 200;\n    }\n}\n\n```\n\n","timestamp":1691335064136},{"name":"02-Redis.md","path":"001-JAVA/02-Redis.md","content":"[Redis6视频笔记](https://zhangc233.github.io/2021/05/02/Redis/#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB)\n\n[javaguide](https://javaguide.cn/database/redis/redis-questions-01.html#redis-除了做缓存-还能做什么)\n\nhttps://www.yuque.com/snailclimb/mf2z3k/ikf0l2\n\nc语言中文网http://c.biancheng.net/redis/slaveof.html\n\n小林coding：https://xiaolincoding.com/redis/\n\n## Redis基础\n\n### 什么是 Redis？\n\n```\n是一个开源的高性能键值存储数据库。\n\n特点：\n（1）高性能：Redis数据存储在内存中，因此具有非常快速的读写性能。\n（2）数据结构丰富：Redis支持多种数据结构，可以满足不同类型的应用需求。\n（3）支持持久化：Redis提供了持久化机制，可以将数据持久化到磁盘上，以便在重启后恢复数据。\n（4）集群：Redis可以通过主从复制和分片等机制进行数据分布和高可用性的部署。\n（5）支持事务：Redis支持简单的事务功能，可以保证一系列操作的原子性。\n（6）支持发布订阅：Redis支持发布订阅模式，可以实现消息的发布和订阅机制。\n\nRedis常被用作缓存、消息队列、分布式锁等场景下的数据存储和处理。它被广泛应用于各种Web应用、移动应用和分布式系统中，以提供高性能的数据存储和访问能力。\n\nchatgpt\n```\n\n### 优缺点\n\n```\n（1）优点：同特点\n（2）缺点：\n\t\t- 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。\n\t\t- 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。\n```\n\n### Redis 为什么这么快？ TODO\n\n```\n（1）内存存储：数据存储在内存中，读写速度快\n（2）IO多路复用： Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用\n（3）Redis 内置了多种优化过后的数据结构实现，性能非常高。\n\nhttps://javaguide.cn/database/redis/redis-questions-01.html#redis-为什么这么快\nRedis 为什么这么快，你知道 I/O 多路复用吗？：https://learnku.com/articles/73927\n```\n\n### 为什么要用 Redis/为什么要用缓存？\n\n```\n缓存的基本思想：\n空间换时间，常见的还有索引、数据库表的冗余字段、CDN\n\n（1）高性能。\n\t直接访问数据库，从磁盘中读取，速度较慢。redis基于内存，读写速度快。将高频且不经常改变的数据直接缓存，下次就可以直接从内存中读取，速度快\n（2）高并发\n\tredis能够承受的请求远大于直接访问mysql。单台设备的redis的QPS是mysql的10倍，redis单机的qps能轻松破10w，而mysql单机的qps很难破1w\n\nQPS（Query Per Second）：每秒钟处理完请求的次数\nhttps://javaguide.cn/database/redis/redis-questions-01.html#为什么要用-redis-为什么要用缓存\n```\n\n### 既然Redis那么快，为什么不用它做主数据库，只用它做缓存？\n\n```\n虽然Redis非常快，但它也有一些局限性，不能完全替代主数据库。有以下原因：\n（1）基于内存：内存昂贵，不适合做海量数据的存取\n（2）事务处理：Redis只支持简单的事务处理，对于复杂的事务无能为力，比如跨多个键的事务处理。\n（3）数据持久化：Redis是内存数据库，数据存储在内存中，如果服务器崩溃或断电，数据可能丢失。虽然Redis提供了数据持久化机制，但有一些限制。\n（4）数据处理：Redis只支持一些简单的数据结构，比如字符串、列表、哈希表等。如果需要处理复杂的数据结构，比如关系型数据库中的表，那么Redis可能不是一个好的选择。\n（5）数据安全：Redis没有提供像主数据库那样的安全机制，比如用户认证、访问控制等等。\n\n因此，虽然Redis非常快，但它还有一些限制，不能完全替代主数据库。所以，使用Redis作为缓存是一种很好的方式，可以提高应用程序的性能，并减少数据库的负载。\n```\n\n### Memcached和Redis的区别？\n\n```\n（1）速度：Redis 的速度比 Memcached 快很多。\n（2）数据结构：MemCached 数据结构单一，仅用来缓存数据，而 Redis 支持多种数据类型。\n（3）持久化：MemCached 不支持数据持久化，重启后数据会消失。Redis 支持数据持久化。\n（4）集群：Redis 提供主从同步机制和 cluster 集群部署能力，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。\n（5）Redis 使用单线程的多路 IO 复用模型，Memcached使用多线程的非阻塞 IO 模型。（Redis6.0引入了多线程IO，用来处理网络数据的读写和协议解析，但是命令的执行仍然是单线程）\n（6）value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。\n\nhttps://mp.weixin.qq.com/s/CiFSsOx_g9g-0PUGXDuvcQ\n```\n\n\n\n\n\n### 缓存的分类\n\n```\n（1）本地缓存\n（2）分布式缓存\n```\n\n#### 什么是本地缓存\n\n```\n本地缓存就是将数据暂时存在应用程序的本地内存中，最大的优点就是速度非常快，不需要额外的网络开销\n缺点就是消耗一定的内存空间、可能会导致数据一致性问题\n```\n\n#### 本地缓存实现方案\n\n```\n（1）JDK自带的HashMap、ConcurrentHashMap：只提供了缓存功能，没有过期时间、淘汰机制等\n（2）Ehcache、Guava cache、spring cache。\n\t\t- Ehcache可以嵌入到hibernate和mybatis作为多级缓存，并且可以将缓存的数据持久化到本地磁盘\n\t\t- Guava cache提供api方便使用\n\t\t- spring cache：提供注解方式，代码干净，但容易出现缓存穿透、内存溢出等问题\n（3）Caffeine。比Guava更方面性能更优秀\n```\n\n#### 本地缓存优劣？\n\n```\n优势：低依赖、轻量、简单、成本低\n劣势：\n\t（1）与应用耦合，对分布式架构不友好。如同一个服务部署在多台机器，各服务之间的缓存无法共享。\n\t（2）内存受限：缓存容量受服务部署所在机器限制明显。当前系统服务所耗费的内存多，那本地缓存使用的容量就少\n```\n\n#### 什么是分布式缓存\n\n```\n是一种在分布式系统中使用的缓存技术，它将缓存数据分布在多个节点上，整体对外提供统一的访问接口，可以提高系统的性能、拓展性和可用性。\n```\n\n#### 分布式缓存优势\n\n```\n（1）高性能：分布式缓存通常使用高速的内存存储，能够快速响应数据请求，提供低延迟的数据访问。\n（2）可拓展性：数据分布在多个节点上，可以通过添加节点的方式实现水平拓展\n（3）高可用：通过复制和备份，即使某个节点发生故障，仍然可以从其他节点获取数据\n```\n\n#### 分布式缓存存在的问题\n\n```\n（1）系统复杂性增加：需要维护数据一致性、保证缓存服务的高可用\n（2）成本增加：内存成本贵\n```\n\n#### 分布式缓存方案\n\n```\n（1）Memcached\n（2）Redis\n```\n\n#### 多级缓存\n\n```\n本地缓存（第一级） + 分布式缓存（第二级），是最常用的多级缓存方式\n读取缓存时先到本地缓存中读，读不到再二级缓存。这样可以降低二级缓存的压力，如果二级缓存也没有，则去查数据库，\n查询成功后将数据写入一级、二级缓存中\n```\n\n#### 用了分布式缓存，为什么还要本地缓存？\n\n```\n本地缓存和分布式缓存都属于缓存，但本地缓存的速度远大于分布式缓存，因为不需要额外的网络开销\n一般情况下不建议使用，需要维护一级缓存 和 二级缓存的一致性\n\n适合多级缓存的场景\n（1）缓存的数据不会频繁修改，比较稳定\n（2）数据访问量特别大，比如秒杀场景\n\nhttps://www.yuque.com/snailclimb/mf2z3k/fg8lgc\n```\n\n\n\n## Redis数据结构\n\n### redis的数据结构有哪些\n\n```\n五种基础数据结构：\n（1）字符串String：存储一个字符串值，可以是文本、整数、或二进制数\n（2）哈希Hash：适用于存储对象的多个属性\n（3）列表List：按照插入顺序存储一组有序值，可以在列表的两端进行元素的插入、删除\n（4）集合Set：存储一组唯一的无序元素，支持集合的交集、并集、差集等操作\n（5）有序集合ZSet：在集合的基础上，添加一个分数score属性，根据这个分数进行排序，支持根据分数范围进行元素的检索和排名\n\n三种特殊结构：\n（1）位图（Bitmap 2.2新增）\n（2）HyperLogLogs（基数统计 2.8新增）：\n（3）地理空间索引（Geospatial 3.2新增）：存储地理位置信息的数据结构，支持地理位置的存储、距离计算和范围查询。\n（4）Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。\n\nhttps://javaguide.cn/database/redis/redis-data-structures-01.html\nhttps://javaguide.cn/database/redis/redis-data-structures-02.html\n```\n\n### 数据结构的应用场景\n\n```\nString 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。\nHash 类型：缓存对象、购物车等。\nSet 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。\nZset 类型：排序场景，比如排行榜、电话和姓名排序等。\nBitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；\nHyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；\nGEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；\n```\n\n### 底层实现 TODO\n\n```\nhttps://xiaolincoding.com/redis/data_struct/data_struct.html\n```\n\n#### String\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/03/15185116910471311691047131521d5hULY-sds.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n```\nfree:还剩多少空间\nlen:字符串长度\nbuf:存放的字符数组\n\nredis使用动态字符串来表示字符串。动态字符串是一种可以自动调整长度的字符串，根据实际存储的数据进行调整。这就使得字符串的修改（增、删等）操作非常高效，无需频繁的进行内存的申请和释放\n```\n\n#### List\n\n![image.png](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/03/1528441691047724169104772461971DUJt-af744bdbec6a4cb38a4cd218ce2eacb9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\n\n```\nredis3.2之前由「双向链表」或「压缩链表」实现\nredis3.2之后，由quicklist实现。quicklist是由压缩列表和双向链表组成的混合体，它将链表按段切分，每一段使用压缩列表来紧凑存储。多个压缩列表之间使用双向指针接起来\n\n默认的单个ziplist长度为8k字节\n```\n\n#### Hash\n\n```\n底层由「压缩列表」或「哈希表」实现\n- 如果哈希类型元素小于512个，所有值小于64字节，使用压缩列表\n- 否则使用哈希表\n\nredis7.0中，压缩列表数据结构已经废弃，交由listpack数据结构来实现\n```\n\n#### Set\n\n```\n底层由「哈希表」或「整数集合」来实现\n- 如果集合中的元素都是整数，且元素个数小于512，则使用整数集合\n- 否则使用哈希表\n```\n\n#### ZSet\n\n```\n由「压缩列表」或「跳表」实现\n- 如果有序集合元素小于128个，并且每个元素的值小于64字节，则使用压缩列表\n- 否则使用跳表\n\nredis7.0中，压缩列表数据结构已经废弃，交由listpack数据结构来实现\n```\n\n\n\n### SortedSet和List异同点？\n\n```\n相同点：\n（1）都是有序的；\n（2）都可以获得某个范围内的元素。\n\n不同点：\n（1）实现\n\t\t- 列表基于链表实现，获取两端元素速度快，访问中间元素速度慢；\n\t\t- 有序集合基于散列表和跳跃表实现，访问中间元素时间复杂度是OlogN；\n（3）列表不能简单的调整某个元素的位置，有序列表可以（更改元素的分数）；\n（4）有序集合更耗内存。\n```\n\n\n\n### String 还是 Hash 存储对象数据更好呢？\n\n```\nString存储的是序列化后的对象数据，存放的是整个对象。\nHash是单独存储对象的每个字段，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。\n\nString节省内存，约是Hash的一半\n如果对象中的某些字段需要经常变动，或者需要经常查询对象中的个别字段信息，Hash适合\n\n在绝大部分情况，我们建议使用 String 来存储对象数据即可\n```\n\n### 购物车信息用 String 还是 Hash 存储更好呢?\n\n```\n由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：\n\n用户 id 为 key\n商品 id 为 field，商品数量为 value\n```\n\n![Hash维护简单的购物车信息](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/02/10211516909428751690942875545HKxnFF-19015916893325191689332519632hGmU2k-hash-shopping-cart.png)\n\n那用户购物车信息的维护具体应该怎么操作呢？\n\n```\n\n用户添加商品就是往 Hash 里面增加新的 field 与 value；\n查询购物车信息就是遍历对应的 Hash；\n更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；\n删除商品就是删除 Hash 中对应的 field；\n清空购物车直接删除对应的 key 即可。\n\njavaGuide\n```\n\n### Set 的应用场景是什么？\n\n```\nRedis 中 Set 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet\n\n常见应用场景：\n（1）存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等等。\n（2）需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。\n（3）需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。\n```\n\n### 使用 Set 实现抽奖系统怎么做？\n\n```\n如果想要使用 Set 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：\nSADD key member1 member2 ...：向指定集合添加一个或多个元素。\nSPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\nSRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。\n```\n\n### 使用 Bitmap 统计活跃用户怎么做？\n\n```\nBitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。\n你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。\n\n如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。\nSETBIT 20210308 1 1\nSETBIT 20210308 2 1\nSETBIT 20210309 1 1\n```\n\n### 使用 HyperLogLog 统计页面 UV 怎么做？\n\n```\n\n```\n\n\n\n## Redis应用\n\n### [Redis的常用场景有哪些?](https://www.javalearn.cn/#/doc/Redis/面试题?id=_6-redis的常用场景有哪些)\n\n```\n（1）缓存\n（2）分布式锁\n（3）限流\n（4）消息队列\n（5）延时队列\n（6）分布式session\n（7）复杂业务场景：排行榜、计数器、点赞、关注\n\nhttps://javaguide.cn/database/redis/redis-questions-01.html#redis-除了做缓存-还能做什么\n```\n\n### Redis 可以做消息队列么？\n\n```\n可以做简单的消息队列，但不建议\n\n（1）功能有限：相对于专门的消息队列中间件，redis提供的消息队列功能相对简单。缺少一些高级特性，如消息持久化、消息顺序保证、消息重试机制\n（2）redis默认将数据存在内存中，如果故障或停机，可能会丢失数据\n（3）拓展性：redis在处理大量消息时，可能会收到性能限制。当消息数量增长时，redis的单线程模型可能会成为瓶颈，影响吞吐量。redis6之后引入多线程模型，即redis线程池，一定程度上可以缓解，但并没有完全并行化处理所有请求，仍然存在一些串行化操作，如数据结构的修改操作疼需要进行同步。\n\nchatgpt\n```\n\n###  如何基于 Redis 实现分布式锁？\n\n```\n\n```\n\n\n\n\n\n## Redis持久化机制\n\n### [Redis持久化机制？](https://www.javalearn.cn/#/doc/Redis/面试题?id=_8-redis持久化机制？)\n\n```\nredis提供了三种不同形式的持久化机制\n（1）RDB（Redis DataBase）：快照\n（2）AOF（Append Only File）：只追加文件\n（3）混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；\n```\n\n### RDB\n\n#### 是什么\n\n```\n是redis默认的持久化方式\n在指定的时间间隔内，将内存中的数据集快照以二进制的形式写入磁盘，恢复时将快照文件读到内存中\n```\n\n#### 优缺点\n\n```\n（1）优点：适合大规模的数据恢复，对数据的完整性和一致性要求不高\n（2）缺点：在一定间隔时间做一次备份，如果rdis意外down掉，会丢失最后一次快照后的所有修改\n```\n\n#### 备份是如何进行的\n\n```\nredis会单独创建fork一个子进程来持久化。首先将数据写入一个临时文件中，待持久化过程都结束了，再用这个文件替换上次持久化好的文件\n\nhttps://zhangc233.github.io/2021/05/02/Redis/#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB\n```\n\n#### RDB 创建快照时会阻塞主线程吗？\n\n```\nRedis 提供了两个命令来生成 RDB 快照文件：\nsave : 在主线程生成rdb文件，会阻塞 Redis 主线程；\nbgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。\n```\n\n#### RDB 在执行快照的时候，数据能修改吗？\n\n```\n可以。在执行bgsave过程中，运用了「写时复制技术」，redis仍然可以继续处理操作命令\n\n在执行bgsave过程中，会通过fork（）创建子进程创建快照。如果主进程执行写操作，被修改的数据会复制一份副本，然后bgsave子进程会把该副本数据写入RDB文件，在这个过程中，主线程仍然可以直接修改原来的数据\n```\n\n\n\n### AOF\n\n#### 是什么 / AOF 日志是如何实现的？\n\n```\n以日志的形式来记录每个写操作（增量保存），将redis执行过的所有数据更新指令记录下来（读操作不记录），追加到AOF文件中。redis启动之初会读取该文件逐一执行命令来进行数据恢复\n```\n\n#### 优缺点\n\n```\n（1）优点：\n\t\t- 备份机制更文件，丢失数据的概率更低\n（2）缺点\n\t\t- 比RDB更占空间\n\t\t- 恢复备份速度要慢\n\t\t- 每次读写都同步，会有一定的性能压力\n```\n\n#### AOF持久化流程 TODO\n\n```\n（1）命令追加：将所有写命令追加到AOF缓冲区中\n（2）通过write（）系统调用将aof缓冲区中的数据写到aof文件中，此时数据并没有写到磁盘中，而是拷贝到了内核缓冲区，等待内核将数据写入磁盘\n（3）根据写回策略，将数据写入硬盘中\n（4）文件重写（rewrite）：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的\n（5）重启加载（load）:当redis重启时，会重新加载AOF文件中的写操作恢复数据\n\n```\n\n#### 持久化策略 / AOF 写回策略有几种？\n\n![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/04/10593616911179761691117976340S2YpGq-98987d9417b2bab43087f45fc959d32a-20230309232253633.png)\n\n```\n（1）appendfsync always：始终同步，每次 Redis 的写入都会立刻记入日志；性能较差但数据完整性比较好。\n（2）appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。\n（3）appendfsync no：redis 不主动进行同步，把同步时机交给操作系统。\n```\n\n#### AOF 为什么是在执行完命令之后记录日志？\n\n```\n关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志\n\n为什么是在执行完命令之后记录日志呢？\n（1）避免额外的检查开销，AOF记录日志不会对命令进行语法检查；如果先写再执行，命令语法有错误就会把错误命令记录到aof中，恢复数据时就会出错\n（2）在命令执行完之后再记录，不会阻塞当前的命令执行。\n\n这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：\n（1）如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；\n（2）可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。\n\njavaguide\n```\n\n#### AOF 日志过大，会触发什么机制？\n\n```\n如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。\n\nRedis 为了避免 AOF 文件越写越大，提供了「 AOF 重写机制」，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。\n\n重写就是将多个键值对用一条命令记录\n```\n\n#### AOF 重写\n\n```\n当AOF变得太大时，redis会在后台的一个子进程中进行重写操作，避免对redis正常处理命令请求造成影响\nAOF重写期间，redis会维护一个「AOF重写缓冲区」，该缓冲区会在子进程创建新的AOF文件期间，记录服务器执行的所有写命令。\n当子进程创建完新的AOF文件后，服务器将重写缓冲区中的所有内容追加到新的AOF文件末尾。\n最后替换旧的AOF文件，完成重写\n\nhttps://javaguide.cn/database/redis/redis-persistence.html#aof-%E9%87%8D%E5%86%99%E4%BA%86%E8%A7%A3%E5%90%97\n```\n\n### AOF 和 RDB 同时开启，redis 听谁的？\n\n```\nAOF默认不开启，如果都开启，系统默认取AOF的数据\n```\n\n### AOF和RDB对比\n\n```\nRDB优势：\n（1）RDB文件存储的内容是经过压缩的二进制数据，保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。\n（2）使用RDB恢复数据，直接解析还原数据即可，非常快。而AOF需要一条一条执行，非常慢\n（3）AOF需要选择合适的刷盘策略，如果刷盘策略选择不当的话，会影响Redis的正常运行。并且，根据所使用的刷盘策略，AOF的速度可能会慢于RDB\n\nAOF优势：\n（1）更安全。RDB会丢掉整个快照，而AOF可能只丢失一条命令或一秒钟内的数据\n\nhttps://javaguide.cn/database/redis/redis-persistence.html#redis-4-0-%E5%AF%B9%E4%BA%8E%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96\n```\n\n### 如何选用\n\n```\n（1）对数据不敏感，选择RDB\n（2）不建议单独使用AOF，因为是不是创建一个RDB快照可以进行数据库备份、更快的重启以及解决AOF引擎错误\n（3）如果只是做纯内存缓存，可以都不用。\n（4）安全性比较高，同时开启\n```\n\n### 混合持久化\n\n#### 为什么会有混合持久化？\n\n```\nRDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。\nAOF 优点是丢失数据少，但是数据恢复不快。\n混合持久化集成了两个的优点\n```\n\n#### 是什么？\n\n```\n混合持久化工作是在AOF日志重写过程中，当开启了混合持久化时，在AOF重写日志时，fork出来的子进程会先将与主线程共享的内存数据以RDB方式写入到AOF文件，然后主线程处理的操作会记录在重写缓冲区中，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。\n\nAOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。\n```\n\n#### 优点\n\n```\n混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。\n```\n\n#### 缺点\n\n```\n（1）AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；\n（2）兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了\n```\n\n\n\n## 线程模型 TODO\n\nhttps://mp.weixin.qq.com/s/oeOfsgF-9IOoT5eQt5ieyw\n\nhttps://xiaolincoding.com/redis/base/redis_interview.html#redis-线程模型\n\n### Redis 是单线程吗？\n\n```\nRedis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。\n\nredis程序并不是单线程的，redis在启动时会启动后台线程（BIO）：\n处理关闭文件、AOF 刷盘、释放内存（lazyfree 线程）\n\n因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。\n```\n\n### Redis 单线程模式是怎样的？\n\n```\n\n```\n\n### 讲讲Redis的线程模型？\n\n```\nhttps://mp.weixin.qq.com/s/CiFSsOx_g9g-0PUGXDuvcQ\n\nhttps://javaguide.cn/database/redis/redis-questions-01.html#redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-%E9%87%8D%E8%A6%81\n```\n\n### Redis 采用单线程为什么还这么快？\n\n```\n单线程的 Redis 吞吐量可以达到 10W/每秒\n\nRedis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：\n（1）都在内存中完成，并且采用了高效的数据结构\n（2）Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。\n（3）Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求。\nIO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。\n#\n```\n\n### Redis 6.0 之前为什么使用单线程？\n\n```\n（1）单线程编程容易并且更容易维护；\n（2）Redis 的性能瓶颈不在 CPU ，主要在内存和网络。CPU 并不是制约 Redis 性能表现的瓶颈所在，更多情况下是受到内存大小和网络I/O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题\n（3）增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。\n```\n\n### Redis 6.0 之后为什么引入了多线程？\n\n```\n（1）为了提高网络 IO 读写性能。因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上，所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。但是对于命令的执行，Redis 仍然使用单线程来处理\n```\n\n\n\n## Redis事务\n\n### 什么是redis事务？\n\n```\nredis事务就是提供了一种将多个命令请求打包的功能，然后按顺序的去执行，执行过程被打断。\n与mysql不同的是，它不具备原子性\n```\n\n### 为什么不具备原子性\n\n```\n原子性：事务是最小的执行单位，它保证了事务中的操作要么都完成，要么都失败。\nredis事务中，如果某个命令失败了，并不会影响事务继续执行，除了失败的命令，其它命令都能正常执行。\n并且，redis事务是不支持回滚操作的。所以redis事务是不满足原子性的\n\nhttps://javaguide.cn/database/redis/redis-questions-02.html#redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97\n```\n\n### 为什么不支持回滚 x\n\n```\nredis官方的介绍是：redis开发者们觉得没有必要支持回滚，这样更简单便捷，性能也更好。\nredis开发者们觉得即使命令执行错误，也应该在开发过程中就发现而不是在生产过程中\n```\n\n### Redis 事务支持持久性吗？\n\n```\nredis支持持久化，但redis事务不支持持久性\nredis可以通过RDB、AOF或者两种方式混合进行持久化\nredis事务在执行过程中，并不会立即将数据写入磁盘，而是先缓存在内存中，当事务执行完毕并成功提交时，才会将数据写入磁盘进行持久化存储。\n\n这就以为着如果redis发生故障或意外宕机，事务中未提交的数据可能会丢失。只存在内存中，并没有持久化到磁盘中。\n\n因此redis事务不具备持久性。\n```\n\n### 如何使用Redis事务？x\n\n```\n流程\n（1）开始事务（Multi）\n（2）命令入队（FIFO）：输入的命令都会依次进入命令队列中，但不会执行\n（3）执行事务（Exec）：Redis 会将之前的命令队列中的命令依次执行\n（4）取消事务（discard）\n\nMULTI 命令用于标记事务的开始，\nEXEC 命令用于执行事务中的命令，\nWATCH 命令用于监视一个或多个键，如果被监视的键在事务执行期间被修改，则事务会被取消，\nDISCARD 命令用于取消事务。\n```\n\n### 如何解决Redis事务的缺陷？\n\n```\n主要处理的是redis事务在原子性、隔离性、错误回滚方面的问题\n可以使用lua脚本的方式解决。\n\n利用lua脚本，可以批量执行多条redis命令，这些命令会被提交到redis服务器一次性执行完成，大幅减少网络开销。\n一段lua脚本执行过程中不会有其他脚本或者redis命令执行，保证了操作不会被其他指令插入干扰。\n\n如果执行期间出错，出错后的命令不会继续执行，但是出错前的命令是不会回滚的，所以也并不能完全保证redis事务的原子性。\n```\n\n\n\n## Redis性能优化\n\n### 大量 key 集中过期问题 x\n\n```\n对于过期的key，redis使用定期删除 + 惰性删除两种策略\n（1）响应慢：定期删除过程中，如果遇到大量key失效的情况，客户端必须等待清理完成，因为定期任务线程是在redis主线程中进行。会导致客户端请求不能被及时处理，响应比较慢。\n（2）占内存：如果大量的key集中过期，但Redis没有及时清理它们，过期的key仍然会占用内存空间。这会导致Redis内存占用率上升，可能导致系统内存不足。\n```\n\n### 如何解决？\n\n```\n（1）给key设置随机过期时间。\n（2）惰性删除。\n```\n\n### redis如何清理这些过期key？\n\n```\n定期删除：\n（1）redis使用定时任务来主动查找并删除过期的键。默认每秒检查一定数量的过期键并删除。\n（2）主线程执行定期任务，可能会导致客户端请求不能及时响应。\n\n惰性删除：\n（1）Redis 在访问某个键时，会先检查该键是否过期。如果键已过期，则会立即删除该键并返回空值。这种方式避免了在每个键上定期检查的开销，只在访问时进行检查和删除。\n（2）采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。\n（3）缺点：不能删除所有过期key\n```\n\n\n\n### Redis bigkey（大 Key）\n\n#### 什么是 bigkey？\n\n```\n一个key对应的value所占的内存比较大，这个key就可以看成是bigkey\n\n参考标准：\nstring类型的value超过10kb\n符合类型的value包含元素超过5000个\n```\n\n#### bigkey 有什么危害？\n\n```\nbigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。因此，我们应该尽量避免 Redis 中存在 bigkey。\n```\n\n#### 如何发现 bigkey？\n\n```\n（1）使用 Redis 自带的 --bigkeys 参数来查找。\n（2）使用开源工具\n```\n\n#### 如何处理 bigkey？\n\n```\n（1）分割bigkey。分割成多个小的key，需要调整业务代码，不推荐\n（2）优化数据结构\n（3）持久化存储\n（4）数据压缩\n```\n\n\n\n### Redis hotkey（热 Key）\n\n#### 什么是 hotkey？\n\n```\n短时间内频繁访问的key\n```\n\n#### 有什么危害\n\n```\n（1）处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理\n（2）如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。\n```\n\n#### 如何解决 hotkey？\n\n```\n（1）缓存预热：在系统启动或低峰期，提前加载热点数据到缓存中，避免热点数据在高峰期大量请求时才从后端存储加载。\n（2）分布式缓存：使用分布式缓存，将热点数据分散到不同的缓存节点上，减轻单个缓存节点的压力。\n（3）缓存穿透处理：使用布隆过滤器等技术，对查询请求进行预处理，判断请求的键是否存在于缓存中，不存在则直接拦截请求，避免穿透到后端存储。\n（4）限流和熔断：对于大量请求访问同一个热点键，可以使用限流和熔断机制，控制请求的并发数或拒绝一部分请求，避免对后端存储造成过大压力。\n（5）读写分离：主节点处理写请求，从节点处理读请求。\n```\n\n\n\n### 慢查询命令\n\n#### 是什么\n\n```\nRedis 命令的执行可以简化为以下 4 步：\n（1）发送命令\n（2）命令排队\n（3）命令执行\n（4）返回结果\n\nredis慢查询统计的是【命令执行】这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令\n```\n\n#### 为什么会有慢查询命令 x\n\n```\nredis中的大部分命令都是O（1）时间复杂度，但也会有部分O（n）时间复杂度的命令，例如：\nKEYS *：会返回所有符合规则的 key。\nHGETALL：会返回一个 Hash 中所有的键值对。\nLRANGE：会返回 List 中指定范围内的元素。\nSMEMBERS：返回 Set 中的所有元素。\nSINTER/SUNION/SDIFF：计算多个 Set 的交集/并集/差集。\n\n随着n的增大，执行的耗时也越长。\n\n另外还有一些时间复杂度在O（N）之上的命令，例如：\n（1）ZRANGE/ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。\n（2）ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。\n\n```\n\n### Redis内存碎片\n\n#### 是什么\n\n```\n已经分配的内存空间中存在未被使用的小块内存，这些小块内容无法被充分利用，导致整体内存利用率降低\n随着内存碎片的不断积累，会导致内存碎片问题进一步加剧，导致「内存分配」和「回收」的性能下降\nRedis内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。\n```\n\n#### 为什么会导致内存分配性能下降？x\n\n```\n因为系统需要寻找连续的内存块来满足分配请求，而内存碎片造成了空洞，增加了查找的复杂度\n```\n\n#### 为什么会有redis内存碎片？x\n\n```\n（1）内部原因：内存分配器无法做到按需分配，是按固定大小来分配内存空间。\n\t\tRedis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 jemalloc，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节......）来分配内存的\n\n（2）频繁修改和删除Redis中的数据会产生内存碎片。\n```\n\n#### 详细说说为什么频繁修改 Redis 中的数据会产生内存碎片\n\n```\n修改时采用写时复制技术，修改流程：\n（1）申请一块新的内存空间，大小与修改后的键值对大小相同（实际上可能会略大于）\n（2）将原始键值对中的数据拷贝到新的内存空间中\n（3）将新的内存空间作为键值对的值，替换原始的内存空间。\n\n写时复制的优点在于：修改数据时保护了原始的内存空间，保证了读操作的并发安全性\n\n频繁修改会导致问题：\n写时复制需要申请新的内存空间，而旧的内存不会立即释放（只有当没有任何引用指向它时，它才会被垃圾回收释放掉），频繁写就会导致出现大量不连续的小块空闲内存\n```\n\n\n\n## RedLock\n\n\n\n## Redis集群\n\n### 主从复制\n\n#### 什么是主从复制\n\n```\n主从复制是一种数据同步机制，用于将一台redis主节点的数据，复制到其他redis从节点中，尽可能保证数据的一致性。\n```\n\n#### 作用\n\n```\n（1）读写分离，性能拓展。Master以写为主，Slave以读为主\n（2）容灾快速恢复：主服务器故障时，可以快速切换到从服务器继续提供服务，提高了系统的容灾能力。\n（3）拓展性。通过添加更多的从服务器，可以水平拓展系统的读取性能和容量。\n```\n\n#### 主从复制工作原理\n\n```\n（1）一个redis作为主服务器Master，负责处理所有的写操作和部分读操作\n（2）其他多个redis服务器作为从服务器Slave，只负责读操作，并通过连接与主服务器建立连接，定期从主服务器同步数据，保持与主服务器数据的一致性。\n```\n\n#### 复制原理TODO: \n\nhttps://developer.baidu.com/article/detail.html?id=294748\n\n```\n\n\n（1）建立连接：slave向master发生一个sync命令来建立与主服务器的连接。\n（2）快照传输：master收到命令后，会将当前的数据状态创建为一个快照，并将快照发送给从服务器。在传输过程中，主服务器继续处理写入操作，但会将写入操作的数据缓存到内存缓冲区中\n（3）命令传播：当快照传输完成后，主服务器会将内存缓冲区中缓存的写操作的数据（命令）发送给从服务器。从服务器接收到命令后，会按照接收到的顺序逐个执行，使得自己的数据状态与主服务器的数据状态一致\n（4）增量同步：建立连接后，从服务器会持续接收主服务器的增加数据，并执行相应的操作，保证与主服务器数据的一致性。\n```\n\n#### 读取从节点会读取到过期的数据吗\n\n```\n有可能\n（1）情况1: 主节点的写操作（设置为过期），还没来得及通知从节点，此时读取从节点的数据就可能读取到过期数据。\n（2）采用EXPIRE或者PEXPIRE设置过期时间到话，表示的是从执行这个命令开始往后TTL时间过期。所以从节点的过期时间会比主节点稍晚一些，在这期间读取从节点数据，则可能读到过期数据。（T3 - T4之间是过期）\n可以使用ExpireAt 或者 PExpireAt, 注意主从节点的时钟要保持一致\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/25/15223816902697581690269758998zYU9bf-image-20230725152238667.png\" alt=\"image-20230725152238667\" style=\"zoom:50%;\" />\n\n#### 为什么全量复制用RDB而不用AOF？\n\n```\n本质在对比RDB和AOF\n```\n\n#### 主从复制方案有什么痛点？\n\n```\n主从复制方案下，master发生宕机，需要手动将一台slave升级为master，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。人工干预会大大增加问题的处理时间以及出错的可能性。\n\n可以使用redis哨兵来解决\n\nhttps://www.yuque.com/snailclimb/mf2z3k/ks9olb19hc9wse5k#4193d6d4\n```\n\n#### Redis主从节点时长连接还是短连接？\n\n```\n长连接\n主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。\n```\n\n#### 怎么判断 Redis 某个节点是否正常工作？\n\n```\n通过相互ping-pong心跳检测机制，如果一半以上的节点去ping一个节点时没有pong回应，集群就会认为这个节点挂掉了，就会断开连接\n\n有两种心跳间隔：\n（1）主节点默认每10s发一次ping，判断从节点的存活性和连接状态\n（2）从节点每1s发送replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量，目的是为了：\n\t- 实时监测主从节点网络状态；\n\t- 上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。\n```\n\n#### 主从复制架构中，过期key如何处理？\n\n```\n主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作。\n```\n\n#### Redis 是同步复制还是异步复制？\n\n```\nRedis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点。\n```\n\n#### 为什么会出现主从数据不一致？\n\n```\n主从数据不一致，就是指客户端从从节点中读取到的值和主节点中的最新值并不一致。\n因为主从节点间的命令复制是异步进行的\n\n具体来说：\n主节点在收到新的写命令后，就会返回结果，并不是等从节点执行完之后再返回。\n如果从节点还没有执行主节点同步过来的命令，主从节点间的数据就不一致了\n```\n\n#### 如何应对主从数据不一致？\n\n```\n（1）第一种方法，尽量保证主从节点间的网络连接状况良好，避免主从节点在不同的机房。\n（2）第二种方法，可以开发一个外部程序来监控主从节点间的复制进度。\nRedis 的 INFO replication 命令可以查看「主节点接收写命令的进度信息」和「从节点复制写命令的进度信息」，所以，我们就可以开发一个监控程序，先用 INFO replication 命令查到主、从节点的进度。\n进度差值大于设定的阈值，就不让客户端从这个从节点读取数据\n```\n\n#### 主从切换如何减少数据丢失？TODO\n\n```\n\n```\n\n#### 主从如何做到故障自动切换？\n\n```\n哨兵模式\n```\n\n\n\n### 哨兵模式 Sentinel\n\n#### 是什么\n\n```\n是redis的一种运行模式，这种模式下，提供一个或多个哨兵运行在独立的服务器上，它会定期监控redis主从节点的状态。当主节点发生故障时，哨兵会通过【选举机制】自动从从节点中选出一个新的主节点，并将其他节点切换为新主节点的从节点，从而实现自动故障转移。\n```\n\n#### 为什么要有哨兵机制？\n\n```\n主从架构中，是读写分离的，如果主节点挂掉，那么就没法响应写操作，也就没法给从节点同步数据。\n如果要恢复服务的话，需要人工介入，选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点\n哨兵机制的作用就是实现「主从节点故障转移」\n```\n\n#### 有什么用\n\n```\n（1）高可用性：监控redis实例状态，主节点宕机自动故障\n（2）配置管理：可以对redis实例的配置进行管理，包括增删改实例的配置，无需手动修改配置文件。\n（3）统一的访问地址：哨兵会提供一个统一的访问地址，客户端可以通过这个地址访问redis实例，而不用关心实际的主节点地址，主从切换时，客户端无需重新配置。\n```\n\n#### 哨兵如何检测节点是否下线？\n\n```\n主观下线（SDOWN）: sentinel节点认为某个redis下线，但不确定，需要其他哨兵节点的投票\n客观下线（ODOWN）：法定数量（通过为过半）的哨兵节点认为redis主节点已经下线，那就是真的下线。【只适用于主节点】\n\n检测流程：\n每个哨兵节点以每秒一次的频率向整个集群中的master、slave以及其他sentinel节点发送一个PING命令，规定时间没有进行有效回复则认为主观下线。\n\n如果是slave节点下线，则无操作，因为对集群影响不大；如果是master，则会向其他哨兵发起命令，其他哨兵进一步确认。通常为半数的哨兵认定master下线，才判定为客观下线。\n```\n\n#### 哨兵如何选出新的master？\n\n```\nslave必须是在线状态才能参加新的master选举\n\n筛选规则（优先级依次降低）：\n（1）slave优先级。数值越小优先级越大，0表示没有参选资格\n（2）复制进度。数据完整度与旧master越接近的\n（3）runid。选runid最小的\n```\n\n#### 如何从哨兵集群中选出leader，进行主从故障转移？\n\n```\n哨兵集群确认有master客观下线之后，会开始故障转移流程，流程的第一步就是要在哨兵集群中选择一个leader，让leader来负责完成故障转移。\n```\n\n那谁来作为候选者呢？\n\n```\nleader的候选人就是那些判断主节点「客观下线」的哨兵\n```\n\n候选者如何选举成为 Leader？\n\n```\n候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。\n每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。\n那么在投票过程中，任何一个「候选者」，要满足两个条件：\n（1）拿到「半数以上」的赞成票\n（2）票数 > 哨兵配置文件中的quorum值\n```\n\n如果有多个候选者，怎么选？\n\n```\n如果某个时间点，刚好有两个哨兵节点判断到主节点为客观下线，那这时就有两个候选者\n\n每位候选者都会先给自己投一票，然后向其他哨兵发起投票请求。\n如果投票者先收到「候选者 A」的投票请求，就会先投票给它，如果投票者用完投票机会后，收到「候选者 B」的投票请求后，就会拒绝投票。这时，候选者 A 先满足了上面的那两个条件，所以「候选者 A」就会被选举为 Leader。\n```\n\n#### 如何选择哨兵个数？\n\n```\n配置成单数，且大于等于3\nquorum 的值建议设置为哨兵个数的二分之一加1\n\n如果两个哨兵，拿不到半数以上的票，即两票，选不出leader\n避免平票\n```\n\n#### 主从故障转移的过程是怎样的？\n\n```\n第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。\n第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；\n第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；\n第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；\n```\n\n\n\n### Redis集群（Cluster模式） TODO\n\nhttps://www.yuque.com/snailclimb/mf2z3k/ikf0l2\n\n#### 是什么？\n\n```\n是一种去中心集群的集群，至少由三个master，每个master至少一个slave节点，它将数据分散存储在多个节点上，每个节点负责管理一部分数据，从而实现数据的水平分片和负载均衡。\n\nslave不对外提供服务，主要是用来保障master的高可用，当master故障时替代它\n```\n\n#### 为什么需要redis cluster？\n\n```\n现有方式存在的问题：\n（1）高并发下，缓存数量可能很大，并发量要求很大\n（2）主从复制和哨兵模式两种方案本质上都是通过增加master的副本slave数量来提高redis服务的整体可用性和读吞吐量，都不支持横向拓展来缓解压力以及解决缓存数据量过大的问题。\n```\n\n#### 什么是slots？\n\n```\n一个redis集群包含16384个插槽，数据库中每个键都属于一个插槽。\n要计算某个key应该分布到哪个哈希槽中，需要先对key计算CRC-16校验码，然后对16384取模\n```\n\n#### 为什么是16384个插槽？ TODO\n\n```\ncrc16算法产生的校验码有16位，理论上可以产生65536个值，\n（1）哈希槽太大会导致心跳包太大，消耗太多带宽\n（2）哈希槽总数越少，对存储哈希槽信息的bitmap压缩效果越好\n（3）redis cluster的主节点通常不会拓展太多，16384个查希槽已经足够用了\n```\n\n#### redis cluster是如何分片的？ TODO\n\n```\n\n```\n\n\n\n## 功能篇 TODO\n\n\n\n## 面试篇 TODO\n\n\n\n## Redis缓存 TODO\n\n### 什么是缓存穿透、缓存击穿、缓存雪崩？\n\n### 数据库和缓存一致性\n","timestamp":1691335064136}]