if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m002']=[{"name":"01-滑动窗口.md","path":"002-数据结构与算法/001-数组/01-滑动窗口.md","content":"# [滑动窗口](https://labuladong.github.io/algo/di-ling-zh-bfe1b/wo-xie-le--f02cd/)\n\n## 什么时候考虑用滑动窗口？\n\n```\n相当给你一个 S 和一个 T，请问你 S 中是否存在一个子串，包含 T 中所有字符且不包含其他字符？\n```\n\n\n\n## 模版\n\n**开始套模板，只需要思考以下几个问题**：\n\n```\n1、什么时候应该移动 `right` 扩大窗口？窗口加入字符时，应该更新哪些数据？\n2、什么时候窗口应该暂停扩大，开始移动 `left` 缩小窗口？从窗口移出字符时，应该更新哪些数据？\n3、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？\n```\n\n注意\n\n-   Java 中的 Integer 和 String 这种包装类不能直接用 `==` 进行相等判断，而应该使用类的 `equals` 方法\n\n```java\n/* 滑动窗口算法框架 */\npublic void slidingWindow(string s) {\n    Map<Character, Integer> window = new HashMap<>();\t\t// 可用数组优化\n    \n  \t// [)区间\n    int left = 0, right = 0;\n    while (right < s.size()) {\n        // c 是将移入窗口的字符\n        char c = s.charAt(right);\n        // 增大窗口\n        right++;\n        // TODO: 进行窗口内数据的一系列更新\n        ...\n\n        /*** debug 输出的位置 ***/\n        // 注意在最终的解法代码中不要 print,因为 IO 操作很耗时，可能导致超时\n       System.out.println(\"window: \" + left + \" \" + right);\n        /********************/\n        \n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // d 是将移出窗口的字符\n            char d = s.charAt(left);\n            // 缩小窗口\n            left++;\n            // TODO: 进行窗口内数据的一系列更新\n            ...\n        }\n    }\n}\n```\n\n### 最小窗口模版\n\n```java\nwhile j < len(nums):\n    判断[i, j)是否满足条件\n    while 满足条件：\n        不断更新结果(注意在while内更新！)\n        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）\n    j += 1\n\n链接：https://leetcode.cn/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/\n```\n\n### 最大窗口模版\n\n```java\nwhile j < len(nums):\n    判断[i, j)是否满足条件\n    while 不满足条件：\n        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）\n    不断更新结果（注意在while外更新！）\n    j += 1\n\n链接：https://leetcode.cn/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/\n```\n\n\n\n## 题目\n\n### [3.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n\n最大窗口\n\n```\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> window = new HashMap<>();\n        int l = 0;\n        int r = 0;\n        int res = 0;\n        while(r < s.length()) {\n            char ch = s.charAt(r);\n            r++;\n\n            window.put(ch, window.getOrDefault(ch, 0) + 1);\n\n            while(window.get(ch) > 1) {\n                char del = s.charAt(l);\n                l++;\n\n                window.put(del, window.get(del) - 1);\n            }\n            res = Math.max(res, r - l);\n        }\n\n        return res;\n    }\n}\n```\n\n另一种写法（以上面写法为主）\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> window = new HashMap<>();   // <字符，下标>\n        int maxLen = 0;\n        int left = 0, right = 0;\n        while(right < s.length()) {\n            char ch = s.charAt(right);\n            int index = right;\n            right++;\n            if(window.containsKey(ch)) {\n               // left = map.get(ch) + 1; // 错解1\n                left = Math.max(left, window.get(ch) + 1);\n            }\n            window.put(ch, index);\n            maxLen = Math.max(maxLen, right - left);\n        }\n\n        return maxLen;\n    }\n}\n```\n\n错解1分析\n\n```\n考虑abba\na，b进map，此时遍历到b，map中已经含有，left = get(b) + 1 = 2;\n此时遍历到a，map中还是含有a，left = get(a) + 1 = 1, 而实际上left左边的已经在窗口之外，不在考虑范围。\n```\n\n\n\n\n\n\n\n###  209.[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)\n\n```\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n```\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int l = 0;\n        int r = 0;\n        int sum = 0;\n        int res = Integer.MAX_VALUE;\n        while(r < nums.length) {\n            int chIndex = r;\n            r++;\n            sum += nums[chIndex];\n\n            while(sum >= target) {\n                res = Math.min(res, chIndex - l + 1);\n                sum -= nums[l];\n                l++;\n            }\n        }\n\n        return res == Integer.MAX_VALUE ? 0 : res;\n    }\n}\n```\n\n\n\n### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)\n\n求最小窗口\n\n```\n输入：s = \"ADOBECODEBANC\", t = \"ABC\"\n输出：\"BANC\"\n解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 \'A\'、\'B\' 和 \'C\'。\n\n```\n\n思路：\n\n1.   我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」\n\n     ```\n     PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动（扩大）一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。\n     ```\n\n2.   我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T`中的所有字符）。\n\n3.   此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。\n\n4.   重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。\n\n```java\nclass Solution {\n    public String minWindow(String s, String t) {\n        Map<Character, Integer> window = new HashMap<>();\t\t// 窗口中已有的需要的字符个数\n        Map<Character, Integer> need = new HashMap<>();\t\t\t// 需要的字符个数\n        for(char ch : t.toCharArray()) {\n             need.put(ch, need.getOrDefault(ch, 0) + 1);\n        }\n      \n      \n        int left = 0;\n        int right = 0;\n        int valid = 0; // 表示窗口中满足 need 条件的字符个数。如need中a=2，b=3，则window中a=2时valid++,valid=2时表示a数量满足，b也满足\n        int start = 0, len = Integer.MAX_VALUE;\t// 记录最小覆盖子串的起始索引及长度\n\n        while(right < s.length()) {\n            char ch = s.charAt(right);\n            right++;\n            if(need.containsKey(ch)) {\t\t// 注意：window只记录有用的字符即可\n                window.put(ch, window.getOrDefault(ch, 0) + 1);\n                if(window.get(ch).equals(need.get(ch))) valid++;\t\t// 注意：要用equals\n            }\n\n            // System.out.println(\"window: \" + left + \" \" + right);\n\n            while(valid == need.size()) {\n              \t// 在这里更新最小覆盖子串\n                if(right - left < len) {\n                    start = left;\n                    len = right - left;\n                }\n              \t// delCh 是将移出窗口的字符，窗口左边右移\n                char delCh = s.charAt(left);\n                left++;\n                if(need.containsKey(delCh)) {  // 如果要删除的字符是need中的字符\n                    if(window.get(delCh).equals(need.get(delCh))) valid--;\n                    window.put(delCh, window.get(delCh) - 1);\n                }\n            }\n        }\n\n        return len == Integer.MAX_VALUE ? \"\" : s.substring(start, start + len);\n    }\n}\n```\n\n\n\n### [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)\n\n```\n给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。\n换句话说，s1 的排列之一是 s2 的 子串 。\n\n输入：s1 = \"ab\" s2 = \"eidbaooo\"\n输出：true\n解释：s2 包含 s1 的排列之一 (\"ba\").\n```\n\n这种题目，是明显的滑动窗口算法，**相当给你一个 `S` 和一个 `T`，请问你 `S` 中是否存在一个子串，包含 `T` 中所有字符且不包含其他字符**？\n\n```java\nclass Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        Map<Character, Integer> need = new HashMap<>();\n        Map<Character, Integer> window = new HashMap<>();\n        for(char s : s1.toCharArray()) {\n             need.put(s, need.getOrDefault(s, 0) + 1);\n        }\n\n        int left = 0, right = 0;\n        int valid = 0;\n        while(right < s2.length()) {\n            char ch = s2.charAt(right);\n            right++;\n            if(need.containsKey(ch)) {\n                window.put(ch, window.getOrDefault(ch, 0) + 1);\n                if(window.get(ch).equals(need.get(ch))) valid++;\n            }\n\n            // System.out.println(\"window: \" + left + \" \" + right);\n\n            // 判断左侧窗口是否要收缩, 相当于维护一个定长窗口\n            while(right - left >= s1.length()) {\n                // 判断是否找到合法子串\n                if(valid == need.size()) return true;\n                char d = s2.charAt(left);\n                left++;\n                if(need.containsKey(d)) {\n                    if(need.get(d).equals(window.get(d))) valid--;\n                    window.put(d, window.get(d) - 1);\n                }\n            }\n        }\n\n        return false;\n    }\n}\n```\n\n对于这道题的解法代码，基本上和76.最小覆盖子串一模一样，只需要改变几个地方：\n\n1、本题移动 `left` 缩小窗口的时机是窗口大小大于 `t.size()` 时，因为排列嘛，显然长度应该是一样的。\n\n2、当发现 `valid == need.size()` 时，就说明窗口中就是一个合法的排列，所以立即返回 `true`。\n\n至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。\n\n>   PS：由于这道题中 `[left, right)` 其实维护的是一个**定长**的窗口，窗口大小为 `t.size()`。因为定长窗口每次向前滑动时只会移出一个字符，所以可以把内层的 while 改成 if，效果是一样的。\n\n\n\n\n\n### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)\n\n```\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n输入: s = \"cbaebabacd\", p = \"abc\"\n输出: [0,6]\n解释:\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n```\n\n同567， 本题是找全部，567是 找一个\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> res = new ArrayList<>();\n        Map<Character, Integer> need = new HashMap<>();\n        Map<Character, Integer> window = new HashMap<>();\n        for(char ch : p.toCharArray()) {\n             need.put(ch, need.getOrDefault(ch, 0) + 1);\n        }\n\n        int left = 0, right = 0;\n        int valid = 0;\n        while(right < s.length()) {\n            char ch = s.charAt(right);\n            right++;\n            if(need.containsKey(ch)) {\n                window.put(ch, window.getOrDefault(ch, 0) + 1);\n                if(window.get(ch).equals(need.get(ch))) valid++;\n            }\n\n            if(right - left >= p.length()) { // while和if都行\n                if(valid == need.size()) {\n                    res.add(left);\n                }\n\n                char d = s.charAt(left);\n                left++;\n                if(need.containsKey(d)) {\n                    if(window.get(d).equals(need.get(d))) valid--;\n                    window.put(d, window.get(d) - 1);\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)\n\n```\n求最长连续数组长度，数组中只能有两类元素\n\n输入：fruits = [1,2,1]\n最长：1 2 1\n输出：3\n\n输入：fruits = [0,1,2,2]\n最长：1 2 2\n输出：3\n```\n\n求最大窗口\n\n```java\nclass Solution {\n    public int totalFruit(int[] fruits) {\n        int res = 0;\n        Map<Integer, Integer> window = new HashMap<>();\n        int l = 0;\n        int r = 0;\n        int kind = 0;\n\t\t\t\t\n      \t// [)区间\n        while(r < fruits.length) {\t// 移动右边界\n            int num = fruits[r];\t// 即将移入窗口的元素\n            r++;\n            window.put(num, window.getOrDefault(num, 0) + 1);\n            if(window.getOrDefault(num, 0) <= 1) kind++;\n\n            \n            while(kind > 2) {\t\t// 不满足条件，移动左边界\n                int del = fruits[l];\t// 即将移出的元素\n                l++;\n                window.put(del, window.get(del) - 1);\n                if(window.get(del) <= 0) kind--;\n\n            }\n\n          \t// 一旦满足条件，更新结果\n            res = Math.max(r - l, res);\n\n        }\n\n        return res;\n    }\n}\n```\n\n### [lc.1004 最大连续1的个数 III](https://leetcode.cn/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/[https://leetcode-cn.com/problems/max-consecutive-ones-iii/)\n\n最大窗口\n\n```\n\n```","timestamp":1683723295939},{"name":"01-121. 买卖股票的最佳时机.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/01-121. 买卖股票的最佳时机.md","content":"### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)\n\n注意：只能买一次，所以不能用[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)拆分利润的方法\n\n#### 方法一：贪心\n\n找低谷与顶峰\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n        int res = 0;\n\n        int min = prices[0];\n        for(int i = 1; i < prices.length; i++) {\n            min = Math.min(min, prices[i]);\n            int diff = prices[i] - min;\n            res = Math.max(res, diff);\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法二：动态规划\n\ndp含义\n\n```\ndp[i] 前i项利润最大值\n```\n\n递推公式\n\n```\ndp[i] = Math.max(prices[i] - min, dp[i - 1]);\n```\n\n源码\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n\n        int[] dp = new int[prices.length];\n        int min = prices[0];\n        dp[0] = 0;\n        for(int i = 1; i < prices.length; i++) {\n            dp[i] = Math.max(prices[i] - min, dp[i - 1]);\n            min = Math.min(min, prices[i]);\n        }\n\n        return dp[prices.length - 1];\n    }\n}\n```\n\n优化：滚动数组\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n\n        int res = 0;\n        int pre = 0;\n        int min = prices[0];\n        for(int i = 1; i < prices.length; i++) {\n            res = Math.max(prices[i] - min, pre);\n            min = Math.min(min, prices[i]);\n            pre = res;\n        }\n\n        return res;\n    }\n}\n```\n\n### 方法三：动态规划2\n\n方式1（为主）\n\n[参考](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/yi-ge-fang-3b01b/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        // dp[i][0]: 第i天不持有股票所得最多现金\n        // dp[i][1]: 第i天持有股票所得最多现金\n        int[][] dp = new int[n][2];  \n        dp[0][0] = 0;   \n        dp[0][1] = -prices[0];\n        for(int i = 1; i < n; i++) {\n            // 今天不持有： 1 昨天不持有 2 昨天持有，今天卖\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            // 今天持有： 1 昨天持有 2 昨天不持有，今天买\n            dp[i][1] = Math.max(dp[i - 1][1], - prices[i]);    // 解释1\n        }\n\n        return dp[n - 1][0];\n    }\n}\n```\n\n解释1:`为什么不是Math.max(dp[i - 1][1],  dp[i - 1][0] - prices[i]);`\n\n```\n因为只买卖一次，昨天不持有说明昨天及之前都没有发生过交易，持有的现金肯定是0\n而dp[i - 1][0]可能包含了两种情况，1 一直没持有； 2 持有过但卖了。\n而现在已经确定了今天要买，并且题目要求只能交易一次，所以只能取dp[i - 1][0]的第一种情况，也就是0\n```\n\n\n\n\n\n方式2\n\n<img src=\"/Users/kuan/Library/Application%20Support/typora-user-images/image-20221222123200226.png\" alt=\"image-20221222123200226\" style=\"zoom: 33%;\" />\n\n```\ndp[i][0] 就是用来记录最低谷的\ndp[i][1] 记录当前最大利润\n```\n\n\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n\n        int[][] dp = new int[prices.length][2];\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i = 1; i < prices.length; i++) {\n            dp[i][0] = Math.max(-prices[i], dp[i - 1][0]);\n            dp[i][1] = Math.max(prices[i] + dp[i-1][0], dp[i - 1][1]);\n        }\n\n        return dp[prices.length - 1][1];\n    }\n}\n```\n\n","timestamp":1683723295939},{"name":"02-122. 买卖股票的最佳时机 II.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/02-122. 买卖股票的最佳时机 II.md","content":"### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)\n\n#### 方法一：贪心\n\n\n\n#### 方法二：dp\n\n##### 方式1（为主）\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        if(n == 0) return 0;\n\n        int[][] dp = new int[n][2];\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        for(int i = 1; i < n; i++) {\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); // 与121.对比\n        }\n        return dp[n - 1][0];\n    }\n}\n```\n\n优化: 滚动数组\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        if(n == 0) return 0;\n\n        int pre0 = 0;\n        int pre1 = -prices[0];\n        for(int i = 1; i < n; i++) {\n            pre0 = Math.max(pre0, pre1 + prices[i]);\n            pre1 = Math.max(pre1, pre0 - prices[i]);\n        }\n        return pre0;\n    }\n}\n```\n\n[参考](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/yi-ge-fang-3b01b/)\n\n##### 方式2\n\n与方式1的区别在于`dp[i][0]和dp[i`][1]相反\n\n[参考](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int[][] dp = new int[prices.length][2];\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i = 1; i < prices.length; i++) {\n            dp[i][0] = Math.max(dp[i-1][1] - prices[i], dp[i-1][0]);\n            dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]);\n        }\n\n        return dp[prices.length- 1][1];\n    }\n}\n```\n\n\n\n```\n7 1 2 5 3 6 4\n\n-7  0\n-1  0\n-1  1\n-4  4\n 1  4\n-2  7\n```\n\n","timestamp":1683723295939},{"name":"03-123. 买卖股票的最佳时机 III.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/03-123. 买卖股票的最佳时机 III.md","content":"### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)\n\n\n\n#### 方法一：三维dp\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int k = 2;\n        if(n == 0) return 0;\n        int[][][]dp = new int[n][k + 1][2];\n        dp[0][1][0] = 0;\n        dp[0][1][1] = -prices[0];\n        dp[0][2][0] = 0;\n        dp[0][2][1] = -prices[0];\n        for(int i = 1; i < n; i++) {\n            for(int j = 1; j <= 2; j++) {\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n\n        return dp[n - 1][k][0];\n    }\n}\n```\n\n优化初始化过程\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int k = 2;\n        if(n == 0) return 0;\n        int[][][]dp = new int[n][k + 1][2];\n        for(int i = 0; i < n; i++) {\n            for(int j = 1; j <= 2; j++) {\n                if(i == 0) {\n                    dp[i][j][0] = 0;\n                    dp[i][j][1] = -prices[i];\n                    continue;\n                }\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n\n        return dp[n - 1][k][0];\n    }\n}\n```\n\nk倒着写才符合语义\n\n第0天还没开始卖，所以最大交易次数应该为k_max\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int k = 2;\n        if(n == 0) return 0;\n        int[][][]dp = new int[n][k + 1][2];\n        for(int i = 0; i < n; i++) {\n            for(int j = k; j >= 1; j--) {\n                if(i == 0) {\n                    dp[i][j][0] = 0;\n                    dp[i][j][1] = -prices[i];\n                    continue;\n                }\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n\n        return dp[n - 1][k][0];\n    }\n}\n```\n\n优化：k次数较小，可以直接列举，滚动数组\n\n```java\n// 状态转移方程：\n// dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\n// dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\n// dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\n// dp[i][1][1] = max(dp[i-1][1][1], -prices[i])\n\n// 空间复杂度优化版本\nint maxProfit_k_2(int[] prices) {\n    // base case\n    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;\n    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;\n    for (int price : prices) {\n        dp_i20 = Math.max(dp_i20, dp_i21 + price);\n        dp_i21 = Math.max(dp_i21, dp_i10 - price);\n        dp_i10 = Math.max(dp_i10, dp_i11 + price);\n        dp_i11 = Math.max(dp_i11, -price);\n    }\n    return dp_i20;\n}\n\n```\n\n\n\n空间优化2: 本质上还是因为k的次数较小，可以直接列举，缩小一个纬度\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int[][] dp = new int[prices.length][5];\n        dp[0][1] = -prices[0];\n        dp[0][3] = -prices[0];\n\n        for(int i = 1; i < prices.length; i++) {\n            dp[i][0] = dp[i-1][0];\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n        }\n\n        return dp[prices.length - 1][4];\n    }\n}\n```\n\n","timestamp":1683723295939},{"name":"04-188. 买卖股票的最佳时机 IV.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/04-188. 买卖股票的最佳时机 IV.md","content":"### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)\n\n```\nclass Solution {\n    public int maxProfit(int k, int[] prices) {\n        int[][] dp = new int[prices.length][2 * k + 1];\n        for(int i = 1; i < k*2; i += 2) {\n            dp[0][i] = -prices[0];\n        }\n\n        for(int i = 1; i < prices.length; i++) {\n            for(int j = 0; j < k*2 - 1; j += 2) {\n                dp[i][j + 1] = Math.max(dp[i-1][j + 1], dp[i-1][j] - prices[i]);\n                dp[i][j + 2] = Math.max(dp[i-1][j + 2], dp[i-1][j + 1] + prices[i]);\n            }\n        }\n\n        return dp[prices.length - 1][k*2];\n    }\n}\n```\n\n三维数组\n\n```\n\n```\n\n","timestamp":1683723295939},{"name":"05-309. 最佳买卖股票时机含冷冻期.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/05-309. 最佳买卖股票时机含冷冻期.md","content":"\n\n\n\n\n\n### [309最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int[][] dp = new int[n][2];\n\n        for(int i = 0; i < n; i++) {\n            if(i - 1 == -1) {\n                dp[i][0] = 0;\n                dp[i][1] = -prices[0];\n                continue;\n            }\n            if(i - 2  == -1) {\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n                dp[i][1] = Math.max(dp[i-1][1], - prices[i]);\n                continue;\n            }\n\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n            // 当天持有：1 前一天持有  2 前一天没有&没有卖 今天买\n            dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);  // 解释1\n        }\n\n        return dp[n - 1][0];\n    }\n}\n```\n\n解释1：为什么是`dp[i-2][0] - prices[i]`\n\n```\n题目要求：1 卖出股票后，第二天不能买； 2 有切仅持有1支股票\n所以当前持有分为两种情况\n- 情况1：前一天持有\n- 情况2: 今天刚买。按要求1 那么就要求昨天不能卖； 按要求2 昨天不能持有\n\n为什么不能是dp[i - 1][0] - prices[i]呢？\ndp[i-1][0]有两个含义：1 前天买昨天卖； 2 前天没有，昨天也没有；\n现在已经明确今天要买，只能是“前天没有，昨天也没有”这种情况\n```\n\n","timestamp":1683723295939},{"name":"06-714. 买卖股票的最佳时机含手续费.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/06-714. 买卖股票的最佳时机含手续费.md","content":"### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices, int fee) {\n        int n = prices.length;\n        int[][] dp = new int[n][2];\n        for(int i = 0; i < n; i++) {\n            if(i - 1 < 0) {\n                dp[i][0] = 0;\n                dp[i][1] = -prices[0];\n                continue;\n            }\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);\t// 与模版的唯一区别\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n        }\n\n        return dp[n - 1][0];\n    }\n}\n```\n\n","timestamp":1683723295939}]