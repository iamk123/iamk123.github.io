if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m002']=[{"name":"000-Java基础.md","path":"002-数据结构与算法/000-Java基础.md","content":"资料\n\n-   [灵茶山艾府](https://github.com/EndlessCheng)\n\n\n\n## map\n\n```java\nList<String> list = map.getOrDefault(key, new ArrayList<String>())\n\n// map转list\nList<List<String>> list = new ArrayList<List<String>>(map.values()); \n\n// 初始化赋值\nMap<String, String> map  = new HashMap<String, String>() { {\n  put(\"key1\", \"value1\");\n  put(\"key2\", \"value2\");\n} };\n```\n\n\n\n## list\n\n```java\nList<List<Integer>> res = new ArrayList<>();\nres.add(Arrays.asList(nums[i], nums[l], nums[r]));\n```\n\n统计字母出现次数\n\n```java\nint[] counts = new int[26];\nint length = str.length();\nfor (int i = 0; i < length; i++) {\n  \tcounts[str.charAt(i) - \'a\']++;\n}\n```\n\nlist转数组\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\n\n// 转换为对象数组\nObject[] array = list.toArray();\n\n// 转换为Integer类型的数组\nInteger[] array = list.toArray(new Integer[list.size()]);\n\n// 使用流API转换为Integer类型的数组\nInteger[] array = list.stream().toArray(Integer[]::new);\n```\n\n","timestamp":1694699764227},{"name":"01-滑动窗口.md","path":"002-数据结构与算法/001-数组/01-滑动窗口/01-滑动窗口.md","content":"# [滑动窗口](https://labuladong.github.io/algo/di-ling-zh-bfe1b/wo-xie-le--f02cd/)\n\n## 什么时候考虑用滑动窗口？\n\n```\n相当给你一个 S 和一个 T，请问你 S 中是否存在一个子串，包含 T 中所有字符且不包含其他字符？\n```\n\n\n\n## 模版\n\n**开始套模板，只需要思考以下几个问题**：\n\n```\n1、什么时候应该移动 `right` 扩大窗口？窗口加入字符时，应该更新哪些数据？\n2、什么时候窗口应该暂停扩大，开始移动 `left` 缩小窗口？从窗口移出字符时，应该更新哪些数据？\n3、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？\n```\n\n注意\n\n-   Java 中的 Integer 和 String 这种包装类不能直接用 `==` 进行相等判断，而应该使用类的 `equals` 方法\n\n```java\n/* 滑动窗口算法框架 */\npublic void slidingWindow(string s) {\n    Map<Character, Integer> window = new HashMap<>();\t\t// 可用数组优化\n    \n  \t// [)区间\n    int left = 0, right = 0;\n    while (right < s.size()) {\n        // c 是将移入窗口的字符\n        char c = s.charAt(right);\n        // 增大窗口\n        right++;\n        // TODO: 进行窗口内数据的一系列更新\n        ...\n\n        /*** debug 输出的位置 ***/\n        // 注意在最终的解法代码中不要 print,因为 IO 操作很耗时，可能导致超时\n       System.out.println(\"window: \" + left + \" \" + right);\n        /********************/\n        \n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // d 是将移出窗口的字符\n            char d = s.charAt(left);\n            // 缩小窗口\n            left++;\n            // TODO: 进行窗口内数据的一系列更新\n            ...\n        }\n    }\n}\n```\n\n### 最小窗口模版\n\n```java\nwhile j < len(nums):\n    判断[i, j)是否满足条件\n    while 满足条件：\n        不断更新结果(注意在while内更新！)\n        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）\n    j += 1\n\n链接：https://leetcode.cn/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/\n```\n\n### 最大窗口模版\n\n```java\nwhile j < len(nums):\n    判断[i, j)是否满足条件\n    while 不满足条件：\n        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）\n    不断更新结果（注意在while外更新！）\n    j += 1\n\n链接：https://leetcode.cn/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/\n```\n\n\n\n## 题目\n\n\n\n### [3.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n\n最大窗口\n\n```\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> window = new HashMap<>();\n        int l = 0;\n        int r = 0;\n        int res = 0;\n        while(r < s.length()) {\n            char ch = s.charAt(r);\n            r++;\n\n            window.put(ch, window.getOrDefault(ch, 0) + 1);\n\n            while(window.get(ch) > 1) {\n                char del = s.charAt(l);\n                l++;\n\n                window.put(del, window.get(del) - 1);\n            }\n            res = Math.max(res, r - l);\n        }\n\n        return res;\n    }\n}\n```\n\n另一种写法（以上面写法为主）\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> window = new HashMap<>();   // <字符，下标>\n        int maxLen = 0;\n        int left = 0, right = 0;\n        while(right < s.length()) {\n            char ch = s.charAt(right);\n            int index = right;\n            right++;\n            if(window.containsKey(ch)) {\n               // left = map.get(ch) + 1; // 错解1\n                left = Math.max(left, window.get(ch) + 1);\n            }\n            window.put(ch, index);\n            maxLen = Math.max(maxLen, right - left);\n        }\n\n        return maxLen;\n    }\n}\n```\n\n错解1分析\n\n```\n考虑abba\na，b进map，此时遍历到b，map中已经含有，left = get(b) + 1 = 2;\n此时遍历到a，map中还是含有a，left = get(a) + 1 = 1, 而实际上left左边的已经在窗口之外，不在考虑范围。\n```\n\n\n\n\n\n\n\n###  209.[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)\n\n```\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n```\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int l = 0;\n        int r = 0;\n        int sum = 0;\n        int res = Integer.MAX_VALUE;\n        while(r < nums.length) {\n            int chIndex = r;\n            r++;\n            sum += nums[chIndex];\n\n            while(sum >= target) {\n                res = Math.min(res, chIndex - l + 1);\n                sum -= nums[l];\n                l++;\n            }\n        }\n\n        return res == Integer.MAX_VALUE ? 0 : res;\n    }\n}\n```\n\n\n\n### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)\n\n求最小窗口\n\n```\n输入：s = \"ADOBECODEBANC\", t = \"ABC\"\n输出：\"BANC\"\n解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 \'A\'、\'B\' 和 \'C\'。\n\n```\n\n思路：\n\n1.   我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」\n\n     ```\n     PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动（扩大）一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。\n     ```\n\n2.   我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T`中的所有字符）。\n\n3.   此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。\n\n4.   重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。\n\n```java\nclass Solution {\n    public String minWindow(String s, String t) {\n        Map<Character, Integer> window = new HashMap<>();\t\t// 窗口中已有的需要的字符个数\n        Map<Character, Integer> need = new HashMap<>();\t\t\t// 需要的字符个数\n        for(char ch : t.toCharArray()) {\n             need.put(ch, need.getOrDefault(ch, 0) + 1);\n        }\n      \n      \n        int left = 0;\n        int right = 0;\n        int valid = 0; // 表示窗口中满足 need 条件的字符个数。如need中a=2，b=3，则window中a=2时valid++,valid=2时表示a数量满足，b也满足\n        int start = 0, len = Integer.MAX_VALUE;\t// 记录最小覆盖子串的起始索引及长度\n\n        while(right < s.length()) {\n            char ch = s.charAt(right);\n            right++;\n            if(need.containsKey(ch)) {\t\t// 注意：window只记录有用的字符即可\n                window.put(ch, window.getOrDefault(ch, 0) + 1);\n                if(window.get(ch).equals(need.get(ch))) valid++;\t\t// 注意：要用equals\n            }\n\n            // System.out.println(\"window: \" + left + \" \" + right);\n\n            while(valid == need.size()) {\n              \t// 在这里更新最小覆盖子串\n                if(right - left < len) {\n                    start = left;\n                    len = right - left;\n                }\n              \t// delCh 是将移出窗口的字符，窗口左边右移\n                char delCh = s.charAt(left);\n                left++;\n                if(need.containsKey(delCh)) {  // 如果要删除的字符是need中的字符\n                    if(window.get(delCh).equals(need.get(delCh))) valid--;\n                    window.put(delCh, window.get(delCh) - 1);\n                }\n            }\n        }\n\n        return len == Integer.MAX_VALUE ? \"\" : s.substring(start, start + len);\n    }\n}\n```\n\n\n\n### [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)\n\n```\n给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。\n换句话说，s1 的排列之一是 s2 的 子串 。\n\n输入：s1 = \"ab\" s2 = \"eidbaooo\"\n输出：true\n解释：s2 包含 s1 的排列之一 (\"ba\").\n```\n\n这种题目，是明显的滑动窗口算法，**相当给你一个 `S` 和一个 `T`，请问你 `S` 中是否存在一个子串，包含 `T` 中所有字符且不包含其他字符**？\n\n```java\nclass Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        Map<Character, Integer> need = new HashMap<>();\n        Map<Character, Integer> window = new HashMap<>();\n        for(char s : s1.toCharArray()) {\n             need.put(s, need.getOrDefault(s, 0) + 1);\n        }\n\n        int left = 0, right = 0;\n        int valid = 0;\n        while(right < s2.length()) {\n            char ch = s2.charAt(right);\n            right++;\n            if(need.containsKey(ch)) {\n                window.put(ch, window.getOrDefault(ch, 0) + 1);\n                if(window.get(ch).equals(need.get(ch))) valid++;\n            }\n\n            // System.out.println(\"window: \" + left + \" \" + right);\n\n            // 判断左侧窗口是否要收缩, 相当于维护一个定长窗口\n            while(right - left >= s1.length()) {\n                // 判断是否找到合法子串\n                if(valid == need.size()) return true;\n                char d = s2.charAt(left);\n                left++;\n                if(need.containsKey(d)) {\n                    if(need.get(d).equals(window.get(d))) valid--;\n                    window.put(d, window.get(d) - 1);\n                }\n            }\n        }\n\n        return false;\n    }\n}\n```\n\n对于这道题的解法代码，基本上和76.最小覆盖子串一模一样，只需要改变几个地方：\n\n1、本题移动 `left` 缩小窗口的时机是窗口大小大于 `t.size()` 时，因为排列嘛，显然长度应该是一样的。\n\n2、当发现 `valid == need.size()` 时，就说明窗口中就是一个合法的排列，所以立即返回 `true`。\n\n至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。\n\n>   PS：由于这道题中 `[left, right)` 其实维护的是一个**定长**的窗口，窗口大小为 `t.size()`。因为定长窗口每次向前滑动时只会移出一个字符，所以可以把内层的 while 改成 if，效果是一样的。\n\n\n\n\n\n### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)\n\n```\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n输入: s = \"cbaebabacd\", p = \"abc\"\n输出: [0,6]\n解释:\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n```\n\n同567， 本题是找全部，567是 找一个\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> res = new ArrayList<>();\n        Map<Character, Integer> need = new HashMap<>();\n        Map<Character, Integer> window = new HashMap<>();\n        for(char ch : p.toCharArray()) {\n             need.put(ch, need.getOrDefault(ch, 0) + 1);\n        }\n\n        int left = 0, right = 0;\n        int valid = 0;\n        while(right < s.length()) {\n            char ch = s.charAt(right);\n            right++;\n            if(need.containsKey(ch)) {\n                window.put(ch, window.getOrDefault(ch, 0) + 1);\n                if(window.get(ch).equals(need.get(ch))) valid++;\n            }\n\n            if(right - left >= p.length()) { // while和if都行\n                if(valid == need.size()) {\n                    res.add(left);\n                }\n\n                char d = s.charAt(left);\n                left++;\n                if(need.containsKey(d)) {\n                    if(window.get(d).equals(need.get(d))) valid--;\n                    window.put(d, window.get(d) - 1);\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)\n\n```\n求最长连续数组长度，数组中只能有两类元素\n\n输入：fruits = [1,2,1]\n最长：1 2 1\n输出：3\n\n输入：fruits = [0,1,2,2]\n最长：1 2 2\n输出：3\n```\n\n求最大窗口\n\n```java\nclass Solution {\n    public int totalFruit(int[] fruits) {\n        int res = 0;\n        Map<Integer, Integer> window = new HashMap<>();\n        int l = 0;\n        int r = 0;\n        int kind = 0;\n\t\t\t\t\n      \t// [)区间\n        while(r < fruits.length) {\t// 移动右边界\n            int num = fruits[r];\t// 即将移入窗口的元素\n            r++;\n            window.put(num, window.getOrDefault(num, 0) + 1);\n            if(window.getOrDefault(num, 0) <= 1) kind++;\n\n            \n            while(kind > 2) {\t\t// 不满足条件，移动左边界\n                int del = fruits[l];\t// 即将移出的元素\n                l++;\n                window.put(del, window.get(del) - 1);\n                if(window.get(del) <= 0) kind--;\n\n            }\n\n          \t// 一旦满足条件，更新结果\n            res = Math.max(r - l, res);\n\n        }\n\n        return res;\n    }\n}\n```\n\n### [lc.1004 最大连续1的个数 III](https://leetcode.cn/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/[https://leetcode-cn.com/problems/max-consecutive-ones-iii/)\n\n最大窗口\n\n```\n\n```","timestamp":1694699764227},{"name":"02-239. 滑动窗口最大值.md","path":"002-数据结构与算法/001-数组/01-滑动窗口/02-239. 滑动窗口最大值.md","content":"### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)\n\n#### 方法一：单调队列\n\n思路：\n\n采用一个单调递减的队列存元素下标，队首始终为窗口最大值下标，\n\n队列为空时，直接加入\n\n始终保持队列单调递减，在加入元素x时，要将队列中>=x的元素下标移除\n\n当队首元素指向的下标不在窗口范围内则移除\n\n\n\n##### Java\n\n错解：\n\n存在的问题：当队首元素已经不再窗口内时，不能将其移出，如 [1,3,1,2,0,5]，窗口为[1,2,0]时，队列为[3,2]并不能把3移除\n\n```java\nclass Solution {\n    Deque<Integer> deque = new LinkedList<>();\n\n    public void myPush(Integer n, int k) {\n        if(deque.size() == k) { // [1,3,1,2,0,5]，到0时，队列为[3,2]并不能把3移除\n            deque.removeLast();\n        }\n        while(!deque.isEmpty() && n >= deque.getFirst()) {\n            deque.removeFirst();\n        }\n        deque.push(n);\n    }\n\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int[] res = new int[nums.length - k + 1];\n        int index = 0;\n\n        // 第一个窗口\n        for(int i=0; i<k; i++) {\n            myPush(nums[i], k);\n        }\n        res[index++] = deque.getLast();\n\n        for(int i=k; i<nums.length; i++) {\n            myPush(nums[i], k);\n            res[index++] = deque.getLast();\n        }\n        \n        return res;\n    }\n}\n```\n\n解决办法：队列中存储数组下标，不存实际值\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        List<Integer> list = new ArrayList<>();\n        Deque<Integer> q = new LinkedList<>(); // 存可能是最大值的下标\n\n        // 初始化第一个窗口\n        for(int i = 0; i < k; i++) {\n            while(!q.isEmpty() && nums[i] >= nums[q.peekLast()]) {\n                q.pollLast();\n            }\n            q.offerLast(i);\n        }\n        list.add(nums[q.peek()]);\n\n      \t// 定长窗口不断右移\n        for(int i = k; i < n; i++) {\n            while(!q.isEmpty() && nums[i] >= nums[q.peekLast()]) {\n                q.pollLast();\n            }\n            q.offerLast(i);\n\n            // 判断最大值是否在窗口外\n            if(i - q.peekFirst() + 1 > k) {\n                q.removeFirst();\n            }\n\n            list.add(nums[q.peek()]);\n        }\n\n        int[] res = new int[list.size()];\n        for(int i = 0; i < list.size(); i++) res[i] = list.get(i);\n        return res;\n    }\n}\n```\n\n优化：直接用数组存结果，不需要中间变量List\n\n```java\nclass Solution {\n\tpublic int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> deque = new LinkedList<>(); // 存可能是最大值的下标\n        int[] res = new int[nums.length - k + 1];\n\n        // 第一个窗口\n        for(int i = 0; i < k; i++) {\n            while(!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n        }\n        res[0] = nums[deque.peekFirst()];\n\n        for(int i = k; i < nums.length; i++) {\n            while(!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n\n            while(deque.peekFirst() <= i-k) {\n                deque.pollFirst();\n            }\n            res[i-k+1] = nums[deque.peekFirst()];  // 优化\n        }\n        \n        return res;\n    }\n}\n\n```\n\n#### 方法二：优先级队列\n\n思路跟单调队列一样，单调队列 是 优先级队列的优化\n\n[参考](https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/)\n\n","timestamp":1694699764227},{"name":"03-阅读书籍组合数.md","path":"002-数据结构与算法/001-数组/01-滑动窗口/03-阅读书籍组合数.md","content":"4399笔试题\n\n```\n在一个文学沙龙中，你作为一名热爱阅读的书迷，来到了一本书店。书店摆放着一排书架，每个位置摆放着不同的书籍类型，用大写字母表示。你有一个特殊的任务：从这些书中选择一段连续的区间，组成一个有趣的阅读列表。\n阅读列表的\"有趣\"标准是：所选区间内的每种书籍类型的数量都不超过限定的值。\n例如：[A,A,A,B,B] 中类型为 A 的书籍有3本，类型为 B 的书籍有2本，每一种类型的书籍数量均不超过3本\n给定一个数组 books，表示书架上的书籍类型排布，请返回在这个书架上，共有多少种有趣的阅读列表组合\n示例：\n\n输入：books = [A,B,C,B], cnt = 1\n输出：8\n\n解释：相同类型的数据不超过 1 本，共有 8 种有趣的阅读列表组合\n长度为 1 的区间 [A]、[B]、[C]、[B] 均满足条件，共 4 种可选择区间\n长度为 2 的区间 [A,B]、[B,C]、[C,B] 均满足条件，共 3 种可选择区间\n长度为 3 的区间 [A,B,C] 满足条件，共 1 种可选择区间。\n区间 [B,C,B],[A,B,C,B] 都包含了 2 本同类型书籍 B ，不满足条件。\n返回总数 4+3+1 = 8\n```\n\n\n\n感觉有问题，cnt=2时，结果为10, B出现了两次\n\n```\nA AB ABC ABCB\nB BC BCB\nC CB\nB\n```\n\n\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public int solve(char[] books, int cnt) {\n        int n = books.length;\n        Map<Character, Integer> bookCount = new HashMap<>();\n        int left = 0;\n        int interestingLists = 0;\n\n        for (int right = 0; right < n; right++) {\n            // 更新当前窗口中的书籍数量信息\n            char book = books[right];\n            bookCount.put(book, bookCount.getOrDefault(book, 0) + 1);\n\n            // 缩小窗口，保持书籍数量不超过限定值\n            while (bookCount.values().stream().anyMatch(count -> count > cnt)) {\n                char leftBook = books[left];\n                bookCount.put(leftBook, bookCount.get(leftBook) - 1);\n                if (bookCount.get(leftBook) == 0) {\n                    bookCount.remove(leftBook);\n                }\n                left++;\n            }\n\n            // 计算当前窗口内的有趣阅读列表数量\n            interestingLists += right - left + 1;\t// 窗口内为ABCD，则共A、AB、ABC、ABCB四个，即r-l+1\n        }\n\n        return interestingLists;\n    }\n\n    public static void main(String[] args) {\n        Main m = new Main();\n        char[] books = {\'A\', \'B\', \'C\', \'B\'};\n        int cnt = 1;\n        int result = m.solve(books, cnt);\n        System.out.println(result);  // 输出：8\n    }\n}\n```\n\n\n\n```\npackage test;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] nums = new String[]{\"A\", \"B\", \"C\", \"B\"};\n        int cnt = 2;\n\n        int res = 0;\n        Map<String, Integer> map = new HashMap<>();\n        int l = 0, r = 0;\n        while(r < nums.length) {\n            String str = nums[r];\n            r++;\n            map.put(str, map.getOrDefault(str, 0) + 1);\n\n            while(map.get(str) > cnt) {\n                String del = nums[l];\n                map.put(del, map.get(del) - 1);\n                l++;\n            }\n\n            res += r - l;\n        }\n\n        System.out.println(res);\n    }\n}\n\n```\n\n","timestamp":1694699764227},{"name":"01-前缀和.md","path":"002-数据结构与算法/001-数组/02-前缀和/01-前缀和.md","content":"作用\n\n```\n快速计算区间和\n```\n\n代码\n\n```java\n// 计算前缀和数组, 注意下标便宜， [0, 2]的前缀和为preSum[3]，preSum[i]是[0, i-1]的和\nint[] preSum = new int[n + 1];\nfor(int i = 0; i < n; i++) {\n  \tpreSum[i + 1] = preSum[i] + nums[i];\n}\n```\n\n","timestamp":1694699764227},{"name":"02-560. 和为 K 的子数组.md","path":"002-数据结构与算法/001-数组/02-前缀和/02-560. 和为 K 的子数组.md","content":"### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)\n\n```\n给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。\n```\n\n#### 错解：滑动窗口\n\n```\n思路：窗口sum < k时不断扩大右边界，> k时缩小左边界\n\n问题：数组为负数时不适用\n[-1,-1,1]\n0\n```\n\n```java\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        // if(k == 0) return 0;\n        int n = nums.length;\n        int res = 0;\n        // Arrays.sort(nums);\n        int l = 0, r = 0;\n        int sum = 0;\n        while(r < n) {\n            sum += nums[r];\n            r++;\n\n            System.out.println(sum);\n            while(sum > k) {\n                sum -= nums[l];\n                l++;\n            }\n\n            if(sum == k) {\n                // System.out.println(sum + \"  \" + nums[r]);\n                res++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法一：枚举\n\n就是暴力破解\n\n```java\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        int res = 0;\n        for(int i = 0; i < nums.length; i++) {\n            // 求nums[0 : i]的前缀和\n            int sum = 0;\n            for(int end = i; end >= 0; end--) {\n                sum += nums[end];\n                if(sum == k) res++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n#### 方法二：前缀和\n\n暴力的优化，利用前缀和数组快速计算区间和\n\n```java\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        int res = 0;\n        int n = nums.length;\n      \t// 计算前缀和数组\n        int[] preSum = new int[n + 1];\n        for(int i = 0; i < n; i++) {\n            preSum[i + 1] = preSum[i] + nums[i];\n        }\n\n        for(int l = 0; l < n; l++) {\n            for(int r = l; r < n; r++) {\n              \t// 区间和，[l, r], 前缀和注意下表偏移\n                int sum = preSum[r + 1] - preSum[l];\n                if(sum == k) res++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/subarray-sum-equals-k/solution/bao-li-jie-fa-qian-zhui-he-qian-zhui-he-you-hua-ja/)\n\n#### 方法三： 前缀和 + 哈希表\n\n```\n区间和[0, j] = preSum[j + 1] - preSum[0]\n区间和[i, j] = preSum[j + 1] - preSum[i]\n要求的就是 区间和[i, j] == k，即preSum[j + 1] - preSum[i] = k的情况， 也可以变化为判断preSum[j + 1] - k = preSum[i]\n\n现在用一个变量preSum代替前缀和数组，preSum代表的是区间和[0, j]\n现在要求[0, j]内有没有区间和为k的情况，可以变化为判断是否存在preSum - k\n```\n\n```java\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, 1);\n        int preSum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            preSum += nums[i];\n            if(map.containsKey(preSum - k)) {\n                res += map.get(preSum - k);\n            }\n\n            map.put(preSum, map.getOrDefault(preSum, 0) + 1);\n        }\n\n        return res;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/subarray-sum-equals-k/solution/bao-li-jie-fa-qian-zhui-he-qian-zhui-he-you-hua-ja/)","timestamp":1694699764227},{"name":"01-二分查找理论.md","path":"002-数据结构与算法/001-数组/03-二分查找/01-二分查找理论.md","content":"### 知识点\n\n易错点\n\n- 如何确定while (left <= right) 还是 while (left < right)\n- 当 nums[middle] > target 时，right = middle - 1 还是 middle\n- int mid = low + ((high - low) >> 1)可以防止（low + high）/ 2 越界\n  - \\>>优先级低于+\n\n二分法种类\n\n- [left, right]\n- [left, right）\n\n[left, right]写法\n\n```java\npublic int search(int[] nums, int target) {\n  int low = 0, high = nums.length - 1;\t// 包含右边nums[nums.length - 1]\n  while(low <= high) {  // [1, 1]是合法的\n    int mid = low + ((high - low) >> 1);\t// 可以防止low+high越界; >>比-低\n    if(nums[mid] == target){\n      return mid;\n    } else if(nums[mid] > target){\n      high = mid - 1;\t\t// nums[middle]一定不是target，下一个查询区间不会去比较nums[middle],所以mid - 1\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n}\n```\n\n[left, right)写法\n\n```java\npublic int search(int[] nums, int target) {\n  int low = 0, high = nums.length; // 区别1: 不包含右边nums[nums.length]\n  while(low < high) {  // 区别2： [1, 1)非法,left == right在区间[left, right)无意义\n    int mid = low + ((high - low) >> 1);\t// 可以防止加号越界\n    if(nums[mid] == target){\n      return mid;\n    } else if(nums[mid] > target){\n      high = mid;\t\t// 区别3: 下一个查询区间不会去比较nums[middle]\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n}\n```\n\n### 题目\n\n","timestamp":1694699764227},{"name":"02-33. 搜索旋转排序数组.md","path":"002-数据结构与算法/001-数组/03-二分查找/02-33. 搜索旋转排序数组.md","content":"### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)\n\n```\n旋转有序数组，找目标值\n\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n```\n\n![fig1](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/30/15433816828406181682840618131DXVmpE-33_fig1.png)\n\n数组部分有序，思想就是尽可能的让搜索的范围变成有序的部分.\n\n每次取mid时，一定是有一部分有序，如何判断？\n\n```\n如果nums[0] <= nums[mid]。说明[l : mid]有序，另外半边无法确定。\n```\n\n\n\n#### 方式1\n\n以方式1为主，与[81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)统一写法\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int l = 0;\n        int r = n - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            System.out.println(\"mid: \" + nums[mid]);\n            if(nums[mid] == target) return mid;\n            if(nums[l] <= nums[mid]) {   // 左半边有序，右半边不一定有序\n                if(nums[l] <= target && target < nums[mid]) { // 判断target在[l, mid]中, 需要<=\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if(nums[mid] < target && target <= nums[r]) {\t// 需要<=\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n```\n\n\n\n#### 方式2\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int l = 0;\n        int r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            System.out.println(\"mid: \" + nums[mid]);\n            if(nums[mid] == target) return mid;\n            if(nums[0] <= nums[mid]) {   // 左半边有序，右半边不一定有序。 解释2\n                if(nums[0] <= target && target < nums[mid]) {\t// 解释1\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if(target > nums[mid] && target < nums[n - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n```\n\n解释1： 为什么要加`nums[0] <= target`?\n\n```\n仅由target < nums[mid]并不能确定target在左半边，如上左图，2小于mid = 7，但是在右半边\n```\n\n解释2: 为什么是 `nums[0] <= nums[mid]` 而不是 `nums[l] <= nums[mid]` ?\n\n```\n两种方法都能实现，nums[l]的写法即方式1\nnums[l] <= nums[mid]的另一种实现方式参考如下\nhttps://leetcode.cn/problems/search-in-rotated-sorted-array/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/\n\n此处nums[0] <= nums[mid]就能判断出哪半边有序了\n如上左图，target=2\n第一轮结束后 l = 4, r = 6\n下一轮： mid = 5， 此时nums[0] > nums[mid]， 说明是右半边有序\n\n\n```\n\n","timestamp":1694699764227},{"name":"03-找出第一个大于目标元素的索引.md","path":"002-数据结构与算法/001-数组/03-二分查找/03-找出第一个大于目标元素的索引.md","content":"### [找出第一个大于目标元素的索引](https://leetcode.cn/problems/search-insert-position/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-69ao/)\n\n```\n有序数中找\nnums = {1,3,5,5,6,6,8,9,11} target = 7\n```\n\n![二分查找模糊边界目标值](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/30/1721011682846461168284646153432irJ3-1608987488-NLxOHm-file_1608987488140.png)\n\n```java\npublic static int lowBoundnum(int[] nums,int target,int left, int right) {\n\n        while (left <= right) {\n            //求中间值\n            int mid = left + ((right - left) >> 1);\n            //大于目标值的情况\n            if (nums[mid] > target) {\n                 //返回 mid\n                if (mid == 0 || nums[mid-1] <= target) {\n                    return mid;\n                }\n                else{\n                    right = mid -1;\n                }\n\n            } else if (nums[mid] <= target){\n                left = mid + 1;\n            }\n        }\n        //所有元素都小于目标元素\n        return -1;\n    }\n\n作者：yuan-chu-de-suan-fa-xiao-wu\n链接：https://leetcode.cn/problems/search-insert-position/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-69ao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","timestamp":1694699764227},{"name":"04-找出最后一个小于目标元素的索引.md","path":"002-数据结构与算法/001-数组/03-二分查找/04-找出最后一个小于目标元素的索引.md","content":"### **找出最后一个小于目标元素的索引**\n\n```java\npublic static int upperBoundnum(int[] nums,int target,int left, int right) {\n\n        while (left <= right) {\n\n            int mid = left + ((right - left) >> 1);\n             //小于目标值\n            if (nums[mid] < target) {\n                //看看是不是当前区间的最后一位，如果当前小于，后面一位大于，返回当前值即可\n                if (mid == right || nums[mid+1] >= target) {\n                    return mid;\n                } else {\n                    left = mid + 1;\n                }\n\n            } else if (nums[mid] >= target) {\n                right = mid - 1;\n            }\n        }\n        //没有查询到的情况\n        return -1;\n    }\n\n作者：yuan-chu-de-suan-fa-xiao-wu\n链接：https://leetcode.cn/problems/search-insert-position/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-69ao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","timestamp":1694699764227},{"name":"05-34. 在排序数组中查找元素的第一个和最后一个位置.md","path":"002-数据结构与算法/001-数组/03-二分查找/05-34. 在排序数组中查找元素的第一个和最后一个位置.md","content":"\n\n### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n#### 二分\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int low = getLeftBound(nums, target);\n        int upper = getRightBound(nums, target);\n        if(upper < low) return new int[]{-1, -1};\n\n        return new int[]{low, upper};\n    }\n\n    // 计算下边界 \n    public int getLeftBound(int[] nums, int target) {\n        int l = 0; \n        int r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] >= target) {\n                r = mid - 1;\n            } else if(nums[mid] < target){\n                l = mid + 1;\n            }\n        }\n\n        return l;   // 考虑为什么返回l而不是r？\n    }\n\n    // 计算上编辑\n    public int getRightBound(int[] nums, int target) {\n        int l = 0; \n        int r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] > target) {\n                r = mid - 1;\n            } else if(nums[mid] <= target){\n                l = mid + 1;\n            }\n        }\n\n      \t// return nums[r] == target ? r : -1; 错误写法，r可能已经越界 如[1] 0\n        return r;   \n    }\n}\n```\n\n#### 双指针\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        if(nums.length == 0) return new int[]{-1, -1};\n\n        int l = 0; \n        int r = nums.length - 1;\n        while(l < r && nums[l] != target) l++;\n        while(l < r && nums[r] != target) r--;\n        if(l == r && nums[l] != target) return new int[]{-1, -1};\n\n        return new int[]{l, r};\n    }\n}\n```\n\n#### 二分+双指针\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int l = 0; \n        int r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] == target) {\n                int left = mid;\n                int right = mid;\n                while(left >= 0 && nums[left] == target) left--;\n                while(right < nums.length && nums[right] == target) right++;\n                return new int[]{left + 1, right - 1};\n            } else if(nums[mid] > target) {\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return new int[]{-1, -1};\n    }\n}\n```\n\n\n\n\n\n相同题：[剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)\n\n```\n统计一个数字在排序数组中出现的次数。\n\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n```\n\n","timestamp":1694699764227},{"name":"06-35. 搜索插入位置.md","path":"002-数据结构与算法/001-数组/03-二分查找/06-35. 搜索插入位置.md","content":"\n\n#### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)\n\n[]写法\n\n```java\npublic int searchInsert(int[] nums, int target) {\n  int low = 0; \n  int high = nums.length - 1; // 定义target在左闭右闭的区间里，[left, right]\n  while(low <= high) { // 当left==right，区间[left, right]依然有效\n    int mid = low + ((high - low) >> 1);\n    if(nums[mid] > target) {\n      high = mid - 1; // target 在左区间，所以[left, middle - 1]\n    } else if(nums[mid] < target) {\n      low = mid + 1; // target 在右区间，所以[middle + 1, right]\n    } else { // nums[middle] == target\n      return mid;\n    }\n  }\n  // 分别处理如下四种情况\n  // 目标值在数组所有元素之前  [0, -1]\n  // 目标值等于数组中某一个元素  return middle;\n  // 目标值插入数组中的位置 [left, right]，return  right + 1\n  // 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1\n  return high + 1;\t\t// return left也行\n}\n```\n\n[)写法\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0; \n        int r = nums.length;\n        while(l < r) {\n            int mid = l + ((r - l) >> 1);\n            // System.out.println(\"mid: \" + nums[mid]);\n            if(nums[mid] == target) {\n                return mid;\n            } else if(nums[mid] < target) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n\n        return r;\t\t// 方式二：return l也行\n    }\n}\n```\n\n```c++\n[1,3,5,6], target = 2\n  \nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n = nums.size();\n        int left = 0;\n        int right = n; // 定义target在左闭右开的区间里，[left, right)  target\n        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间\n            int middle = left + ((right - left) >> 1);\n            if (nums[middle] > target) {\n                right = middle; // target 在左区间，在[left, middle)中\n            } else if (nums[middle] < target) {\n                left = middle + 1; // target 在右区间，在 [middle+1, right)中\n            } else { // nums[middle] == target\n                return middle; // 数组中找到目标值的情况，直接返回下标\n            }\n        }\n        // 分别处理如下四种情况\n        // 目标值在数组所有元素之前 [0,0)\n        // 目标值等于数组中某一个元素 return middle\n        // 目标值插入数组中的位置 [left, right) ，return right 即可\n        // 目标值在数组所有元素之后的情况 [left, right)，因为是右开区间，所以 return right\n        return right;\t\t\n    }\n};\n\n[1,3,5,6], target = 2\nmid: 5 => mid: 3 => mid: 1\n  \n[1,3,5,6], target = 7\nmid: 5 => mid: 6\n\n[1,3,5,6], target = 0\nmid: 5 => mid: 3 => mid: 1\n```\n\n","timestamp":1694699764227},{"name":"07-81. 搜索旋转排序数组 II.md","path":"002-数据结构与算法/001-数组/03-二分查找/07-81. 搜索旋转排序数组 II.md","content":"### [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)\n\n与[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)的区别：有重复元素\n\n```\n[1,0,1,1,1]\n0\n```\n\n写法1（为主）\n\n```java\nclass Solution {\n    public boolean search(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] == target) return true;\n            if(nums[l] == nums[mid]) {\t\t// 与T33的区别\n                l++;\n                continue;\n            }\n            if(nums[l] < nums[mid]) {\n                if(nums[l] <= target && target < nums[mid]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if(nums[mid] < target && target <= nums[r]) {   // (], mid已经判断过不是target\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\nhttps://leetcode.cn/problems/search-in-rotated-sorted-array-ii/solution/zai-javazhong-ji-bai-liao-100de-yong-hu-by-reedfan/\n```\n\n写法二\n\n```java\nclass Solution {\n    public boolean search(int[] nums, int target) {\n        int n = nums.length;\n        int l = 0;\n        int r = n - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            System.out.println(\"mid: \" + nums[mid]);\n            if(nums[mid] == target) return true;\n            if(nums[l] == nums[mid] && nums[mid] == nums[r]) {\n                l++;\n                r--;\n            } else if(nums[l] <= nums[mid]) {   // 左半边有序，右半边不一定有序\n                if(nums[l] <= target && target < nums[mid]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if(target > nums[mid] && target <= nums[n - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n```\n\n参考：官方题解\n","timestamp":1694699764227},{"name":"08-153. 寻找旋转排序数组中的最小值.md","path":"002-数据结构与算法/001-数组/03-二分查找/08-153. 寻找旋转排序数组中的最小值.md","content":"### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)\n\n```\n有序数组多次旋转，找最小值\n\n输入：nums = [3,4,5,1,2]\n输出：1\n解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n```\n\n\n\n```\n我们考虑数组中的最后一个元素x：\n- 在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 x；\n- 而在最小值左侧的元素，它们的值一定都严格大于 x。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。\n```\n\n\n\n第一种情况是pivot的值小于high值，这说明 `nums[pivot]`是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。（思考：能不能是因为pivot < low值？）\n\n![image-20230430202707458](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/30/20270716828576271682857627561i9OumE-image-20230430202707458.png)\n\n第二种情况是pivot的值大于high。这说明 `nums[pivot]`是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。\n\n![image-20230430202826683](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/30/20282616828577061682857706805qP4Oc2-image-20230430202826683.png)\n\n由于数组不包含重复元素，并且只要当前的区间长度不为 1，pivot就不会与high重合；\n\n而如果当前的区间长度为 1，这说明我们已经可以结束二分查找了。\n\n因此不会存在`nums[pivot]=nums[high]`的情况。\n\n当二分查找结束时，我们就得到了最小值所在的位置。\n\n```java\nclass Solution {\n    public int findMin(int[] nums) {\n        int l = 0;\n        int r = nums.length - 1;\n        while(l < r) {  // 不能是<=\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid]  < nums[r]) {\n                r = mid;  // 不能是mid-1，如nums[mid]就是最小值\n            } else {\n                l = mid + 1;    // nums[mid]一定不是最小值\n            }\n        }\n        return nums[l];\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-5irwp/)\n\n\n\n思考：情况1和情况2能不能考虑pivot和low值比较？\n\n```\n不能\n\n有序数组 [1 2 3 4 5]\n第一种情况成立，不会出现该情况\n第二种情况不成立，不能因为nums[pivot] > nums[l]就得出结论,最小值在右边\n\n```\n\n","timestamp":1694699764227},{"name":"09-154. 寻找旋转排序数组中的最小值 II.md","path":"002-数据结构与算法/001-数组/03-二分查找/09-154. 寻找旋转排序数组中的最小值 II.md","content":"### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n数组有重复值\n\n\n\n```\n考虑\n[1,3,3]\n[0,1,1,1,2,2]\n```\n\n\n\n#### 写法1（主要）\n\n```\nclass Solution {\n    public int findMin(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while(l < r) {\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] > nums[r]) {\n                l = mid + 1;\n            } else if(nums[mid] < nums[r]){\n                r = mid;\n            } else {\n                r--;\n            }\n        }\n\n        return nums[l];\n    }\n}\n```\n\n\n\n#### 写法2\n\n```java\nclass Solution {\n    public int findMin(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while(l < r) {\n            while(l < r && r > 0 && nums[r] == nums[r - 1]) r--;\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] >= nums[r]) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n\n        return nums[l];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"10-704. 二分查找.md","path":"002-数据结构与算法/001-数组/03-二分查找/10-704. 二分查找.md","content":"### #### [704. 二分查找](https://leetcode.cn/problems/binary-search/)\n\n#### 递归\n\n```java\npublic static int binarySearch(int[] nums,int target,int left, int right) {\n        \n        if (left <= right) {\n            int mid = left + ((right - left) >> 1);\n            if (nums[mid] == target) {\n                //查找成功\n                return  mid;\n            }else if (nums[mid] > target) {\n                //新的区间,左半区间\n                return binarySearch(nums,target,left,mid-1);\n            }else if (nums[mid] < target) {\n                //新的区间，右半区间\n                return binarySearch(nums,target,mid+1,right);\n            }\n        }\n        //不存在返回-1\n        return -1;\n    }\n\n链接：https://leetcode.cn/problems/search-insert-position/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-69ao/\n```\n\n#### 迭代\n\n```\n\n```\n\n","timestamp":1694699764227},{"name":"01-总结.md","path":"002-数据结构与算法/001-数组/04-二维数组遍历/01-总结.md","content":"https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/er-wei-shu-150fb/","timestamp":1694699764227},{"name":"02-48. 旋转图像.md","path":"002-数据结构与算法/001-数组/04-二维数组遍历/02-48. 旋转图像.md","content":"### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n\n        // 对角线翻转\n        for(int i = 0; i < rows; i++) {\n            for(int j = i + 1; j < cols; j++) {\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = tmp;\n            }\n        }\n\n        // 竖直翻转\n        for(int i = 0; i < rows; i++) {\n            int l = 0, r = cols - 1;\n            while(l < r) {\n                int tmp = matrix[i][l];\n                matrix[i][l] = matrix[i][r];\n                matrix[i][r] = tmp;\n                l++;\n                r--;\n            }\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"03-54. 螺旋矩阵.md","path":"002-数据结构与算法/001-数组/04-二维数组遍历/03-54. 螺旋矩阵.md","content":"### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)\n\n```\nclass Solution {\n    public int[] spiralOrder(int[][] matrix) {\n        if(matrix.length == 0 || matrix[0].length == 0) return new int[]{};\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n\n        int[] res = new int[rows * cols];\n        int index = 0;\n\n        int t = 0, b = rows - 1, l = 0, r = cols - 1;\n        while(t <= b && l <= r) {\n            if(t <= b) {    // 保证上下没有越界\n                for(int i = l; i <= r; i++) {   // 保证左右没有越界\n                    res[index++] = matrix[t][i];\n                }\n                t++;\n            }\n\n            if(l <= r) {\n                for(int i = t; i <= b; i++) {\n                    res[index++] = matrix[i][r];\n                }\n                r--;\n            }\n\n            if(t <= b) {\n                for(int i = r; i >= l; i--) {\n                    res[index++] = matrix[b][i];\n                }\n                b--;\n            }\n\n            if(l <= r) {\n                for(int i = b; i >= t; i--) {\n                    res[index++] = matrix[i][l];\n                }\n                l++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"04-59. 螺旋矩阵 II.md","path":"002-数据结构与算法/001-数组/04-二维数组遍历/04-59. 螺旋矩阵 II.md","content":"### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)\n\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] res = new int[n][n];\n\n        int t = 0, b = n - 1;\n        int l = 0, r = n - 1;\n        int num = 1;\n        while(num <= n * n) {\n            if(t <= b) {\n                for(int i = l; i <= r; i++) {\n                    res[t][i] = num++;\n                }\n                t++;\n            }\n\n            if(l <= r) {\n                for(int i = t; i <= b; i++) {\n                    res[i][r] = num++;\n                }\n                r--;\n            }\n\n            if(t <= b) {\n                for(int i  = r; i >= l; i--) {\n                    res[b][i] = num++;\n                }\n                b--;\n            }\n\n            if(l <= r) {\n                for(int i = b; i >= t; i--) {\n                    res[i][l] = num++;\n                }\n                l++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-209.长度最小的子数组.md","path":"002-数据结构与算法/001-数组/100-209.长度最小的子数组.md","content":"### 209.长度最小的子数组\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int l = 0;\n        int r = 0;\n        int sum = 0;\n        int res = Integer.MAX_VALUE;\n        while(r < nums.length) {\n            sum += nums[r];\n\n            while(sum >= target) {\n                res = Math.min(res, r - l + 1);\n                sum -= nums[l];\n                l++;\n            }\n            r++;\n        }\n\n        return res == Integer.MAX_VALUE ? 0 : res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"101-367. 有效的完全平方数.md","path":"002-数据结构与算法/001-数组/101-367. 有效的完全平方数.md","content":"### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)\n\n\n\n```java\nclass Solution {\n    public boolean isPerfectSquare(int num) {\n        int l = 0; \n        int r = num;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            long square = (long) mid * mid;\n            if(square == num) {\n                return true;\n            } else if(square < num) {\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n\n        return false;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"102-69. x的平方根.md","path":"002-数据结构与算法/001-数组/102-69. x的平方根.md","content":"### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)\n\n#### 方法：二分\n\n```\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0;\n        int r = x;\n        int mid = 0;\n        while(l <= r) {\n            mid = l + ((r - l) >> 1);\n            if((long)mid*mid == x) {\n                return mid;\n            } else if((long)mid*mid < x) {\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n\n        return mid * mid > x ? mid - 1 : mid;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"103-双指针.md","path":"002-数据结构与算法/001-数组/103-双指针.md","content":"#### [27. 移除元素](https://leetcode.cn/problems/remove-element/)\n\n##### 解法一：双指针\n\n```java\n    public int removeElement(int[] nums, int val) {\n        int low = 0;\n        int high = nums.length - 1;\n        while(low <= high) {\n            if(nums[low] == val) {\n                int tmp = nums[low];\n                nums[low] = nums[high];\n                nums[high] = tmp;\n                high--;\n            } else {\n                low ++;\n            }\n        }\n        return low;\n    }\n```\n\n优化：不需要保存=val的nums[low]\n\n```java\n    public int removeElement(int[] nums, int val) {\n        int low = 0;\n        int high = nums.length - 1;\n        while(low <= high) {\n            if(nums[low] == val) {\n                nums[low] = nums[high];\n                high--;\n            } else {\n                low ++;\n            }\n        }\n        return low;\n    }\n```\n\n##### 解法二：快慢指针\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        // 快慢指针\n        int fastIndex = 0;\n        int slowIndex;\n        for (slowIndex = 0; fastIndex < nums.length; fastIndex++) {\n            if (nums[fastIndex] != val) {\n                nums[slowIndex] = nums[fastIndex];\n                slowIndex++;\n            }\n        }\n        return slowIndex;\n    }\n}\n```\n\n[题解](https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#_27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0)\n\n\n\n#### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)\n\n**解题思路 - 双指针**：\n\n数组有序，重复元素一定相邻。\n\n删除重复元素 => 将不重复元素移到数组左侧。\n\n考虑双指针：慢指针low 快指针fast\n\n比较low 和 fast位置上的元素\n\n- 如果相等 fast++ （即找到第一个不重复的元素）\n- 如果不等，low++，将fast位置的元素复制到low上，fast++\n\n重复，直到q等于数组长度\n\n返回low + 1，即为新数组长度\n\n```java\npublic int removeDuplicates(int[] nums) {\n  if(nums == null || nums.length == 0) return 0;\n  int low  = 0;\n  int fast = 1;\n  while(fast < nums.length) {\n    if(nums[low] != nums[fast]) {\n      nums[++low] = nums[fast];\n    }\n    fast++;\n  }\n  return low + 1;\n}\n```\n\n**优化**\n\n如果没有重复元素，每次都需要原地替换\n\n```java\npublic int removeDuplicates(int[] nums) {\n  if(nums == null || nums.length == 0) return 0;\n  int low  = 0;\n  int fast = 1;\n  while(fast < nums.length) {\n    if(nums[low] != nums[fast]) {\n      low++;\n      if(low != fast) {\n        nums[low] = nums[fast];\n      }\n    }\n    fast++;\n  }\n  return low + 1;\n}\n```\n\n[题解](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/)\n\n\n\n#### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)\n\n**解题思路**\n\n双指针\n\nlow指向首个0元素下标，fast找到第1个非0元素，与low交换，low++。\n\n```java\npublic void moveZeroes(int[] nums) {\n        if(nums == null && nums.length == 0) return;\n        int low = 0, fast = 0;\n        while(fast < nums.length) {\n            if(nums[fast] != 0) {\n                int tmp = nums[low];\n                nums[low] = nums[fast];\n                nums[fast] = tmp;\n                low++;\n            }\n            fast++;\n        }\n    } \n```\n\n\n\n\n\n#### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)\n\n##### **错解**\n\n双指针，p1=0， p2=0，依次比较字符是否相等，如果不相等看下一位是否为‘#’\n\n没有考虑存在s = \"ab##\", t = \"c#d#\"\n\n也没考虑s，t不是等长的情况\n\n```java\n    public boolean backspaceCompare(String s, String t) {\n        int p1 = 0;\n        int p2 = 0;\n        while(p1 < s.length() && p2 < t.length()) {\n            if(s.charAt(p1) != t.charAt(p2)) {\n                if(p1 + 1 >= s.length() || p2 + 1 >= t.length()) {\n                    return false;\n                } \n                if(s.charAt(p1+1) != \'#\' || t.charAt(p2+1) != \'#\') {\n                    return false;\n                }\n            }\n            p1++;\n            p2++;\n        }\n        return true;\n    }\n```\n\n##### 解法一：双指针\n\n一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。\n\n从前往后遍历，不太好确定有多少个字符需要被删掉。\n\n从后往前遍历，分别找到第一个需要比较的字符\n\n- 若是#， 则skip++\n- 若不是#\n  - 若skip > 0, skip--；\n  - 若skip = 0, 则找到要比较的字符；\n\n```java\n public boolean backspaceCompare(String s, String t) {\n        int i = s.length() - 1;\n        int j = t.length() - 1;\n        int skip1 = 0;\n        int skip2 = 0;\n        while(i >= 0 || j >= 0) {\n            // 找到s要比较的字符串\n            while(i >= 0) {\n                if(s.charAt(i) == \'#\') {\n                    skip1++;\n                    i--;\n                } else if(skip1 > 0) {\n                    skip1--;\n                    i--;\n                } else {\n                    break;\n                }\n            }\n\n            // 找到t要比较的字符串\n            while(j >= 0) {\n                if(t.charAt(j) == \'#\') {\n                     skip2++;\n                     j--;\n                } else if(skip2 > 0) {\n                    skip2--;\n                    j--;\n                } else {\n                    break;\n                }\n            }\n            if(i >= 0 && j >= 0) {\n                if(s.charAt(i) != t.charAt(j)) {\n                    return false;\n                }\n            } else {\n                if(i >=0 || j >= 0) {\n                    return false;\n                }\n            }\n            i--;\n            j--;\n        }\n        return true;\n    }\n```\n\n[参考](https://leetcode.cn/problems/backspace-string-compare/solution/shuang-zhi-zhen-bi-jiao-han-tui-ge-de-zi-8fn8/)\n\n##### 解法二：重构字符串\n\n```java\nclass Solution {\n    public boolean backspaceCompare(String S, String T) {\n        return build(S).equals(build(T));\n    }\n\n    public String build(String str) {\n        StringBuffer ret = new StringBuffer();\n        int length = str.length();\n        for (int i = 0; i < length; ++i) {\n            char ch = str.charAt(i);\n            if (ch != \'#\') {\n                ret.append(ch);\n            } else {\n                if (ret.length() > 0) {\n                    ret.deleteCharAt(ret.length() - 1);\n                }\n            }\n        }\n        return ret.toString();\n    }\n}\n\n作者：LeetCode-Solution\n链接：https://leetcode.cn/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n#### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n\n##### 错解\n\n双指针，最大值一定在两端，\n\n仅考虑了[负数 0 正数]的情况，当数组全为负数的时候，错误\n\n```java\n    public int[] sortedSquares(int[] nums) {\n        int len = nums.length;\n        if(nums == null || len == 0) return nums;\n        // 平方\n        for(int i = 0; i < len; i++) {\n            nums[i] = (int)Math.pow(nums[i], 2);\n        }\n        // 双指针排序\n        int low = 0, high = len - 1;\n        while(low < high) {\n            if(nums[high] >= nums[low]) {\n                high--;\n                continue;\n            } else {\n                swap(nums, low, high);\n                high--;\n            }\n        }\n        return nums;\n    }\n```\n\n##### 解法一：双指针\n\n空间复杂度O(n)\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        int n = nums.length;\n        int[] ans = new int[n];\n        for (int i = 0, j = n - 1, pos = n - 1; i <= j;) {\n            if (nums[i] * nums[i] > nums[j] * nums[j]) {\n                ans[pos] = nums[i] * nums[i];\n                ++i;\n            } else {\n                ans[pos] = nums[j] * nums[j];\n                --j;\n            }\n            --pos;\n        }\n        return ans;\n    }\n}\n```\n\n[参考](https://programmercarl.com/0977.有序数组的平方.html#双指针法)\n\n错解\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        int l = 0;\n        int r = nums.length - 1;\n        while(l <= r) {\n            if(nums[r]*nums[r] < nums[l]*nums[l]) {\n                swap(nums, l, r);\n            }\n            nums[r] = nums[r] * nums[r];\n            System.out.println(nums[r]);\n            r--;\n        }\n\n        return nums;\n    }\n\n    void swap(int[] nums, int a, int b) {\n        int tmp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = tmp;\n    }\n}\n\n// [-5,-3,-2,-1]\nOutput： [1,9,4,25]\nExpected： [1,4,9,25]\n```\n\n\n\n#### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n##### 方法一：暴力解法\n\n从头开始遍历，以每个元素为起点，寻找符合条件的子序列\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int minLen = Integer.MAX_VALUE;  // 结果\n        for(int i = 0; i < nums.length; i++) {\n            int sum = 0;\t// 子序列之和\n            for(int j = i; j < nums.length; j++) {\n                sum += nums[j];\n                if(sum >= target) {\n                    minLen = Math.min(minLen, j - i + 1);\n                    break;\n                }\n            }\n        }\n        return minLen == Integer.MAX_VALUE ? 0 : minLen;\n    }\n}\n```\n\n问题：数组长度很大时超时\n\n[参考](https://programmercarl.com/0209.长度最小的子数组.html#暴力解法)\n\n##### 方法二：双指针-滑动窗口\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int minLen = Integer.MAX_VALUE;\n        int i = 0, j = 0;\t// 滑动窗口左、右指针\n        int sum = 0;  // i ~ j 之间的和\n        while(j < nums.length) {\n            sum += nums[j];\n            while(sum >= target) {\t// 尽可能右移左指针\n                minLen = Math.min(minLen, j - i + 1);\n                sum -= nums[i];\n                i++;\n            }\n            j++;\n        }\n        return minLen == Integer.MAX_VALUE ? 0 : minLen;\n    }\n}\n```\n\n[参考](https://programmercarl.com/0209.长度最小的子数组.html#相关题目推荐)\n\n\n\n#### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)\n\n从左至右，从上到下，从右到左，从下到上，每次以左闭右开的原则赋值，循环。\n\n![螺旋矩阵](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/07/09/105224165733514416573351443552eUM3g-2020121623550681.png)\n\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] res = new int[n][n];\n        int loop = 0;    // 循环次数\n        int start = 0;   // 每次循环的开始点(start, start)\n        int count = 1;   // 定义填充数字\n        int i, j;\n\n        while(loop++ < n / 2) {  // 判断边界后，loop从1开始\n            // 上侧 左=>右 y轴start不变\n            for(i = start; i < n - loop; i++) {\n                res[start][i] = count++;\n            }\n            // 右侧 上=>下 x轴j不变\n            for(j = start; j < n - loop; j++) {\n                res[j][i] = count++;\n            }\n            // 下侧 右=>左 y轴j不变\n            for(; i >= loop; i--) {\n                res[j][i] = count++;\n            }\n            // 左侧 下=>上 x轴i不变\n            for(; j >= loop; j--) {\n                res[j][i] = count++;\n            }\n            start++;\n        }\n        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值\n        if(n % 2 == 1) {\n            res[start][start] = count;\n        }\n        return res;\n    }\n}\n```\n\n[题解](https://programmercarl.com/0059.螺旋矩阵II.html#_59-螺旋矩阵ii)","timestamp":1694699764227},{"name":"01-移除链表元素.md","path":"002-数据结构与算法/002-链表/01-移除链表元素.md","content":"## 移除链表元素\n\n#### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)\n\n##### 方法一：迭代\n\n首先找到第一个不为val的头节点，然后设置一个虚拟头节点pre.next = head，用pre来遍历删除元素，最后返回head\n\n```java\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        while(head != null && head.val == val) {\n            head = head.next;\n        }\n        ListNode pre = new ListNode(Integer.MAX_VALUE);\n        pre.next = head;\n        while(pre.next != null) {\n            if(pre.next.val == val) {\n                pre.next = pre.next.next;\n            } else {\n                pre = pre.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n优化\n\n```java\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode temp = dummyHead;\n        while (temp.next != null) {\n            if (temp.next.val == val) {\n                temp.next = temp.next.next;\n            } else {\n                temp = temp.next;\n            }\n        }\n        return dummyHead.next;\n    }\n}\n```\n\n还可以优化，直接将head当作tmp，少声明一个变量\n\n\n\n##### 方法二：递归\n\n```java\npublic ListNode removeElements(ListNode head, int val) {\n\tif(head == null) {\n    return head;\n\t}\n  head.next = removeElements(head.next, val);\n  return head.val == val ? head.next : head;\n}\n```\n\n\n\n","timestamp":1694699764227},{"name":"02-反转链表.md","path":"002-数据结构与算法/002-链表/02-反转链表.md","content":"### 方法一： 虚拟头节点+尾指针+头插\n\n思路：采用虚拟头节点dummyHead，尾指针tail记录反转好的尾节点，每次将tail的下一个节点前插到head之前（即dummyHead之后），直到tail的下一个节点为null\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null) return head;\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode tail = head; // 反转后的尾部\n        // 每次将cur插到ç\n        ListNode cur = tail.next;\n        while(cur != null) {\n            // 处理cur的next节点\n            tail.next = cur.next;\n\n            // cur插到dummyHead后\n            cur.next = dummyHead.next;\n            dummyHead.next = cur;\n\n            // 更新head 和 tail\n            head = cur;\n            cur = tail.next;\n        }\n        return dummyHead.next;\n    }\n}\n```\n\n\n\n### 方法二：双指针\n\n```java\npublic ListNode reverseList(ListNode head) {\n    if(head == null) return head;\n    ListNode pre = null;\n    ListNode cur = head;\n    ListNode tmp;\n  \twhile(cur != null) {\t\n\t\t\t\ttmp = cur.next;\n\n        // 翻转\t\n        cur.next = pre;\n\n        // 前移\n        pre = cur;\n        cur = tmp;\n    }\n  \treturn pre;\n}\n```\n\n递归\n\n```java\n    public ListNode reverseList(ListNode head) {\n        return reverse(null, head);\n    }\n\n    public ListNode reverse(ListNode pre, ListNode cur) {\n        if(cur==null) {\n            return pre;\n        }\n        ListNode tmp = cur.next;\n        cur.next = pre;\n\n        // 更新pre，cur位置\n        // pre = cur;\n        // cur = tmp;\n        // return reverse(pre, cur);\n\n        // 等效\n        return reverse(cur, tmp);\n    }\n\t\n\t\n```\n\n","timestamp":1694699764227},{"name":"03-两两交换链表中的节点.md","path":"002-数据结构与算法/002-链表/03-两两交换链表中的节点.md","content":"#### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n\n##### 方法1: 虚拟头节点 + 双指针\n\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null) return head;\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n\n        ListNode cur = head;\n        ListNode next;\n        ListNode pre = dummyHead;\n        while(cur != null && cur.next != null) {\n            next = cur.next;\n\n            cur.next = next.next;\n            pre.next = next;\n            next.next = cur;\n\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummyHead.next;\n    }\n}\n```\n\n优化： cur节点可以省略，用pre.next代替\n\n[参考](https://programmercarl.com/0024.两两交换链表中的节点.html#思路)","timestamp":1694699764227},{"name":"04-删除链表倒数第n个节点.md","path":"002-数据结构与算法/002-链表/04-删除链表倒数第n个节点.md","content":"#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n##### 方法一：虚拟头节点 + 双指针\n\n思路：双指针low 、 fast，fast与low相隔n-1个节点，即fast遍历到末尾时，low会指向目标节点的前一个节点。\n\n![image-20220726103542110](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/07/26/10354216588029421658802942229c0pEfc-image-20220726103542110.png)\n\nfast.next=null时遍历结束，fast指向5，low指向3，然后删除节点\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n\n        ListNode low = dummyHead; // 删除节点的前一个节点\n        ListNode fast = dummyHead; // 尾指针，与low节点相隔n-1个节点\n        while(n-- > 0) {\n            fast = fast.next;\n        }\n        while(fast.next != null) {\n            low = low.next;\n            fast = fast.next;\n        }\n\n        // 移除节点\n        low.next = low.next.next;\n\n        return dummyHead.next;\n    }\n}\n```\n\ngo\n\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    dummyHead := &ListNode{}\n    dummyHead.Next = head\n    low, fast := dummyHead, dummyHead\n    for ; n > 0; n-- {\n        if fast.Next != nil {\n            fast = fast.Next\n        }\n    }\n\n    for fast.Next != nil {\n        low = low.Next\n        fast = fast.Next\n    }\n\n    // 删除\n    low.Next = low.Next.Next\n\n    return dummyHead.Next\n}\n```\n\n","timestamp":1694699764227},{"name":"05-链表相交.md","path":"002-数据结构与算法/002-链表/05-链表相交.md","content":"#### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)\n\n##### 方法一： 双指针\n\n```\n双指针a 、b分别指向两条链遍历，a链后边接b链，b链后接a链\n即A： 4 1 8 4 5 5 0 1 8 4 5\n  B: 5 0 1 8 4 5 4 1 8 4 5\n```\n\n![image-20220726113458154](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/07/26/113458165880649816588064982810stJaQ-image-20220726113458154.png)\n\n注意，判断是不是交点，不是判断val是否相等，需要判断指针是不是想等，否则比到A : 4 1 8 4 5 5 时会返回5，提前结束\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) {\n            return null;\n        }\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while(a != b) {\n            if(a.next == null && b.next == null) {\n                return null;\n            }\n            a = a.next == null ? headB : a.next;\n            b = b.next == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n\n优化\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) {\n            return null;\n        }\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while(a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n\n**go**\n\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    if headA == nil || headB == nil {\n        return nil\n    }\n    \n    p1, p2 := headA, headB\n    for p1 != p2 {\n        if p1.Next == nil && p2.Next == nil {\n            return nil\n        }\n\n        if p1.Next != nil {\n            p1 = p1.Next\n        } else {\n            p1 = headB\n        }\n\n        if p2.Next != nil {\n            p2 = p2.Next\n        } else {\n            p2 = headA\n        }\n    }\n\n    return p1\n\n}\n```\n\n 优化\n\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { \n    p1, p2 := headA, headB\n    for p1 != p2 {\n        if p1 == nil && p2 == nil {\n            return nil\n        }\n\n        if p1 != nil {\n            p1 = p1.Next\n        } else {\n            p1 = headB\n        }\n\n        if p2 != nil {\n            p2 = p2.Next\n        } else {\n            p2 = headA\n        }\n    }\n\n    return p1\n\n}\n```\n\n","timestamp":1694699764227},{"name":"06-环型链表.md","path":"002-数据结构与算法/002-链表/06-环型链表.md","content":"#### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)\n\n##### 解法一：快慢指针\n\n思路：快慢指针slow、fast，慢指针每次走一格，fast每次走两格，如果相遇那么有环。\n\n相遇后，fast指向头节点，slow和fast每次走一格，相遇点就是入口\n\n![image-20220727110520698](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/07/27/11052016588911201658891120845pu2LYP-image-20220727110520698.png)\n\nA 点是入口, B是相遇的地方\n\n```\nslow = x + y\nfast = x + y + n(y + z)  // fast转了n圈与slow相遇，且n>=1\n\nslow * 2 =  fast\n2(x+y) = x + y + n(y + z)\n\n=> x = n(y + z) - y\n=> x = (n - 1)(y + z) + z // 走n-1圈后再走z 等与 x\n取特值n=1 x=z\n\n```\n\n问题：为什么slow 不等于 x + y + n(y + z)\n\n![image-20220727111706101](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/07/27/11170616588918261658891826202wGr44S-image-20220727111706101.png)\n\nfast先进入环，slow再进入, 假设slow走了一圈到A3，那么fast会走slow两倍的距离，此时一定会在A2与A3之间相遇\n\n\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode low = head;\n        ListNode fast = head;\n        while(fast != null && fast.next != null) {\n            low = low.next;\n            fast = fast.next.next;\n            // 有环\n            if(fast == low) {\n                fast = head;\n                while(fast != low) {\n                    fast = fast.next;\n                    low = low.next;\n                }\n                return low;\n            }\n        }\n\n        return null;\n    }\n}\n```\n\n\n\n[参考](https://programmercarl.com/0142.环形链表II.html#其他语言版本)\n\n\n\ngo\n\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    low, fast := head, head\n    for fast != nil && fast.Next != nil {\n        low = low.Next\n        fast = fast.Next.Next\n\n        // 有环\n        if low == fast {\n\n            // 找入口\n            fast = head\n            for fast != low {\n                fast = fast.Next\n                low = low.Next\n            }\n            return low\n        }\n    }\n    return nil\n}\n```\n\n","timestamp":1694699764227},{"name":"07-翻转链表系列.md","path":"002-数据结构与算法/002-链表/07-翻转链表系列.md","content":"https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/\n\n### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)\n\n翻转整个链表\n\n#### 方法一：迭代\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        ListNode next = null;\n        while(cur != null) {\n            next = cur.next;\n            cur.next = pre;\n\n            pre = cur;\n            cur = next;\n        }\n\n        return pre;\n    }\n}\n```\n\n#### 方法二：递归\n\n注意不要带入递归中，把递归的部分看成一个整体\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/02/11/14384916760975291676097529032uZlQdc-image-20230211143848936.png\" alt=\"image-20230211143848936\" style=\"zoom:50%;\" />\n\n`reverse(head.next)` 执行完成后，整个链表就成了这样：\n\n<img src=\"/Users/kuan/Library/Application%20Support/typora-user-images/image-20230211143926815.png\" alt=\"image-20230211143926815\" style=\"zoom:50%;\" />\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {   \n        if(head == null || head.next == null) return head;\n        ListNode newHead = reverseList(head.next);\n        head.next.next = head;\t// 2的next指向1\n        head.next = null;\t\t\t\t// 1的next指向null\n        \n        return newHead;\n    }\n}\n```\n\n\n\n### 翻转链表前n个节点\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/03/233044169375504416937550445384CZ7tG-image-20230211150229814.png\" alt=\"image-20230211150229814\" style=\"zoom:50%;\" />\n\n<img src=\"/Users/kuan/Library/Application%20Support/typora-user-images/image-20230211150404129.png\" alt=\"image-20230211150404129\" style=\"zoom:50%;\" />\n\n```java\nListNode successor = null; // 后驱节点\n\n// 反转以 head 为起点的 n 个节点，返回新的头结点\nListNode reverseN(ListNode head, int n) {\n    if (n == 1) {\n        // 记录第 n + 1 个节点\n        successor = head.next;\n        return head;\n    }\n    // 以 head.next 为起点，需要反转前 n - 1 个节点\n    ListNode last = reverseN(head.next, n - 1);\n\n    head.next.next = head;\n    // 让反转之后的 head 节点和后面的节点连起来\n    head.next = successor;\n    return last;\n}\n```\n\n\n\n### [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)\n\n翻转指定区间[left, right]的链表\n\n#### 方法一：\n\n找到left的前一个节点，剩余节点即【翻转链表的前n个节点】\n\n```java\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if(left == right) return head;\n        if(head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n\n        ListNode pre = dummy;\n        for(int i = 1; i < left; i++) {\n            pre = pre.next;\n        }\n\n        System.out.print(pre.val);\n\n        ListNode p = pre.next;\n\n        ListNode last = reverse(p.next, right - left);\n        p.next.next = p;\n        p.next = successor;\n\n        pre.next = last;\n        return dummy.next;\n    }\n\n    ListNode successor = null; // 后驱节点  \n    public ListNode reverse(ListNode head, int n) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        if(n == 1) {\n            successor = head.next;\n            return head;\n        }\n        ListNode last = reverse(head.next, n-1);\n        head.next.next = head;\n        head.next = successor;\n        return last;\n    }\n}\n```\n\n#### 方法二\n\n首先，如果 `m == 1`，就相当于反转链表开头的 `n` 个元素\n\n如果 `m != 1` 怎么办？如果我们把 `head` 的索引视为 1，那么我们是想从第 `m` 个元素开始反转对吧；如果把 `head.next` 的索引视为 1 呢？那么相对于 `head.next`，反转的区间应该是从第 `m - 1` 个元素开始的；那么对于 `head.next.next` 呢……\n\n```\n链表为1 2 3 4 5， left = 2, right = 4, 即要翻转2 3 4\nhead.next的索引视为 1时，链表相当于（1）2 3 4 5, 此时要翻转2 3 4，则left = 1， right = 3\n```\n\n```java\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if(left == 1) return reverse(head, right);\n        head.next = reverseBetween(head.next, left - 1, right - 1);\n        return head;\n    }\n\n    ListNode successor = null; // 后驱节点  \n    public ListNode reverse(ListNode head, int n) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        if(n == 1) {\n            successor = head.next;\n            return head;\n        }\n        ListNode last = reverse(head.next, n-1);\n        head.next.next = head;\n        head.next = successor;\n        return last;\n    }\n}\n```\n\n\n\n### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)\n\nhttps://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/ru-he-k-ge-d591d/\n\n```java\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if(head == null) return head;\n        ListNode a = head;\n        ListNode b = head;\n        for(int i = 0; i < k; i++) {\n            if(b == null) return head;\t// 不是k的整数倍不用翻转\n            b = b.next;\n        }\n\n        ListNode newHead = reverse(a, b);\n        a.next = reverseKGroup(b, k);\n        return newHead;\n    }\n\n    // 翻转区间 [a, b)\n    public ListNode reverse(ListNode a, ListNode b) {\n        ListNode cur = a, pre = null, next = null;\n        while(cur != b) {\t  // 与翻转整个区间的区别\n            next = cur.next;\n            cur.next = pre;\n            \n            pre = cur;\n            cur = next;\n        }\n\n        return pre;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-242.有效的字母异位词.md","path":"002-数据结构与算法/003-哈希表/01-242.有效的字母异位词.md","content":"#### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)\n\n```go\nfunc isAnagram(s string, t string) bool {\n    var c1, c2 [26]int\n    for _, ch := range s {\n        c1[ch - \'a\']++\n    }\n    for _, ch := range t {\n        c2[ch - \'a\']++\n    }\n    return c1 == c2\n}\n```\n\n\n\n","timestamp":1694699764227},{"name":"02-349. 两个数组的交集.md","path":"002-数据结构与算法/003-哈希表/02-349. 两个数组的交集.md","content":"```go\nfunc intersection(nums1 []int, nums2 []int) []int {\n    m := make(map[int]int)\n    for _, v := range nums1 {\n        m[v] = 1\n    }\n\n    var res []int\n    for _, v := range nums2 {\n        if count, ok := m[v]; ok && count > 0 {\n            res = append(res, v)\n            m[v]--\n        }\n    }\n\n    return res\n}\n```\n\n优化，利用set，减少count统计\n\n```\n\n```\n\n","timestamp":1694699764227},{"name":"03-202. 快乐数.md","path":"002-数据结构与算法/003-哈希表/03-202. 快乐数.md","content":"#### [202. 快乐数](https://leetcode.cn/problems/happy-number/)\n\n题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现**\n\n所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。\n\n```go\nfunc isHappy(n int) bool {\n    set := make(map[int]bool)\n    for n != 1 {\n        n = getNextNumber(n)\n        if set[n] {\n            return false\n        }\n        set[n] = true\n    }\n    return n == 1\n}\n\nfunc getNextNumber(n int) int {\n    sum := 0\n    for n > 0 {\n        sum += (n % 10) * (n % 10)\n        n /= 10\n    }\n    return sum\n}\n```\n\n","timestamp":1694699764227},{"name":"04-1.两数之和.md","path":"002-数据结构与算法/003-哈希表/04-1.两数之和.md","content":"map目的用来存放我们访问过的元素\n\nkey存需要的数，即target - 当前数\n\nvalue存当前数的在数组中的下标\n\n```go\nfunc twoSum(nums []int, target int) []int {\n    m := make(map[int]int)  // 需要的数：当前数的下标\n    for index, num := range nums {\n        value, ok := m[num]\n        if ok {\n            return []int{index, value}\n        }\n        m[target - num] = index\n    }\n    return []int{}\n}\n```\n\n","timestamp":1694699764227},{"name":"05-454. 四数相加 II.md","path":"002-数据结构与算法/003-哈希表/05-454. 四数相加 II.md","content":"**本题解题步骤：**\n\n1.  首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。\n2.  遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。\n3.  定义int变量count，用来统计 a+b+c+d = 0 出现的次数。\n4.  在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。\n5.  最后返回统计值 count 就可以了\n\n\n\n**为什么统计次数？**\n\n题目要求统计出现的总数，如果A，B 之和为2有两种情况，C，D之和有一个-2，那么就有两种组合情况\n\n```go\nfunc fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {\n    m := make(map[int]int) // key放a和b两数之和，value 放a和b两数之和出现的次数\n    cnt := 0 // a+b+c+d = 0 出现的次数\n\n    // 统计num1, num2 各元素之和及次数\n    for _, v1 := range nums1 {\n        for _, v2 := range nums2 {\n            if _, ok := m[v1 + v2]; ok {\n                m[v1 + v2]++ \n            } else {\n                m[v1 + v2] = 1\n            }\n        }\n    }\n\n    // \n    for _, v1 := range nums3 {\n        for _, v2 := range nums4 {\n            if value, ok := m[0 - (v1 + v2)]; ok {\n                cnt += value\n            }\n        }\n    }\n\n    return cnt\n}\n```\n\n","timestamp":1694699764227},{"name":"06-383. 赎金信.md","path":"002-数据结构与算法/003-哈希表/06-383. 赎金信.md","content":"#### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)\n\n-   常规题：遍历一遍B统计字符个数，再遍历一遍A\n-   字符类型为rune\n\n```go\nfunc canConstruct(ransomNote string, magazine string) bool {\n        m := make(map[rune]int)\n\n        for _, ch := range magazine {\n            if _, ok := m[ch]; ok {\n                m[ch]++\n            } else {\n                m[ch] = 1\n            }\n        }\n\n        for _, ch := range ransomNote {\n            if value, ok := m[ch]; ok && value > 0  {\n                m[ch]--\n            } else {\n                return false\n            }\n        }\n        return true\n}\n```\n\n其他\n\n```go\nfunc canConstruct(ransomNote string, magazine string) bool {\n    record := make([]int, 26)\n    for _, v := range magazine {\n        record[v-\'a\']++\n    }\n    for _, v := range ransomNote {\n        record[v-\'a\']--\n        if record[v-\'a\'] < 0 {\n            return false\n        }\n    }\n    return true\n}\n```\n\n","timestamp":1694699764227},{"name":"07-15. 三数之和.md","path":"002-数据结构与算法/003-哈希表/07-15. 三数之和.md","content":"\n\n## 知识点\n\n-   多维数组\n\n    -   声明`res := [][]int{}`\n\n    -   添加元素`res = append(res, []int{n1, n2, n3})`\n\n-   排序`sort.Ints(nums)`\n\n\n\n#### [15. 三数之和](https://leetcode.cn/problems/3sum/)\n\n方法一：排序 + 双指针\n\n```go\nfunc threeSum(nums []int) [][]int {\n    sort.Ints(nums)\n    res := [][]int{}\n\n    for i := 0; i < len(nums) - 2; i++ {\n        n1 := nums[i]\n\n        // 排序后第一位为正数，即所有数都为正数\n        if n1 > 0 {\n            break\n        }\n\n        // 三元组首位去重\n        if i > 0 && n1 == nums[i - 1] {\n            continue\n        }\n\n        l, r := i + 1, len(nums) - 1\n        for l < r {\n            n2, n3 := nums[l], nums[r]\n            if n1 + n2 + n3 == 0 {\n                res = append(res, []int{n1, n2, n3})\n                for l < r && n2 == nums[l]{\n                    l++\n                }\n                for l < r && n3 == nums[r] {\n                    r--\n                }\n            } else if n1 + n2 + n3 < 0 {\n                l++\n            } else {\n                r--\n            }\n        }\n    }\n    return res\n}\n```\n\n","timestamp":1694699764227},{"name":"08-18. 四数之和.md","path":"002-数据结构与算法/003-哈希表/08-18. 四数之和.md","content":"#### [18. 四数之和](https://leetcode.cn/problems/4sum/)\n\n思路同三数之和，区别在于多加一层循环，首位和第二位去重\n\n```go\nfunc fourSum(nums []int, target int) [][]int {\n    if len(nums) < 4 {\n        return [][]int{}\n    }\n\n    sort.Ints(nums)\n    res := [][]int{}\n\n    for i := 0; i < len(nums) - 3; i++ {\n        n1 := nums[i]\n        // 首位去重\n        if i > 0 && nums[i] == nums[i-1] {\n            continue\n        }\n\n        for j := i + 1; j < len(nums) - 2; j++ {\n            n2 := nums[j]\n            // 第二位去重\n            if j > i + 1 && nums[j] == nums[j-1] {\n                continue\n            }\n            l, r := j + 1, len(nums) - 1\n            \n            for l < r {\n                n3, n4 := nums[l], nums[r]\n\n                if n1 + n2 + n3 + n4 == target {\n                    res = append(res, []int{n1, n2, n3, n4})\n                    \n                    for l < r && n3 == nums[l] {\n                        l++\n                    }\n                    for l < r && n4 == nums[r] {\n                        r--\n                    }\n                } else if n1 + n2 + n3 + n4 < target {\n                    l++\n                } else {\n                    r--\n                }\n            }\n        }\n    }\n    return res\n}\n```\n\n","timestamp":1694699764227},{"name":"09-nSum问题.md","path":"002-数据结构与算法/003-哈希表/09-nSum问题.md","content":"# [一个函数秒杀 2Sum 3Sum 4Sum 问题](https://mp.weixin.qq.com/s/fSyJVvggxHq28a0SdmZm6Q)\n\n\n\n### [1. 两数之和](https://leetcode.cn/problems/two-sum/)\n\n```\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n#### 哈希表\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++) {\n          \tint need = target - nums[i]);\n            if(map.containsKey(need) {\n                return new int[]{i, map.get(need};\n            } else {\n                map.put(nums[i], i);\n            }\n        }\n        return new int[]{};\n    }\n}\n```\n\n\n\n### 1.两数之和改编\n\n```\n改题：\n1 返回元素，不返回下标\n2 数组中可能出现多组答案，要求答案去重\tnums = [1,1,1,2,2,3,3], target = 4\n```\n\n```java\nvector<vector<int>> twoSumTarget(vector<int>& nums, int target) {\n    // nums 数组必须有序\n    sort(nums.begin(), nums.end());\n    int lo = 0, hi = nums.size() - 1;\n    vector<vector<int>> res;\n    while (lo < hi) {\n        int sum = nums[lo] + nums[hi];\n        int left = nums[lo], right = nums[hi];\n        if (sum < target) {\n            while (lo < hi && nums[lo] == left) lo++;\n        } else if (sum > target) {\n            while (lo < hi && nums[hi] == right) hi--;\n        } else {\n            res.push_back({left, right});\n            while (lo < hi && nums[lo] == left) lo++;\n            while (lo < hi && nums[hi] == right) hi--;\n        }\n    }\n    return res;\n}\n```\n\n\n\n### [15. 三数之和](https://leetcode.cn/problems/3sum/)\n\n```\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n```\n\n\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        int n = nums.length;\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i++) {\n            // 排序后第一个值大于0，一定找不到和为0的解\n            if(nums[i] > 0) return res;\n            \n            if (i > 0 && nums[i] == nums[i - 1]) {  // 去重第一个数\n                continue;\n            }\n\n            // 两数之和\n            int l = i + 1, r = n - 1;\n            while(l < r) {\n                if(nums[i] + nums[l] + nums[r] < 0) {\n                    l++;\n                } else if(nums[i] + nums[l] + nums[r] > 0) {\n                    r--;\n                } else {\n                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                    // 对第2、3个数去重\n                    while(l < r && nums[l] == nums[l+1]) l++;\n                    while(l < r && nums[r] == nums[r-1]) r--;\n                    \n                    l++;\n                    r--;\n                }\n            }\n        }\n\n        return res;\n    }\n}\n\n代码随想录：https://programmercarl.com/0015.三数之和.html#双指针\n```\n\n\n\n### [18. 四数之和](https://leetcode.cn/problems/4sum/)\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        int n = nums.length;\n        for(int i = 0; i < n; i++) {\n            if (nums[i] > 0 && nums[i] > target) {  // 理论上已经不存在解\n                return res;\n            }\n\n            if(i > 0 && nums[i] == nums[i - 1]) continue;\n\n            for(int j = i + 1; j < n; j++) {\n                if(j > i + 1 && nums[j] == nums[j - 1]) continue;\n\n                int l = j + 1, r = n - 1;\n                while(l < r) {\n                    long sum = (long)nums[i] + nums[j] + nums[l] + nums[r];\n                    if(sum == target) {\n                        res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));\n                        while(l < r && nums[l] == nums[l + 1]) l++;\n                        while(l < r && nums[r] == nums[r - 1]) r--;\n\n                        l++;\n                        r--;\n                    } else if(sum < target) {\n                        l++;\n                    } else {\n                        r--;\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n}\n\n代码随想录：https://programmercarl.com/0018.四数之和.html#其他语言版本\n```\n\n写法二\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        int n = nums.length;\n        // [-2 -1 0 0 1 2]\n        for(int i = 0; i < n; i++) {\n            \n            if (nums[i] > 0 && nums[i] > target) {  // 理论上已经不存在解\n                return res;\n            }\n            \n            if(i > 0 && nums[i] == nums[i - 1]) continue;   // 第一个数去重\n\n            // 找三数和\n            long target1 = (long)target - nums[i];\n            for(int j = i + 1; j < n; j++) {\n                if(j > i + 1 && nums[j] == nums[j - 1]) continue;   // 第二个数去重\n                \n                // 找两数和\n                long target2 = target1 - nums[j];\n                int l = j + 1, r = n - 1;\n                while(l < r) {\n                    long sum = (long)nums[l] + nums[r];\n                    if(sum == target2) {\n                        res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));\n                        while(l < r && nums[l] == nums[l + 1]) l++;     // 第三个数去重\n                        while(l < r && nums[r] == nums[r - 1]) r--;     // 第四个数去重\n\n                        l++;\n                        r--;\n                    } else if(sum < target2) {\n                        l++;\n                    } else {\n                        r--;\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-344. 反转字符串.md","path":"002-数据结构与算法/004-字符串/01-344. 反转字符串.md","content":"## 知识点\n\n-   元素互换`s[l], s[r] = s[r], s[l]`\n\n\n\n#### [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)\n\n##### 方法一：双指针\n\n```go\nfunc reverseString(s []byte)  {\n    l, r := 0, len(s) - 1\n    for l < r {\n        s[l], s[r] = s[r], s[l]\n        l++\n        r--\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-541. 反转字符串 II.md","path":"002-数据结构与算法/004-字符串/02-541. 反转字符串 II.md","content":"## 知识点\n\n[字符串  <=> 数组](https://blog.csdn.net/qq_42410605/article/details/112685670)\n\n-   字符串 => 数组 `strArr := []byte(s)`\n-   数组 => 字符串 `string(strArr[:])`\n\n\n\n#### [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)\n\n```go\nfunc reverseStr(s string, k int) string {\n    strArr := []byte(s)\n    l := 0\n    for l < len(strArr) && k + l <= len(s) {\n        strArr = reverse(strArr, l, l + k - 1)\n        l += 2 * k\n    }\n    strArr = reverse(strArr, l, len(strArr) - 1)\n    return string(strArr[:])\n\n}\n\nfunc reverse(s []byte, l int, r int) []byte{\n    for l < r {\n        s[l], s[r] = s[r], s[l]\n        l++\n        r--\n    }\n    return s\n}\n```\n\n[其他版本](https://programmercarl.com/0541.反转字符串II.html#其他语言版本)\n\n参考如何反转部分数组\n\n```go\nfunc reverseStr(s string, k int) string {\n    ss := []byte(s)\n    length := len(s)\n    for i := 0; i < length; i += 2 * k {\n        if i + k <= length {\n            reverse(ss[i:i+k])\n        } else {\n            reverse(ss[i:length])\n        }\n    }\n    return string(ss)\n}\n\nfunc reverse(b []byte) {\n    left := 0\n    right := len(b) - 1\n    for left < right {\n        b[left], b[right] = b[right], b[left]\n        left++\n        right--\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"03-剑指 Offer 05. 替换空格.md","path":"002-数据结构与算法/004-字符串/03-剑指 Offer 05. 替换空格.md","content":"## 知识点\n\n-   变量名不能用`len`\n\n-   不能使用`b[i--] = 0`\n\n-   数组扩容\n\n    ```go\n    b := []byte(s)\n    tmp := make([]byte, 2)\n    b = append(b, tmp...)\n    ```\n\n-   切片（不定长数组）\n\n    ```go\n    // 声明\n    result := make([]byte, 0)\n    // 添加元素， ...含义为将byte数组展开\n    result = append(result, []byte(\"%20\")...) \n    ```\n\n    \n\n#### [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)\n\n方法一：遍历添加\n\n```go\nfunc replaceSpace(s string) string {\n    b := []byte(s)\n    result := make([]byte, 0)\n    for _, v := range b {\n        if v == \' \' {\n            result = append(result, []byte(\"%20\")...)\n        } else {\n            result = append(result, v)\n        }\n    }\n    return string(result)\n}\n```\n\n方法二：原地替换\n\n扩容数组 + 倒叙遍历\n\n```go\nfunc replaceSpace(s string) string {\n    b := []byte(s)\n    length := len(b)\n    cnt := 0\n\n    // 遍历统计空格数\n    for _, v := range b {\n        if v == \' \' {\n            cnt++\n        } \n    }\n\n    // 拓展切片容量\n    tmp := make([]byte, cnt * 2)\n    b = append(b, tmp...)\n\n    // 倒叙遍历替换字符\n    i := length - 1    // 原数组尾指针\n    j := len(b) - 1 // 新数组尾指针\n    for i >= 0 {\n        if b[i] == \' \' {\n            b[j] = \'0\'\n            b[j-1] = \'2\'\n            b[j-2] = \'%\'\n            i--\n            j -= 3\n        } else {\n            b[j] = b[i]\n            j--\n            i--\n        }\n    }\n    return string(b)\n}\n```\n\n","timestamp":1694699764227},{"name":"04-151. 反转字符串中的单词.md","path":"002-数据结构与算法/004-字符串/04-151. 反转字符串中的单词.md","content":"## 知识点\n\n-   去除首位空格`str = strings.TrimSpace(str)`\n-   字符串分割`strings.Split`\n\n\n\n#### [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)\n\n方法一：空间复杂度O（n） \n\n```go\nimport \"strings\"\n\nfunc reverseWords(s string) string {\n    s = strings.TrimSpace(s)\n    sArr := strings.Split(s, \" \")\n\n    // 翻转数组\n    i, j := 0, len(sArr) - 1\n    for i < j {\n        sArr[i], sArr[j] = sArr[j], sArr[i]\n        i++\n        j--\n    }\n\n    // // 拼接\n    ss := \"\"\n    for _, v := range sArr {\n        if strings.TrimSpace(v) != \"\" {\n            ss += v + \" \"\n        }\n    }\n\n    return strings.TrimSpace(ss)\n}\n```\n\n方法二： \n\n解题思路：\n\n-   移除多余空格\n-   将整个字符串反转\n-   将每个单词反转\n\n举个例子，源字符串为：\"the sky is blue \"\n\n-   移除多余空格 : \"the sky is blue\"\n-   字符串反转：\"eulb si yks eht\"\n-   单词反转：\"blue is sky the\"\n\n```go\nfunc reverseWords(s string) string {\n    b := []byte(s)\n    slow, fast := 0, 0\n\n    // 处理头部, fast为首个字母下标\n    for fast < len(b) && b[fast] == \' \'{\n        fast++\n    }\n\n    // 处理中间\n    for ;fast < len(b); fast++ {\n        if b[fast] != \' \' {\n            b[slow] = b[fast]\n            slow++\n        } else {\n            if slow > 0 && b[slow - 1] != \' \' {\n                b[slow] = \' \'\n                slow++\n            }\n        }\n    }\n\n    // // 处理尾部\n    if slow-1 > 0 && b[slow-1] == \' \' {\n        b = b[:slow-1]\n    } else {\n        b = b[:slow] // 切除尾部多余字符，否则尾部会重复空格数量的尾部字符\n    }\n\n    // 翻转整个字符串\n    b = reverse(b, 0, len(b) - 1)\n\n    // 翻转每一个单词\n    slow, fast = 0, 0\n    for ;fast < len(b); fast++ {\n        if b[fast] == \' \'{\n            b = reverse(b, slow, fast-1)\n            slow = fast + 1\n        }\n    }\n    b = reverse(b, slow, fast-1) \n\n    return string(b)\n}\n\nfunc reverse(b []byte, l int, r int) []byte{\n    for l < r {\n        b[l], b[r] = b[r], b[l]\n        l++\n        r--\n    }\n    return b\n}\n```\n\n","timestamp":1694699764227},{"name":"05-剑指 Offer 58 - II. 左旋转字符串.md","path":"002-数据结构与算法/004-字符串/05-剑指 Offer 58 - II. 左旋转字符串.md","content":"\n\n\n\n#### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n\n```go\nfunc reverseLeftWords(s string, n int) string {\n    b := []byte(s)\n    n = n % len(s)\n    b = reverse(b, 0, n - 1)\n    b = reverse(b, n, len(s) - 1)\n    b = reverse(b, 0, len(s) - 1)\n    return string(b)\n}\n\nfunc reverse(b []byte, l int, r int) []byte {\n    for l < r {\n        b[l], b[r] = b[r], b[l]\n        l++\n        r--\n    }\n    return b\n}\n```\n\n优化\n\n```go\nfunc reverseLeftWords(s string, n int) string {\n    b := []byte(s)\n    // 1. 反转前n个字符\n    // 2. 反转第n到end字符\n    // 3. 反转整个字符\n    reverse(b, 0, n-1)\n    reverse(b, n, len(b)-1)\n    reverse(b, 0, len(b)-1)\n    return string(b)\n}\n// 切片是引用传递\nfunc reverse(b []byte, left, right int){\n    for left < right{\n        b[left], b[right] = b[right],b[left]\n        left++\n        right--\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"06-459. 重复的子字符串.md","path":"002-数据结构与算法/004-字符串/06-459. 重复的子字符串.md","content":"#### [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)\n\n##### 方法一：枚举\n\n-   实现一\n\n依次找到以b[0]开头的字符串b[j]，用b[0:j]依次向后对比，如果都相同，那么为字串\n\n```go\n// 错解\nfunc repeatedSubstringPattern(s string) bool {\n    // abbaa abbaa abbaa\n    // ab ab ab ab\n    b := []byte(s)\n    j := 1\n    for j < len(b) {\n        if b[j] != b[0] {\n            j++\n        } else {\n            str := string(b[0:j])\n            for ; str == string(b[j:j+len(str)]); j+=len(str) {\n                if j + len(str) == len(b) && str == string(b[j:j+len(str)]){\n                    return true\n                }\n            }\n            j++\n        }\n    }\n    return false\n}\n\n\n// 参考下方解法改进\nfunc repeatedSubstringPattern(s string) bool {\n// abbaa abbaa abbaa\n    // ab ab ab\n    b := []byte(s)\n    n := len(b)\n\n    for j := 1; j * 2 <= n; j++ {\n\n        if b[j] == b[0] {\n            str := string(b[0:j])\n            strLen := len(str)\n            if n % strLen != 0 {\n                continue\n            }\n            \n            match := true\n            for i := j; i < n; i+=strLen {\n                if str != string(b[i:i+strLen]) {\n                    match = false\n                    break\n                }\n            }\n            if match {\n                return true\n            }\n\n        }\n    }\n    return false\n}\n```\n\n-   实现二\n\n```go\nfunc repeatedSubstringPattern(s string) bool {\n    // abbaa abbaa abbaa\n    // ab ab ab\n    n := len(s)\n    for i := 1; i * 2 <= n; i++ {  // 子串长度，子串至少需要重复一次，最大为s的一半\n        if n % i == 0 {  // 字符一定是字串长度的整数倍\n            match := true\n            for j := i; j < n; j++ {\n                if s[j] != s[j - i] {\n                    match = false\n                    break\n                }\n            }\n            if match {\n                return true\n            }\n        }\n    }\n\n    return false\n}\n```\n\n##### 方法二：移动匹配\n\n```java\ns: abc (abc)\n\nss:  (abc) abc (abc) abc // 后面的子串做前串，前后的子串做后串，就一定还能组成一个s\n  \n在  bc) abc (abc) ab 中寻找是否有s\n\nclass Solution {\n    public boolean repeatedSubstringPattern(String s) {\n        return (s + s).indexOf(s, 1) != s.length();\n    }\n}\n\n```\n\n","timestamp":1694699764227},{"name":"01-模版.md","path":"002-数据结构与算法/005-栈与队列/01-单调栈/01-模版.md","content":"## 什么时候用单调栈呢？\n\n```\n通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了\n```\n\n\n\n## 模版\n\n### 模版1：正序遍历\n\n```java\nclass Solution {\n    public int[] dailyTemperatures(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        Deque<Integer> s = new LinkedList<>();\n        s.push(0);\t// 思考：存下标 还是 存元素\n        for(int i = 1; i < n; i++) {\n            while(!s.isEmpty() && nums[i] > nums[s.peek()]) {\n                res[s.peek()] = nums[s.peek()];\t// 思考：结果集要存的东西\n                s.pop();\n            }\n            s.push(i);\n        }\n\n        return res;\n    }\n}\n```\n\n### [模版2](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-daeca/dan-diao-z-1bebe/)：逆序遍历\n\n```java\nint[] nextGreaterElement(int[] nums) {\n    int n = nums.length;\n    // 存放答案的数组\n    int[] res = new int[n];\n    Stack<Integer> s = new Stack<>(); \n    // 倒着往栈里放\n    for (int i = n - 1; i >= 0; i--) {\n        // 判定个子高矮\n        while (!s.isEmpty() && s.peek() <= nums[i]) {\n            // 矮个起开，反正也被挡着了。。。\n            s.pop();\n        }\n        // nums[i] 身后的更大元素\n        res[i] = s.isEmpty() ? -1 : s.peek();\n        s.push(nums[i]);\n    }\n    return res;\n}\n\n```\n\n","timestamp":1694699764227},{"name":"02-496. 下一个更大元素 I.md","path":"002-数据结构与算法/005-栈与队列/01-单调栈/02-496. 下一个更大元素 I.md","content":"### [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)\n\n在nums2中找大于nums1各元素的第一个值\n\n```\n输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n```\n\n解题思路：\n\n```\nnums1是nums2的子集\n求nums2的个元素的下一个最大元素，用map记录\n再从map中取nums1的个元素的下一个最大元素\n```\n\n\n\n```java\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n\t\t\t\t// 求nums2的个元素的下一个最大元素\n        Map<Integer, Integer> map = new HashMap<>();\n        Deque<Integer> s = new LinkedList<>();\n        s.push(nums2[0]);\n        for(int i = 1; i < nums2.length; i++) {\n            while(!s.isEmpty() && nums2[i] > s.peek()) {\n                map.put(s.peek(), nums2[i]);\n                s.pop();\n            }\n            s.push(nums2[i]);\n        }\n\n      \t// 求nums1的个元素的下一个最大元素（nums1s是nums2的子集）\n      \tint[] res = new int[nums1.length];\n        for(int i = 0; i < nums1.length; i++) {\n            if(map.containsKey(nums1[i])) {\n                res[i] = map.get(nums1[i]);\n            } else {\n                res[i] = -1;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n[参考](https://programmercarl.com/0496.下一个更大元素I.html#其他语言版本)","timestamp":1694699764227},{"name":"03-503. 下一个更大元素 II.md","path":"002-数据结构与算法/005-栈与队列/01-单调栈/03-503. 下一个更大元素 II.md","content":"### [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)\n\n\n\n思路：将数据拼接 nums + nums，遍历两次nums\n\n优化：在遍历过程中模拟遍历两次nums\n\n```java\nclass Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        if(nums == null || nums.length <= 1) {\n            return new int[]{-1};\n        }\n\n        int len = nums.length;  \n        int[] res = new int[len];\n        Arrays.fill(res, -1);\n        Deque<Integer> s = new LinkedList<>();\n        for(int i = 0; i < len * 2; i++) {\n            while(!s.isEmpty() && nums[i % len] > nums[s.peek()]) {\n                res[s.peek() % len] = nums[i % len];\n                s.pop();\n            }\n            s.push(i % len);\n        }\n\n        return res;\n    }\n}\n```\n\n[参考](https://programmercarl.com/0503.下一个更大元素II.html#其他语言版本)","timestamp":1694699764227},{"name":"04-739. 每日温度.md","path":"002-数据结构与算法/005-栈与队列/01-单调栈/04-739. 每日温度.md","content":"### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)\n\n题目\n\n```\n给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n示例 1:\n输入: t = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n```\n\n思路：\n\n用单调栈，初始化时t[0]入栈，依次遍历剩余元素，新元素入栈时先将站内比自己小的元素取出，更新结果集res\n\n```java\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        int n = temperatures.length;\n        int[] res = new int[n];\n        Deque<Integer> s = new LinkedList<>();\n        s.push(0);\n        for(int i = 1; i < n; i++) {\n            while(!s.isEmpty() && temperatures[i] > temperatures[s.peek()]) {\n                res[s.peek()] = i - s.peek();\n                s.pop();\n            }\n            s.push(i);\n        }\n\n        return res;\n    }\n}\n```\n\n优化\n\n```java\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        int[] res = new int[temperatures.length];\n        Deque<Integer> stack = new LinkedList<>();\n      \t// s.push(0); 优化一，for从0开始\n        for(int i = 0; i < temperatures.length; i++) {\n            while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n                res[stack.peek()] = i - stack.peek();\n                stack.pop();\n            }\n            stack.push(i);\n        }\n\n        // System.out.println(Arrays.toString(res));\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"05-42.接雨水.md","path":"002-数据结构与算法/005-栈与队列/01-单调栈/05-42.接雨水.md","content":"### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)\n\n#### 方法一：单调栈\n\n情况2：高度 = 栈顶元素高度\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/15/16373116841398511684139851299uftOQg-19583216733519121673351912945DlbuoT-image-20230110195832788.png\" alt=\"image-20230110195832788\" style=\"zoom: 50%;\" />\n\n情况3：高度 > 栈顶元素高度\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/01/10/20044816733522881673352288357WQw3Qe-image-20230110200448235.png\" alt=\"image-20230110200448235\" style=\"zoom:50%;\" />\n\n\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        // int[] next = new int[height.length];\n        int res = 0;\n        Deque<Integer> s = new LinkedList<>();  // height下标\n        s.push(0);\n        for(int i = 1; i < height.length; i++) {\n            if(height[i] < height[s.peek()]) {  // 情况1: 高度 < 栈顶元素高度\n                s.push(i);\n            } else if (height[i] == height[s.peek()]) { \t// 情况2: 高度 = 栈顶元素高度\n                s.pop();\n                s.push(i);\n            } else {\t\t// 情况3: 高度 > 栈顶元素高度\n                while(!s.isEmpty() && height[i] > height[s.peek()]) {\n                    int mid = s.peek();\n                    s.pop();\n                    if(!s.isEmpty()) {\n                        int left = s.peek();\n                        int width = i - left - 1;\n                        int h = Math.min(height[left], height[i]) - height[mid];\n                        res += h * width;\n                    }\n                }\n                s.push(i);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法二：双指针\n\n按列计算雨水，宽度为1，只需计算每一列的高度\n\n如何求高度？\n\n```\n可以看出每一列雨水的高度，取决于，该列 左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度。\n例如4那一列的高度，4两边最高的高度是3和7，列4的雨水高度为列3-列4\n```\n\n![image-20230516131247597](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/16/13124716842139671684213967737fHAFo4-image-20230516131247597.png)\n\n\n\n思路：按列计算雨水，遍历到i时，分别找到`i`两侧比`i`**最高**的的柱子\n\n![image-20230111103046060](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/15/16373216841398521684139852308WGZPpK-10304616734042461673404246243ffXz0b-image-20230111103046060.png)\n\n错解：只找了比i高的，没有找最高的。如遍历到5时，找的柱子是4和6，导致少算了1滴雨水\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int res = 0;\n        for(int i = 0; i < height.length; i++) {\n            if(i == 0 || i == height.length - 1) continue;\n\n            int left = i - 1;\n            while(left > 0 && height[left] <= height[i]) left--;\n\n            int right = i + 1;\n            while(right < height.length - 1 && height[right] <= height[i]) right++;\n\n            int h = Math.min(height[left], height[right]) - height[i];\n\n            System.out.print(h + \" \");\n\n            if(h > 0) res += h;\n        }\n\n        return res;\n    }\n}\n```\n\njava\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int res = 0;\n        for(int i = 0; i < height.length; i++) {\n            if(i == 0 || i == height.length - 1) continue;\n\n          \t// 找左边自己高的最高柱子\n            int left = height[i];\n            for(int l = i; l >= 0; l--) {\n                if(height[l] > left) left = height[l];\n            }\n\n          \t// 找右边比自己高的最高柱子\n            int right = height[i];\n            for(int r = i + 1; r < height.length; r++) {\n                if(height[r] > right) right = height[r];\n            }\n\n            int h = Math.min(left, right) - height[i];\n\n            // System.out.print(h + \" \");\n\n            if(h > 0) res += h;\n\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法三：dp\n\n双指针解法中，每次向两侧寻找最高柱子是会重复计算的\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int len = height.length;\n        int[] dpL = new int[len];\n        int[] dpR = new int[len];\n\n        dpL[0] = height[0];\n        for(int i = 1; i < len; i++) {\n            dpL[i] = Math.max(height[i], dpL[i - 1]);\n        }\n\n        dpR[len - 1] = height[len - 1];\n        for(int i = len - 2; i >= 0; i--) {\n            dpR[i] = Math.max(height[i], dpR[i + 1]);\n        }\n\n        int res = 0;\n        for(int i = 0; i < len; i++) {\n            int h = Math.min(dpL[i], dpR[i]) - height[i];\n            if(h > 0) res += h;\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n#### 方法四：双指针2（最简单）\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int l = 0, r = height.length - 1;\n        int lMax = 0, rMax = 0;\n\n        int res = 0;\n        while(l < r) {\n            lMax = Math.max(lMax, height[l]);\n            rMax = Math.max(rMax, height[r]);\n\n            if(lMax < rMax) {\n                res += lMax - height[l];\n                l++;\n            } else {\n                res += rMax - height[r];\n                r--;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n参考：https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-gao--0d5eb/\n","timestamp":1694699764227},{"name":"06-84. 柱状图中最大的矩形.md","path":"002-数据结构与算法/005-栈与队列/01-单调栈/06-84. 柱状图中最大的矩形.md","content":"### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)\n\n#### 方法一：单调栈\n\n**思考**： \n\n为什么会用单调栈\n\n```\n在一维数组中对每一个数找到第一个比自己小的元素。这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。\n```\n\n为什么是找到第一个比自己小的？\n\n```\n当右侧元素比自己大时，那么面积一定是变大的，当碰到比栈顶元素小时，说明面积可能在变小\n```\n\n开头为什么要加元素0？\n\n```\n如果数组本身是降序的，例如 [8,6,4,2]，在 8 入栈后，6 开始与8 进行比较，此时我们得到 mid（8），rigt（6），但是得不到 left，无法计算面积\n```\n\n结尾为什么要加元素0？\n\n```\n输入为[2,1,2]时，当遍历到第二个2，右边已经没有比它小的元素了，所以永远不会计算第二个2的面积\n```\n\n**错解**：计算面积时用[ )\n\n```\n[2,1,2]\nOutput: 2\nExpected: 3\n```\n\n\n\n```java\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        // 扩容数组，首尾添0\n        int[] newHeights = new int[n + 2];\n        newHeights[0] = 0;\n        newHeights[newHeights.length - 1] = 0;\n        for(int i = 0; i < heights.length; i++) newHeights[i + 1] = heights[i];\n\n        int res = 0;\n        Deque<Integer> s = new LinkedList<>();\n        s.push(0);\n        for(int i = 1; i < newHeights.length; i++) {\n            // System.out.println(newHeights[i]);\n            if(newHeights[i] > newHeights[s.peek()]) {\n                s.push(i);\n            } else if(newHeights[i] == newHeights[s.peek()]) {\n                s.push(i);\n            } else {\n                while(!s.isEmpty() && newHeights[i] < newHeights[s.peek()]) {\t// 依次取栈中比当前元素大的元素作为高计算面积\n                    // 面积区间[)\n                    int r = i;  // 面积不包括r\n                    int l = s.peek();\n                    int h = newHeights[l];\n                    int width = r - l;\n                    res = Math.max(res, width * h);\n                    s.pop();\n                    // System.out.println(\"res: \" + res);\n                }\n                s.push(i);\n            }\n        }\n\n        return res; // [2,1,2]\n    }\n}\n```\n\n正解\n\n```\n[2 3 1]\n计算面积时用()\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/16/09572816842022481684202248434V0WfWT-image-20230516095728201.png\" alt=\"image-20230516095728201\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/16/09585916842023391684202339502Z24Nww-image-20230516095859380.png\" alt=\"image-20230516095859380\" style=\"zoom:50%;\" />\n\n```java\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        // 扩容数组，首尾添0\n        int[] newHeights = new int[n + 2];\n        newHeights[0] = 0;\n        newHeights[newHeights.length - 1] = 0;\n        for(int i = 0; i < heights.length; i++) newHeights[i + 1] = heights[i];\n\n        int res = 0;\n        Deque<Integer> s = new LinkedList<>();\n        s.push(0);\n        for(int i = 1; i < newHeights.length; i++) {\n            // System.out.println(newHeights[i]);\n            if(newHeights[i] > newHeights[s.peek()]) {\n                s.push(i);\n            } else if(newHeights[i] == newHeights[s.peek()]) {\n                // s.pop();    // 可省略, 省略后思路不同\n                s.push(i);\n            } else {\n                while(!s.isEmpty() && newHeights[i] < newHeights[s.peek()]) {\n                    // 面积区间()\n                    int r = i;  // 面积不包括r\n                    int mid = s.peek();\n                    s.pop();\n                    int l = s.peek();\n                    int h = newHeights[mid];\n                    int width = r - l - 1;\n                    res = Math.max(res, width * h);\n                    \n                    // System.out.println(\"res: \" + res);\n                }\n                s.push(i);\n            }\n        }\n\n        return res; // [2,1,2]\n    }\n}\n```\n\n\n\n#### 方法二：双指针\n\n找两侧比自己小的第一个元素\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/16/10145116842032911684203291336gjNWii-13345516734152951673415295957n7eOWJ-image-20230111133455755.png\" alt=\"image-20230111133455755\" style=\"zoom:50%;\" />\n\n在接雨水中，按列计算，宽度始终是1，所以l、r直接记录高度，此处记录下标\n\n接雨水要分别找两侧比自己最高的柱子，用`for`；此处分别找两侧第一个比自己小的，用`while`\n\n```java\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int res = 0;\n        int len = heights.length;\n        for(int i = 0; i < len; i++) {\n            // 找左边比自己小的\n            int l = i;\n            while(l >= 0 && heights[l] >= heights[i]) l--;\n\n          \t// 找右边比自己小的\n            int r = i;\n            while(r < len && heights[r] >= heights[i]) r++;\n\n            int w = r - l - 1;\t// 面积区间为（l, r）\n\n            // System.out.print(w * heights[i] + \" \");\n\n            res = Math.max(w * heights[i], res);\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法三：dp\n\n难点：如何找出左侧第一个比自己小的\n\n错解：\n\n左边邻居不一定比自己小，左邻居的第一个最小值dp[i - 1]`也不一定比自己小，以2为例，所以不能用if\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/16/10145116842032911684203291705qa4rPz-13584416734167241673416724919Nz5c2y-image-20230111135844803.png\" alt=\"image-20230111135844803\" style=\"zoom:33%;\" />\n\n```java\nfor(int l = 1; l < len; l++) {\n    if(heights[l - 1] < heights[l]) {\n      dpL[l] = l - 1;\n    } else if(heights[dpL[l - 1]] < heights[l]) {\n      dpL[l] = dpL[l - 1];\n    } else {\n      dpL[l] = l;\n    }\n}\n```\n\n正解：\n\n```java\ndpL[0] = -1;\t// 为了能让while退出循环\n  for(int l = 1; l < len; l++) {\n    int tmp = l - 1;\n    while(tmp >= 0 && heights[tmp] >= heights[l]) tmp = dpL[tmp];\n    dpL[l] = tmp;\n}\n```\n\njava\n\n```java\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int len = heights.length;\n        int[] dpL = new int[len];\n        int[] dpR = new int[len];\n\n        dpL[0] = -1;\n        for(int l = 1; l < len; l++) {\n            int tmp = l - 1;\n            while(tmp >= 0 && heights[tmp] >= heights[l]) tmp = dpL[tmp];\n            dpL[l] = tmp;\n        }\n        // System.out.println(Arrays.toString(dpL));\n\n        dpR[len - 1] = len;\n        for(int r = len - 2; r >= 0; r--) {\n            int tmp = r + 1;\n            while(tmp < len && heights[tmp] >= heights[r]) tmp = dpR[tmp];\n            dpR[r] = tmp;\n        }\n        //  System.out.println(Arrays.toString(dpR));\n\n        int res = 0;\n        for(int i = 0; i < len; i++) {\n            int w = dpR[i] - dpL[i] - 1;\n            int area = w * heights[i];\n            res = Math.max(res, area);\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-总结.md","path":"002-数据结构与算法/005-栈与队列/100-总结.md","content":"https://www.cainiaojc.com/java/java-deque.html\n\n\n\n## 双端队列作为堆栈数据结构\n\n```\nDeque<Integer> stack = new LinkedList<>();  // 不能用int\n```\n\nJava Collections框架的Stack类提供了堆栈的实现。\n\n但是，建议Deque用作堆栈而不是[Stack类](https://www.cainiaojc.com/java/java-stack.html)。这是因为Stack的方法是同步的。\n\n以下是Deque接口提供的用于实现堆栈的方法：\n\n-   push() - 在双端队列的开头添加元素\n-   pop() - 从双端队列的开头删除元素\n-   peek() - 从双端队列的开头返回一个元素","timestamp":1694699764227},{"name":"101-232. 用栈实现队列.md","path":"002-数据结构与算法/005-栈与队列/101-232. 用栈实现队列.md","content":"### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)\n\n#### 方法一：双栈\n\n使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈**一个输入栈，一个输出栈**\n\n进栈：往sIn追加元素\n\n出栈：判断sOut是否为空，如果为空，将sIn全部放入sOut，再pop第一个元素\n\n##### go\n\n```go\ntype MyQueue struct {\n    sIn []int\n    sOut []int\n}\n\n\nfunc Constructor() MyQueue {\n    return MyQueue{}\n}\n\nfunc (this *MyQueue) In2Out() {\n    for len(this.sIn) > 0 {\n        this.sOut = append(this.sOut, this.sIn[len(this.sIn)-1])\n        this.sIn = this.sIn[:len(this.sIn) - 1]\n    }\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n    this.sIn = append(this.sIn, x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n    // if this.Empty() {\n    //     return nil\n    // }\n\n    if len(this.sOut) == 0 {\n        this.In2Out()\n    }\n\n    out := this.sOut[len(this.sOut) - 1]\n    this.sOut = this.sOut[:len(this.sOut)-1]\n    return out\n}\n\n\nfunc (this *MyQueue) Peek() int {\n    // if this.Empty() {\n    //     return nil\n    // }\n\n    if len(this.sOut) == 0 {\n        this.In2Out()\n    }\n\n    return this.sOut[len(this.sOut)-1]\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n    // if len(this.sIn) == 0 && len(this.sOut) == 0 {\n    //     return true\n    // } else {\n    //     return false\n    // }\n\n    // 优化：\n    return len(this.sIn) == 0 && len(this.sOut) == 0\n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */\n```\n\n","timestamp":1694699764227},{"name":"102-225. 用队列实现栈.md","path":"002-数据结构与算法/005-栈与队列/102-225. 用队列实现栈.md","content":"### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)\n\n#### 方法一：一个队列\n\n往后追加元素，从后向前出\n\n##### go\n\n```go\ntype MyStack struct {\n    s []int\n}\n\n\nfunc Constructor() MyStack {\n    return MyStack{}\n}\n\n\nfunc (this *MyStack) Push(x int)  {\n    this.s = append(this.s, x)\n}\n\n\nfunc (this *MyStack) Pop() int {\n    out := this.s[len(this.s)-1]\n    this.s = this.s[:len(this.s)-1]\n    return out\n}\n\n\nfunc (this *MyStack) Top() int {\n    return this.s[len(this.s)-1]\n}\n\n\nfunc (this *MyStack) Empty() bool {\n    return len(this.s) == 0\n}\n\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.Empty();\n */\n```\n\n\n\n#### 方法二：两个队列\n\nS1: 主队列，s2辅助队列\n\n-   新元素进s2，将s1所有元素依次取出追加到s2尾部\n-   将s1与s2交换\n\n##### Go\n\n```go\ntype MyStack struct {\n    s1 []int\n    s2 []int\n}\n\n\nfunc Constructor() MyStack {\n    return MyStack{}\n}\n\n\nfunc (this *MyStack) Push(x int)  {\n    this.s2 = append(this.s2, x)\n    for len(this.s1) > 0 {\n        this.s2 = append(this.s2, this.s1[0])\n        this.s1 = this.s1[1:]\n    }\n    this.s1, this.s2 = this.s2, this.s1\n}\n\n\nfunc (this *MyStack) Pop() int {\n    out := this.s1[0]\n    this.s1 = this.s1[1:]\n    return out\n}\n\n\nfunc (this *MyStack) Top() int {\n    return this.s1[0]\n}\n\n\nfunc (this *MyStack) Empty() bool {\n    return len(this.s1) == 0\n}\n\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.Empty();\n */\n```\n\n","timestamp":1694699764227},{"name":"103-20. 有效的括号.md","path":"002-数据结构与算法/005-栈与队列/103-20. 有效的括号.md","content":"### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)\n\n#### 方法一： map + 栈\n\n##### Java\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        if(s == \"\") {\n            return true;\n        }\n\n        Map<Character, Character> m = new HashMap<>();\n        m.put(\')\', \'(\');\n        m.put(\'}\', \'{\');\n        m.put(\']\', \'[\');\n\n        LinkedList<Character> stack = new LinkedList<Character>();\n        for(int i=0; i<s.length(); i++) {\n            char ch = s.charAt(i);\n            if(ch == \'(\' || ch == \'{\' || ch == \'[\') {\n                stack.add(ch);\n            } else {\n                if(stack.isEmpty()) {\n                    return false;\n                }\n                char last = stack.getLast();\n                if(last == m.get(ch)) {\n                    stack.removeLast();\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        return stack.isEmpty();\n    }\n}\n```\n\n优化 - 不需要map\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        Deque<Character> deque = new LinkedList<>();\n        char ch;\n        for (int i = 0; i < s.length(); i++) {\n            ch = s.charAt(i);\n            //碰到左括号，就把相应的右括号入栈\n            if (ch == \'(\') {\n                deque.push(\')\');\n            }else if (ch == \'{\') {\n                deque.push(\'}\');\n            }else if (ch == \'[\') {\n                deque.push(\']\');\n            } else if (deque.isEmpty() || deque.peek() != ch) {\n                return false;\n            }else {//如果是右括号判断是否和栈顶元素匹配\n                deque.pop();\n            }\n        }\n        //最后判断栈中元素是否匹配\n        return deque.isEmpty();\n    }\n}\n```\n\n##### Go\n\n```go\nfunc isValid(s string) bool {\n    hash := map[byte]byte{\')\': \'(\', \'}\':\'{\', \']\':\'[\'}\n    stack := make([]byte, 0)\n\n    for i:=0; i<len(s); i++ {\n        if s[i] == \'(\' || s[i] == \'[\' || s[i] == \'{\' {\n            stack = append(stack, s[i]);\n        } else if len(stack) > 0 && stack[len(stack) - 1] == hash[s[i]] {\n            stack = stack[:len(stack)-1]\n        } else {\n            return false\n        }\n    }\n    return len(stack) == 0\n}\n```\n\n","timestamp":1694699764227},{"name":"104-1047. 删除字符串中的所有相邻重复项.md","path":"002-数据结构与算法/005-栈与队列/104-1047. 删除字符串中的所有相邻重复项.md","content":"### [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)\n\n\n\n#### 方法一：栈\n\n##### Java\n\n```java\nclass Solution {\n    public String removeDuplicates(String s) {\n        Deque<Character> stack = new LinkedList<>();\n        for(int i=0; i<s.length(); i++) {\n            char ch = s.charAt(i);\n            if(stack.isEmpty()) {\n                stack.push(ch);\n            } else {\n                if(stack.peek() == ch) {\n                    while(!stack.isEmpty() && stack.peek() == ch) {\n                        stack.pop();\n                    }\n                } else {\n                    stack.push(ch);\n                }\n            }\n        }\n\n        String str = \"\";\n        while (!stack.isEmpty()) {\n            str = stack.pop() + str;\n        }\n        return str;\n    }\n}\n```\n\n优化：\n\n没必要用for循环，因为栈里只有两种情况（eg: abbbbb）, 栈中有b / 无b，不存在有多个b的情况\n\n```java\nclass Solution {\n    public String removeDuplicates(String s) {\n        Deque<Character> stack = new LinkedList<>();\n        for(int i=0; i<s.length(); i++) {\n            char ch = s.charAt(i);\n            if(!stack.isEmpty() && stack.peek() == ch) {\n                stack.pop();\n            } else {\n                stack.push(ch);\n            }\n        }\n\n        String str = \"\";\n        while (!stack.isEmpty()) {\n            str = stack.pop() + str;\n        }\n        return str;\n    }\n}\n```\n\n\n\n##### Go\n\n```go\nfunc removeDuplicates(s string) string {\n    stack := make([]byte, 0)\n    for i:=0; i<len(s); i++ {\n        // 栈不空 且 与栈顶元素不等\n        if len(stack) > 0 && stack[len(stack) - 1] == s[i] {\n            // 弹出栈顶元素 并 忽略当前元素(s[i])\n            stack = stack[:len(stack)-1]\n        } else {\n            // 入栈\n            stack = append(stack, s[i])\n        }\n    }\n\n    return string(stack[:])\n}\n```\n\n\n\n#### 方法二：快慢指针\n\n```java\nclass Solution {\n    public String removeDuplicates(String s) {\n        char[] chArr = s.toCharArray();\n        int slow = 0;\n        int fast = 1;\n        while(fast < chArr.length) {\n            if(slow < 0 || chArr[slow] != chArr[fast]) {\n                chArr[++slow] = chArr[fast];\n            } else {\n                slow--;\n            }\n            fast++;\n        }\n        return new String(chArr,0,slow + 1);\n    }\n}\n```\n\n写法二\n\n```java\nclass Solution {\n    public String removeDuplicates(String s) {\n        char[] ch = s.toCharArray();\n        int fast = 0;\n        int slow = 0;\n        while(fast < s.length()){\n            // 直接用fast指针覆盖slow指针的值\n            ch[slow] = ch[fast];\n            // 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了\n            if(slow > 0 && ch[slow] == ch[slow - 1]){\n                slow--;\n            }else{\n                slow++;\n            }\n            fast++;\n        }\n        return new String(ch,0,slow);\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"105-150. 逆波兰表达式求值.md","path":"002-数据结构与算法/005-栈与队列/105-150. 逆波兰表达式求值.md","content":"### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)\n\n#### 方法一：栈\n\n思路：遇到数字就进栈，遇到运算符就从栈内取出两个做运算后再放回结果\n\n##### Java\n\n```java\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Deque<Integer> stack = new LinkedList<>();\n        for(String s : tokens) {\n            if(\"+\".equals(s)) { // leetcode 内置jdk的问题，不能使用==判断字符串是否相等\n                stack.push(stack.pop() + stack.pop());\n            } else if (\"-\".equals(s)) {\n                stack.push(-stack.pop() + stack.pop());\n            } else if (\"*\".equals(s)) {\n                stack.push(stack.pop() * stack.pop());\n            } else if (\"/\".equals(s)) {\n                int temp1 = stack.pop();\n                int temp2 = stack.pop();\n                stack.push(temp2 / temp1);\n            } else {\n                stack.push(Integer.valueOf(s));\n            }\n        }\n\n        return stack.peek();\n    }\n}\n```\n\n##### Go\n\n```go\nfunc evalRPN(tokens []string) int {\n    stack := make([]int, 0)\n    for _, s := range tokens {\n        val, err := strconv.Atoi(s)\n        if err == nil {\n            stack = append(stack, val)\n        } else {\n            num1, num2 := stack[len(stack)-2], stack[(len(stack))-1]\n\t\t\tstack = stack[:len(stack)-2]\n            switch s {\n                case \"+\":\n                    stack = append(stack, num1+num2)\n                case \"-\":\n                    stack = append(stack, num1-num2)\n                case \"*\":\n                    stack = append(stack, num1*num2)\n                case \"/\":\n                    stack = append(stack, num1/num2)\n\t\t\t}\n        }\n    }\n\n    return stack[0]\n}\n```\n\n","timestamp":1694699764227},{"name":"106-239. 滑动窗口最大值.md","path":"002-数据结构与算法/005-栈与队列/106-239. 滑动窗口最大值.md","content":"### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)\n\n#### 方法一：单调队列\n\n思路：\n\n采用一个单调递减的队列存元素下标，队首始终为窗口最大值下标，\n\n队列为空时，直接加入\n\n始终保持队列单调递减，在加入元素x时，要将队列中>=x的元素下标移除\n\n当队首元素指向的下标不在窗口范围内则移除\n\n\n\n##### Java\n\n错解：\n\n存在的问题：当队首元素已经不再窗口内时，不能将其移出，如 [1,3,1,2,0,5]，窗口为[1,2,0]时，队列为[3,2]并不能把3移除\n\n```java\nclass Solution {\n    Deque<Integer> deque = new LinkedList<>();\n\n    public void myPush(Integer n, int k) {\n        if(deque.size() == k) { // [1,3,1,2,0,5]，到0时，队列为[3,2]并不能把3移除\n            deque.removeLast();\n        }\n        while(!deque.isEmpty() && n >= deque.getFirst()) {\n            deque.removeFirst();\n        }\n        deque.push(n);\n    }\n\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int[] res = new int[nums.length - k + 1];\n        int index = 0;\n\n        // 第一个窗口\n        for(int i=0; i<k; i++) {\n            myPush(nums[i], k);\n        }\n        res[index++] = deque.getLast();\n\n        for(int i=k; i<nums.length; i++) {\n            myPush(nums[i], k);\n            res[index++] = deque.getLast();\n        }\n        \n        return res;\n    }\n}\n```\n\n解决办法：队列中存储数组下标，不存实际值\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> deque = new LinkedList<>(); // 存可能是最大值的下标\n        int[] res = new int[nums.length - k + 1];\n\n        // 第一个窗口\n        for(int i = 0; i < k; i++) {\n            while(!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n        }\n        res[0] = nums[deque.peekFirst()];\n\n        for(int i = k; i < nums.length; i++) {\n            while(!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n\n            // 当队首元素不在窗口内时，移除\n            while(deque.peekFirst() <= i-k) {\n                deque.pollFirst();\n            }\n\n            res[i-k+1] = nums[deque.peekFirst()];\n        }\n        \n        return res;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/)","timestamp":1694699764227},{"name":"107-347. 前 K 个高频元素.md","path":"002-数据结构与算法/005-栈与队列/107-347. 前 K 个高频元素.md","content":"### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)\n\n#### 方法一：优先级队列-小顶堆\n\n统计词频，维护一个大小为k的小顶堆，k个数量最多的数按小顶堆排列\n\n##### Java\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        // 统计词频\n        Map<Integer, Integer> map = new HashMap<>();\n        for(Integer n : nums) {\n            map.put(n, map.getOrDefault(n, 0) + 1);\n        }\n\n        // 大小为k的小顶堆，即k个数量最多的数按小顶堆排列\n        PriorityQueue<int[]> pq = new PriorityQueue<>((pair1, pair2) -> pair1[1] - pair2[1]);   // 小顶堆\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()) {\n            if(pq.size() < k) {  //小顶堆元素个数小于k个时直接加\n                pq.add(new int[]{entry.getKey(), entry.getValue()});\n            } else {\n                if(entry.getValue() > pq.peek()[1]) {\n                     pq.poll();\n                     pq.add(new int[]{entry.getKey(),entry.getValue()});\n                }\n            }\n        }\n\n        int[] res = new int[k];\n        for(int i = 0; i < k; i++) {\n            res[i] = pq.poll()[0];\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-理论.md","path":"002-数据结构与算法/006-堆/01-理论.md","content":"优先级队列PriorityQueue\n\n```java\nPriorityQueue<Integer> numbers = new PriorityQueue<>();\n\n// 添加\nadd() - 将指定的元素插入队列。如果队列已满，则会引发异常。\noffer() - 将指定的元素插入队列。如果队列已满，则返回false。\n  \n// 队列头部\npeek()\n  \n// 删除\nremove() - 从队列中删除指定的元素\npoll() - 返回并删除队列的开头\n  \n// 遍历\n// 1. 使用iterator()方法\nIterator<Integer> iterate = numbers.iterator();\nwhile(iterate.hasNext()) {\n  System.out.print(iterate.next());\n  System.out.print(\", \");\n}\n\n// 其他\ncontains(element)\t\t// 在优先级队列中搜索指定的元素。如果找到该元素，则返回true，否则返回false。\ntoArray()\t\t// 将优先级队列转换为数组，并返回它。‘\nsize()\t\t\t//返回队列元素个数\nisEmpty()\t\t//判断队列是否为空，为空返回true,不空返回false\n```\n\n比较器\n\n```java\n//自定义比较器，降序排列\nstatic Comparator<Integer> cmp = new Comparator<Integer>() {\n      public int compare(Integer e1, Integer e2) {\n        // 降序\n        return e2 - e1;\t\n        \n        //升序\n        // return e1-e2;\n      }\n};\n\npublic static void main(String[] args) {\n        //不用比较器，默认升序排列。输出结果2 3 4 \n        Queue<Integer> q = new PriorityQueue<>();\n        q.add(3);\n        q.add(2);\n        q.add(4);\n        while(!q.isEmpty()) System.out.print(q.poll() + \" \");\n\n        //使用自定义比较器，降序排列 4 3 2 \n        Queue<Integer> qq = new PriorityQueue<>(cmp);\n        qq.add(3);\n        qq.add(2);\n        qq.add(4);\n  \t\t\twhile(!q.isEmpty()) System.out.print(q.poll() + \" \");\n  \n}\n```\n\n简写\n\n```java\nPriorityQueue<int[]> pq = new PriorityQueue<>(o1, o2) -> o1-o2);\n```\n\n[参考](https://www.cnblogs.com/wei-jing/p/10806236.html)\n\n[参考](https://www.cainiaojc.com/java/java-priorityqueue.html)","timestamp":1694699764227},{"name":"01-236. 二叉树的最近公共祖先.md","path":"002-数据结构与算法/007-二叉树/01-公共祖先问题/01-236. 二叉树的最近公共祖先.md","content":"### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n[参考1:代码随想录](https://programmercarl.com/0236.二叉树的最近公共祖先.html)\n\n[参考2:Labuladong](https://mp.weixin.qq.com/s/njl6nuid0aalZdH5tuDpqQ)\n\n\n\n情况1：左子树为p，右子树为q\n\n判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。\n\n![image-20221018135134765](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/18/13513416660722941666072294867gKQGEF-image-20221018135134765.png)\n\n情况2：\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/18/135357166607243716660724375217VWQOU-image-20221018135357442.png\" alt=\"image-20221018135357442\" style=\"zoom: 33%;\" />\n\n\n\n<img src=\"/Users/kuan/Library/Application%20Support/typora-user-images/image-20221018140701731.png\" alt=\"image-20221018140701731\" style=\"zoom: 33%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/202102041512582.png\" alt=\"236.二叉树的最近公共祖先2\" style=\"zoom:50%;\" />\n\n#### 方法一：后序遍历\n\n通过返回的是不是null来判断，是否找到p 或 q\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n       \treturn find(root, p, q);\n    }\n  \n  \tpublic TreeNode find(TreeNode root, TreeNode p, TreeNode q) {\n      if(root == null) {\n            return null;\n        }\n\n        if(root == p || root == q) { // 情况二，根节点为p或q\n            return root;\n        }\n\n        TreeNode left = lowestCommonAncestor(root.left, p, q);      // 左\n        TreeNode right = lowestCommonAncestor(root.right, p, q);    // 右\n\n        // 根\n        if(left != null && right != null ) {    // 情况一\n            return root;\n        }\n        if(left != null && right == null) {\n            return left;\n        }\n        if(left == null && right != null) {\n            return right;\n        }\n\n        return null;\n    }\n}\n```\n\n[参考](https://programmercarl.com/0236.二叉树的最近公共祖先.html#java)\n\n写法2 (主要)\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        return traversal(root, p.val, q.val);\n    }\n\n    public TreeNode traversal(TreeNode root, int val1, int val2) {\n        if(root == null) return null;\n\n        if(root.val == val1 || root.val == val2)  {\t\t// 放在后序位置也行\n            return root;\n        }\n\n        TreeNode left = traversal(root.left, val1, val2);\n        TreeNode right = traversal(root.right, val1, val2);\n\n        if(left != null && right != null) return root;\n\n        return left != null ? left : right;\n    }\n}\n```\n\n\n\n\n","timestamp":1694699764227},{"name":"02-235. 二叉搜索树的最近公共祖先.md","path":"002-数据结构与算法/007-二叉树/01-公共祖先问题/02-235. 二叉搜索树的最近公共祖先.md","content":"### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n思路：\n\n利用二叉搜索树性质，在二叉树的最近公共祖先的基础上剪枝，不需要遍历整颗树。\n\n-   当 root > p && root > q时，解在左子树\n-   当root < p && root < q时，解在右子树\n\n![image-20221019105429448](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/19/105429166614806916661480695639EIibL-image-20221019105429448.png)\n\n以0，5为例，都小于6，则在左子树求解，然后遍历以2为根的树进一步求解（后续情况就跟普通二叉树一样，此处可优化）\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null) return null;\n        if(root == p || root == q) return root;\n\n        if(root.val > p.val && root.val > q.val) {\t// 剪枝，解在左子树\n            return lowestCommonAncestor(root.left, p, q);\n        }\n\n        if(root.val < p.val && root.val < q.val) {\t// 剪枝，解在右子树\n            return lowestCommonAncestor(root.right, p, q);\n        }\n\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\t\t// 此处可优化\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n        if(left != null && right != null ) {    \n            return root;\n        }\n        if(left != null && right == null) {\n            return left;\n        }\n        if(left == null && right != null) {\n            return right;\n        }\n\n        return null;\n    }\n}\n```\n\n优化： 找到答案提前返回，少遍历半边树\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null) return null;\n        if(root == p || root == q) return root;\n\n        if(root.val > p.val && root.val > q.val) {\n             TreeNode left =  lowestCommonAncestor(root.left, p, q);\n             if(left != null) return left;\n        }\n\n        if(root.val < p.val && root.val < q.val) {\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\n            if(right != null) return right;\n        }\n\n      \t// 一个大于root，一个小于root，那么root就是最近公共祖先\n        return root;\n    }\n}\n```\n\n**疑问**\n\n因为是有序树，所有 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在p, q区间的.\n\n那么只要从上到下去遍历，遇到 cur节点（第一个节点是5）是数值在[p, q]区间中则一定可以说明该节点cur就是q 和 p的公共祖先。 \n\n那问题来了，**一定是最近公共祖先吗**？\n\n**答**\n\n以1 和 9 为例，我们从根节点搜索，第一次遇到 cur节点是数值在[p, q]区间中，即 节点5，此时可以说明 p 和 q 一定分别存在于 节点 5的左子树，和右子树中。此时节点5是不是最近公共祖先？ 如果 以5继续向下遍历，（即采用普通二叉树找最近公共祖先的方法遍历），左和右都会分别找到节点，即5一定是1 和 9 的最近公共祖先\n\n![image-20221019110915902](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/19/11091616661489561666148956018S9OSeB-image-20221019110915902.png)\n\n[参考](https://programmercarl.com/0235.二叉搜索树的最近公共祖先.html#递归法)\n\n\n\n#### 写法2\n\nhttps://mp.weixin.qq.com/s/njl6nuid0aalZdH5tuDpqQ\n\n```java\nTreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    // 保证 val1 较小，val2 较大\n    int val1 = Math.min(p.val, q.val);\n    int val2 = Math.max(p.val, q.val);\n    return find(root, val1, val2);\n}\n\n// 在 BST 中寻找 val1 和 val2 的最近公共祖先节点\nTreeNode find(TreeNode root, int val1, int val2) {\n    if (root == null) {\n        return null;\n    }\n    if (root.val > val2) {\t// 大于val2一定大于val1\n        // 当前节点太大，去左子树找\n        return find(root.left, val1, val2);\n    }\n    if (root.val < val1) {\n        // 当前节点太小，去右子树找\n        return find(root.right, val1, val2);\n    }\n    // val1 <= root.val <= val2\n    // 则当前节点就是最近公共祖先, 解释见上方\n    return root;\n}\n```\n\n\n\n#### 方法二：迭代\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        while(root != null) {\n            if(root.val > p.val && root.val > q.val) {\n                root = root.left;\n            } else if(root.val < p.val && root.val < q.val) {\n                root = root.right;\n            } else {\n                return root;\n            }\n        }\n\n        return null;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"03-1676 题「二叉树的最近公共祖先 IV.md","path":"002-数据结构与算法/007-二叉树/01-公共祖先问题/03-1676 题「二叉树的最近公共祖先 IV.md","content":"###  [1676 题「二叉树的最近公共祖先 IV」](https://mp.weixin.qq.com/s/njl6nuid0aalZdH5tuDpqQ)\n\n多个节点的最近公共祖先，且nodes一定存在二叉树中\n\n```java\nTreeNode lowestCommonAncestor(TreeNode root, TreeNode[] nodes) { \n\t\tHashSet<Integer> hs = new HashSet<>();\n  \tfor(TreeNode node : nodes) {\n    \t\ths.add(node.val);\n    }\n  \n  \treturn find(root, hs);\n}\n\nTreeNode find(TreeNode root, HashSet<Integer> values) {\n  \tif(root == null) return null;\n  \tif(values.contains(root.val)) returnn root;\n  \tTreeNode left = find(root.left, values);\n  \tTreeNode right = find(root.right, values);\n  \t\n  \t// 同上一题\n  \tif(left != null && right != null) return root;\n  \t\n  \treturn left != null ? left, right;\n}\n```\n\n\n\n\n\n\n\n","timestamp":1694699764227},{"name":"04-1644 题「二叉树的最近公共祖先 II」.md","path":"002-数据结构与算法/007-二叉树/01-公共祖先问题/04-1644 题「二叉树的最近公共祖先 II」.md","content":"\n\n### 1644 题「二叉树的最近公共祖先 II」\n\n找p和q的公共祖先，如果p或q不存在，返回null\n\n```java\nboolean findP = false, findQ = false;\n\nTreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { \n\t\tTreeNode res = find(root, p.val, q.val);\n    if (!foundP || !foundQ) {\n        return null;\n    }\n    // p 和 q 都存在二叉树中，才有公共祖先\n    return res;\n}\n\nTreeNode find(TreeNode root, int val1, int val2) {\n\tif(root == null) return null;\n  \n  TreeNode left = find(root.left, val1, val2);\n  TreeNode right = find(root.right, val1, val2);\n  \n  if(left ！= null && right != null) return root;\n  \n  // 后序位置，判断当前节点是不是目标值\n    if (root.val == val1 || root.val == val2) {\n        // 找到了，记录一下\n        if (root.val == val1) foundP = true;\n        if (root.val == val2) foundQ = true;\n        return root;\n    }\n\n    return left != null ? left : right;\n}\n```\n\n","timestamp":1694699764227},{"name":"05-1650 二叉树的最近公共祖先 III.md","path":"002-数据结构与算法/007-二叉树/01-公共祖先问题/05-1650 二叉树的最近公共祖先 III.md","content":"\n\n### 1650 二叉树的最近公共祖先 III\n\n带父节点的二叉树\n\n将root看成next，就是相交链表的问题\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/18/21113416923642941692364294959phRIxW-111705167746782516774678255115BRRu5-640.png\" alt=\"图片\" style=\"zoom:50%;\" />\n\n```java\nNode lowestCommonAncestor(Node p, Node q) {\n    // 施展链表双指针技巧\n    Node a = p, b = q;\n    while (a != b) {\n        // a 走一步，如果走到根节点，转到 q 节点\n        if (a == null) a = q;\n        else           a = a.parent;\n        // b 走一步，如果走到根节点，转到 p 节点\n        if (b == null) b = p;\n        else           b = b.parent;\n    }\n    return a;\n}\n```\n\n方式二\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) {\n            return null;\n        }\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while(a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-总结.md","path":"002-数据结构与算法/007-二叉树/100-总结.md","content":"### 确定递归函数的参数和返回类型\n\n参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。\n\n再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：\n\n-   如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）\n-   如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在[236. 二叉树的最近公共祖先 (opens new window)](https://programmercarl.com/0236.二叉树的最近公共祖先.html)中介绍）\n-   如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）\n\n[参考](https://programmercarl.com/0112.路径总和.html#思路)\n\n![image-20221018134300255](/Users/kuan/Library/Application%20Support/typora-user-images/image-20221018134300255.png)\n\n[二叉树公共祖先](https://programmercarl.com/0236.二叉树的最近公共祖先.html#java)\n\n\n\n\n\n二叉搜索树\n\n-   二叉搜索树的题目可以转为在有序数组中求解（中序遍历为有序数组）\n\n\n\n有增删用\n\n```\nLinkedList<String> path = new LinkedList<>();\n不用\nList<String> path = new ArrayList<>();\n```\n\n","timestamp":1694699764227},{"name":"101-二叉树遍历.md","path":"002-数据结构与算法/007-二叉树/101-二叉树遍历.md","content":"### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\n\n#### 方法一：递归\n\n**java**\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        preOrder(root, res);\n        return res;\n\n    }\n\n    public void preOrder(TreeNode root, List<Integer> res) {\n        if(root == null) {\n            return;\n        }\n        res.add(root.val);\n        preOrder(root.left, res);\n        preOrder(root.right, res);\n    }\n}\n```\n\n#### 方法二：迭代 + 栈(为主)\n\nJava\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (root == null) {\n            return res;\n        }\n\n        Deque<TreeNode> stack = new LinkedList<TreeNode>();\n        TreeNode node = root;\n        while (!stack.isEmpty() || node != null) {\n            while (node != null) {\n                res.add(node.val);\n                stack.push(node);\n                node = node.left;\n            }\n            node = stack.pop();\n            node = node.right;\n        }\n        return res;\n    }\n}\n\n作者：LeetCode-Solution\n链接：https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n写法二\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) {\n            return res;\n        }\n        \n        Deque<TreeNode> stack = new LinkedList<>();\n        stack.push(root);\n        while(!stack.isEmpty()) {\n            TreeNode tmp = stack.pop();\n            res.add(tmp.val);\n            if(tmp.right != null) {\n                stack.push(tmp.right);\n            }\n            if(tmp.left != null) {\n                stack.push(tmp.left);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\n\n#### 方法一：递归\n\njava\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        postOrder(root, res);\n        return res;\n\n    }\n\n    public void postOrder(TreeNode root, List<Integer> res) {\n        if(root == null) {\n            return;\n        }\n        \n        postOrder(root.left, res);\n        postOrder(root.right, res);\n        res.add(root.val);\n    }\n}\n```\n\n#### 方法二：迭代 + 栈\n\n![前序到后序](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/09/2249421665326982166532698287249dyC8-20200808200338924.png)\n\n后序遍历是【左右中】，前序遍历是【中左右】，调整顺序为【中右左】，再将最后的res数组翻转，即左右中。\n\njava\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) {\n            return res;\n        }\n\n        Deque<TreeNode> s = new LinkedList<>();\n        s.push(root);\n        while(!s.isEmpty()) {\n            TreeNode node = s.pop();\n            res.add(node.val);\n            if(node.left != null) s.push(node.left);\n            if(node.right != null) s.push(node.right);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n方式2（为主）\n\n```java\n        List<Integer> res = new ArrayList<>();\n        TreeNode cur = root;\n        TreeNode pre = null;\n        Deque<TreeNode> s = new LinkedList<>();\n        while(!s.isEmpty() || cur != null) {\n            while(cur != null) {\n                s.push(cur);\n                cur = cur.left;\n            }\n            cur = s.pop();\n  \n            if(cur.right == null || pre == cur.right) { // 右节点为空 or 已经访问过\n                res.add(cur.val);\n                pre = cur;\n                cur = null;\n            } else {    // 右节点未访问，先回存根节点，访问右节点\n                s.push(cur);\n                cur = cur.right;\n            }\n        }\n\n        return res;\n\n作者：LeetCode-Solution\n链接：https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n\nJava\n\n#### 方法一：递归\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        inOrder(root, res);\n        return res;\n\n    }\n\n    public void inOrder(TreeNode root, List<Integer> res) {\n        if(root == null) {\n            return;\n        }\n        \n        inOrder(root.left, res);\n        res.add(root.val);\n        inOrder(root.right, res);\n    }\n}\n```\n\n#### 方法二：迭代 + 栈\n\njava\n\n写法一\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) {\n            return res;\n        }\n\n        Deque<TreeNode> s = new LinkedList<>();\n        TreeNode cur = root;\n        while(cur != null || !s.isEmpty()) {\n            if(cur != null) {\n                s.push(cur);\n                cur = cur.left;\n            } else {\n                cur = s.pop();\n                res.add(cur.val);\n                cur = cur.right;\n            }\n        }\n        return res;\n    }\n}\n```\n\n写法二(为主)\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        TreeNode cur = root;\n        Deque<TreeNode> s = new LinkedList<>();\n        while(!s.isEmpty() || cur != null) {\n            while(cur != null) {\n                s.push(cur);\n                cur = cur.left;\n            }\n            cur = s.pop();\n            res.add(cur.val);\n            cur = cur.right;\n        }\n\n        return res;\n    }\n}\n\n作者：LeetCode-Solution\n链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n#### 方法三：前中后统一格式写法\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) {\n            return res;\n        }\n\n        Deque<TreeNode> s = new LinkedList<>();\n        s.push(root);\n        while(!s.isEmpty()) {\n            TreeNode node = s.peek();\n            if(node != null) {\n                s.pop();\n                if(node.right != null) s.push(node.right);\n                s.push(node);\n                s.push(null);  // 中节点访问过，但是还没有处理，加入空节点做为标记\n                if(node.left != null) s.push(node.left);\n            } else {\n                s.pop();    // 弹出null\n                node = s.peek();\n                s.pop();    // 弹出访问节点\n                res.add(node.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n\n\n### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)\n\n#### 方法一：迭代 + 队列\n\nJava\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(root == null) {\n            return res;\n        }\n\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        int n = 1; // 当层节点数\n        while(!q.isEmpty()) {\n            int l = 0; // 统计下层节点数\n            List<Integer> list = new ArrayList<>();\n            while(n-- > 0) {\n                TreeNode node = q.poll();\n                list.add(node.val);\n                if(node.left != null) {\n                    q.add(node.left);\n                    l++;\n                }\n                if(node.right != null) {\n                    q.add(node.right);\n                    l++;\n                }\n            }\n            n = l;\n            res.add(list);\n        }\n        \n        return res;\n    }\n}\n```\n\n优化：队列的大小即为当前层节点数，不需要n和l分别统计\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(root == null) {\n            return res;\n        }\n\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n\n        while(!q.isEmpty()) {\n            List<Integer> list = new ArrayList<>();\n            int len = q.size();\n\n            while(len-- > 0) {\n                TreeNode node = q.poll();\n                list.add(node.val);\n\n                if(node.left != null) q.add(node.left);\n                if(node.right != null) q.add(node.right);\n            }\n            res.add(list);\n        }\n        \n        return res;\n    }\n}\n```\n\n#### 方法二：递归 + DFS\n\njava\n\n```java\nclass Solution {\n\n    List<List<Integer>> res = new ArrayList<>();\n\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        \n        if(root == null) {\n            return res;\n        }\n\n        levelOrder(root, 0);\n        \n        return res;\n    }\n\n    public void levelOrder(TreeNode root, int deep) {\n        if(root == null) {\n            return;\n        }\n\n        // 初始化存储当前层节点的空间\n        if(res.size() <= deep) {\n            List<Integer> list = new ArrayList<>();\n            res.add(list);\n        }\n\n        res.get(deep).add(root.val);  // 根据deep来找到当前节点要存储的地方\n        levelOrder(root.left, deep + 1);\n        levelOrder(root.right, deep + 1);\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"102-二叉树的层次遍历拓展.md","path":"002-数据结构与算法/007-二叉树/102-二叉树的层次遍历拓展.md","content":"### [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)\n\n```\n给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n```\n\n二叉树层次的变种\n\n-   方案二： 层序遍历完后将结果集反转\n\n```java\nList<List<Integer>> result = new ArrayList<>();\nfor (int i = list.size() - 1; i >= 0; i-- ) {\n  result.add(list.get(i));\n}\n```\n\n-   方案一：在遍历完一层节点之后，将存储该层节点值的列表添加到结果列表的头部\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(root == null) return res;\n\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            int len = q.size();\n            List<Integer> list = new ArrayList<>();\n            while(len-- > 0) {\n                TreeNode node = q.poll();\n                list.add(node.val);\n\n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);\n            }\n            res.add(0, list);  // 头插\n        }\n        \n        return res;\n    }\n}\n```\n\n\n\n### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)\n\n错解：漏掉左子树比右子树高的情况\n\n有右进右，无右进左\n\n当[1,2,3,4]，输出为[1,3]，少了4\n\n```java\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) return res;\n\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            TreeNode node = q.poll();\n            res.add(node.val);\n\n            if(node.right != null) {\n                q.offer(node.right);\n            } else {\n                if(node.left != null) q.offer(node.left);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法一：BFS + 迭代层次遍历\n\n层次遍历的改写\n\n只将当前层最后一个节点的值加到结果集中\n\n```java\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) return res;\n\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            int len = q.size();\n            while(len-- > 0) {\n                TreeNode node = q.poll();\n\n                if(len == 0) {\t\t// 只将当前层最后一个节点的值加到结果集中\n                    res.add(node.val);\n                }\n\n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法二：DFS 只存最右节点\n\n思路：\n\n对树进行深度优先搜索，在搜索过程中，总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。\n\nmap中存储每一层最右节点的深度及节点值（即首次访问到的当层节点），遍历到同层的其他节点时，当该层存在值时，不再覆盖\n\n```java\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> res = new ArrayList<>();  // 结果集\n        if(root == null) return res;\n\n        Map<Integer, Integer> map = new HashMap<>();  // 每一层的最右节点 <深度，节点值>\n        Deque<TreeNode> nodeS = new LinkedList<>();\t\t// 节点栈\n        Deque<Integer> depthS = new LinkedList<>();\t\t// 节点对应的深度\n        nodeS.push(root);\n        depthS.push(0);\n\n        while(!nodeS.isEmpty()) {\n            TreeNode node = nodeS.pop();\n            int depth = depthS.pop();\n\n            if(node != null) {\n                if(!map.containsKey(depth)) {\t\t// 不为空说明已经存放了最右节点的值\n                    map.put(depth, node.val);\n                }\n                \n              \t// 左节点先入栈，保证右节点先出栈\n                nodeS.push(node.left);\n                depthS.push(depth + 1);\n                nodeS.push(node.right);\n                depthS.push(depth + 1);\n            }\n        }\n\n        for(int i=0; i<map.size(); i++) {\n            res.add(map.get(i));\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n### [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)\n\n#### 方法一：BFS\n\n层次遍历，统计\n\n```java\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<Double> res = new ArrayList<>();\n        if(root == null) return res;\n\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            int len = q.size();\n            double sum = 0;\n\n            for(int i=0; i<len; i++) {\n                TreeNode node = q.poll();\n                sum += node.val;\n\n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);\n            }\n            res.add(sum / len);\n        }\n        return res;\n    }\n}\n```\n\n\n\n### [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)\n\n#### 方法一：BFS\n\n同二叉树层序遍历\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(root == null) return res;\n\n        Queue<Node> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            List<Integer> list = new ArrayList<>();\n            int len = q.size();\n            while(len-- > 0) {\n                Node node = q.poll();\n                list.add(node.val);\n\n                if(node.children != null) {\n                    for(Node child : node.children) {\n                        if(child != null) q.offer(child);\n                    }\n                }\n                \n            }\n            res.add(list);\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n### [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)\n\n#### 方法一：深度优先搜索 TODO\n\n\n\n#### 方法二：BFS\n\n```java\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) return res;\n\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            int len = q.size();\n            int max = Integer.MIN_VALUE;\n            while(len-- > 0) {\n                TreeNode node = q.poll();\n                max = Math.max(node.val, max);\n\n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);\n            }\n            res.add(max);\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n### [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)\n\n完美二叉树：左右节点都不为null\n\n#### 方法一：BFS\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if(root == null) return root;\n\n        Queue<Node> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            int len = q.size();\n            while(len-- > 0) {\n                Node node = q.poll();\n                if(len != 0) {\n                    node.next = q.peek();\n                }\n\n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);\n            }\n        }\n\n        return root;\n    }\n}\n```\n\n方式2：也可以记录pre节点\n\n```\n\n```\n\n\n\n#### 方法二：使用已建立的 nextnext 指针 TODO\n\nhttps://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/\n\n情况1：两个节点同属一个父节点\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/03/31/16493916802525791680252579511ThWG9X-4.png\" alt=\"fig4\" style=\"zoom: 33%;\" />\n\n情况2: 两个节点属于不同父节点\n\n<img src=\"https://assets.leetcode-cn.com/solution-static/116/5.png\" alt=\"fig5\" style=\"zoom:33%;\" />\n\n```java\n// 遍历当前层，处理下一层\nclass Solution {\n    public Node connect(Node root) {\n        if(root == null) return null;\n        Node leftMost = root;   // 每层的最左节点\n        while(leftMost.left != null) {  // 还存在下一层，则继续遍历\n            // 遍历当前层\n            Node head = leftMost;   \n            while(head != null) {\n                // 情况1\n                head.left.next = head.right;\n\n                // 情况2\n                if(head.next != null) {\n                    head.right.next = head.next.left;\n                }\n\n                head = head.next;\n            }\n\n            leftMost = leftMost.left;\n        }\n\n        return root;\n    }\n}\n```\n\n递归实现\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if(root==null){\n            return root;\n        }\n        if(root.left!=null){\n            root.left.next=root.right;\n            root.right.next=root.next!=null?root.next.left:null;\n            connect(root.left);\n            connect(root.right);\n        }\n        return root;\n    }\n}\n```\n\n\n\n### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)\n\n以方法二为主，本质相同，便于理解\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if(root == null) return root;\n\n        Node cur = root;\n        while(cur != null) {\n            Node dummy = new Node(0); // cur的下一层虚拟头节点\n            Node p = dummy;     // cur的下一层链表的遍历指针\n\n            // 遍历当前层链表\n            while(cur != null) {  \n                if(cur.left != null) {\n                    p.next = cur.left;\n                    p = p.next;\n                }\n                if(cur.right != null) {\n                    p.next = cur.right;\n                    p = p.next;\n                }\n                cur = cur.next;  // 当前层指针右移\n            }\n            cur = dummy.next;  // 遍历下一层\n        }\n        return root;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/solution/bfsjie-jue-zui-hao-de-ji-bai-liao-100de-yong-hu-by/)\n\n方式二：根据题目: [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) 修改，便于理解\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if(root == null) return root;\n\n        Node leftMost = root;           // 最左侧节点记录指针，用于切换到下一层\n        while(leftMost != null) {       // 区别1\n            Node cur = leftMost;        // 当前层遍历指针\n            Node dummy = new Node(0);   // 下一层左左侧节点的记录指针\n            Node p = dummy;             // 下一层的遍历指针\n            // 遍历当前层，处理下一层，将下一层串起来\n            while(cur != null) {\n                if(cur.left != null) {\n                    p.next = cur.left;\n                    p = p.next;\n                }\n                if(cur.right != null) {\n                    p.next = cur.right;\n                    p = p.next;\n                }\n                cur = cur.next;\n            }\n            leftMost = dummy.next;  // 更新最左侧节点为下一层的头节点\n        }\n\n        return root;\n    }\n}\n```\n\n\n\n\n\n### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n\n#### 方法一：递归 + DFS\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n\n        int left = maxDepth(root.left) + 1;\n        int right = maxDepth(root.right) + 1;\n        return Math.max(left, right);\n    }\n}\n```\n\n#### 方法二：迭代\n\n层序遍历\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        int depth = 0;\n        Deque<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            int len = q.size();\n            depth++;\n            TreeNode node;\n            while(len-- > 0) {\n                 node = q.poll();\n                 if(node.left != null) q.offer(node.left);\n                 if(node.right != null) q.offer(node.right);\n            }\n        }\n\n        return depth;\n    }\n}\n```\n\n\n\n### [559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)\n\n```java\nclass Solution {\n    public int maxDepth(Node root) {\n        if(root == null) return 0;\n        int max = 0;\n\n        for(Node child : root.children) {\n            max = Math.max(max,  maxDepth(child));\n        }\n\n        return max + 1;\n    }\n}\n```\n\n迭代法同二叉树\n\n\n\n### [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/01/16581416803394941680339494589rvMavc-image-20230401165814425.png\" alt=\"image-20230401165814425\" style=\"zoom:33%;\" />\n\n#### 方法一：递归\n\n```java\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if(root == null) return 0;\n        int leftDepth = minDepth(root.left);\n        int rightDepth = minDepth(root.right);\n        if(root.left == null) {\n            return rightDepth + 1;\n        }\n        if(root.right == null) {\n            return leftDepth + 1;\n        }\n\n        return Math.min(leftDepth, rightDepth) + 1;\n    }\n}\n```\n\n方式二：\n\n```java\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if(root == null) return 0;\n\t\t\t\t\n      \t// 找到叶子节点\n        if(root.left == null && root.right == null) {\n            return 1;\n        }\n        int min = Integer.MAX_VALUE;\n        if(root.left != null) {\n            min = Math.min(minDepth(root.left), min);\n        }\n        if(root.right != null) {\n            min = Math.min(minDepth(root.right), min);\n        }\n\n        return min + 1;\n    }\n}\n```\n\n#### 方法二：迭代\n\n层序遍历\n\n```java\n\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if(root == null) return 0;\n        Deque<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        int depth = 0;\n        while(!q.isEmpty()) {\n            int len = q.size();\n            TreeNode node;\n            depth++;\n            while(len-- > 0) {\n                node = q.poll();\n                if(node.left == null && node.right == null) return depth;\n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right); \n            }\n        }\n\n        return depth;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"103-翻转二叉树.md","path":"002-数据结构与算法/007-二叉树/103-翻转二叉树.md","content":"### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)\n\n#### 方法一：递归\n\njava\n\n```java\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root == null) return root;\n\n        TreeNode tmp = root.left;\n        root.left = root.right;\n        root.right = tmp;\n        invertTree(root.left);\n        invertTree(root.right);\n\n        return root;\n    }\n}\n```\n\n写法二\n\n```java\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n      \n        TreeNode left = invertTree(root.left);\n        TreeNode right = invertTree(root.right);\n        root.left = right;\n        root.right = left;\n      \n        return root;\n    }\n}\n```\n\n#### 方法二：DFS深度优先遍历\n\n前序 或 后序遍历都行\n\n```java\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root == null) return root;\n\n        swap(root); // 前序写法\n        invertTree(root.left);\n        invertTree(root.right);\n        // swap(root);\t// 后续写法\n\n        return root;\n    }\n\n    public void swap(TreeNode root) {\n        TreeNode tmp = root.left;\n        root.left = root.right;\n        root.right = tmp;\n    }\n}\n```\n\n#### 方法三：BFS广度优先遍历\n\n```java\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root == null) return root;\n\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            int len = q.size();\n            while(len-- > 0) {\n                TreeNode node = q.poll();\n                // swap(node);\t// 前序写法\n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);\n                swap(node);\t\t// 后续写法\n            }\n        }\n\n        return root;\n    }\n\n    public void swap(TreeNode root) {\n        TreeNode tmp = root.left;\n        root.left = root.right;\n        root.right = tmp;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"104-对称二叉树 .md","path":"002-数据结构与算法/007-二叉树/104-对称二叉树 .md","content":"### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)\n\n注意：对比的不是父节点的左右子树，而是两个树的左子树 / 右子树\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if(root == null) return true;\n        \n        return test(root.left, root.right);\n    }\n\n    public boolean test(TreeNode n1, TreeNode n2) {\n        if(n1 == null && n2 == null) return true;\n        if((n1 == null && n2 != null) || (n1 != null && n2 == null)) {\n            return false;\n        }\n        if(n1.val != n2.val) return false;\n\n        return test(n1.left, n2.right) && test(n1.right, n2.left);\n    }\n}\n```\n\n优化\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return check(root, root);\n    }\n\n    public boolean check(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);\n    }\n}\n```\n\n迭代\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if(root == null) return true;\n        Deque<TreeNode> q = new LinkedList<>();\n        q.offer(root.left);\n        q.offer(root.right);\n        while(!q.isEmpty()) {\n            TreeNode n1 = q.poll();\n            TreeNode n2 = q.poll();\n            if(n1 == null && n2 == null) continue;\n            if(n1 == null || n2 == null) return false;\n            if(n1.val != n2.val) return false;\n            q.offer(n1.left);\n            q.offer(n2.right);\n\n            q.offer(n1.right);\n            q.offer(n2.left);\n        }\n\n        return true;\n    }\n}\n```\n\n其他方法：\n\n-   双队列\n-   栈\n\n\n\n### [100. 相同的树](https://leetcode.cn/problems/same-tree/)\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n\n\n### [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)\n\n#### 错解一\n\n不能通过指针判断两个树是否相等\n\n```java\nclass Solution {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        if(root == null) return subRoot == null;\n        if(root == subRoot) return true;\n        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n    }\n}\n```\n\n#### 错解二：\n\n只判断了根节点，左节点为根节点、右节点为根节点的树是否与subRoot相等，应该遍历整颗树\n\n漏掉了root子树和subRoot相等的情况\n\n```java\nclass Solution {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        if(root == null) {\n            return subRoot == null;\n        }\n        return check(root, subRoot) || check(root.left, subRoot) || check(root.right, subRoot);\n    }\n\n    public boolean check(TreeNode p, TreeNode q) {\n        if(p == null && q == null) {\n            return true;\n        }\n        if(p == null || q == null || p.val != q.val) {\n            return false;\n        }\n        return check(p.left, q.left) && check(p.right, q.right);\n    }\n}\n\n// [1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,2]\n// [1,null,1,null,1,null,1,null,1,null,1,2]\n// 预期：true  返回：false\n```\n\n#### 方法一：DFS搜索暴力匹配\n\n```java\nclass Solution {\n\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) { \n        return dfs(root, subRoot);\n    }\n    \n    public boolean dfs(TreeNode s, TreeNode t) {\n        if(s == null) {\n            return t == null;\n        }\n      \t// s为根，t为根是否相等 || s的左子树为根，t为根 ｜｜ s的右子树为跟， t为根\n        return check(s, t) || dfs(s.left, t) || dfs(s.right, t);\n    }\n\n    public boolean check(TreeNode p, TreeNode q) {\n        if(p == null && q == null) {\n            return true;\n        }\n        if(p == null || q == null || p.val != q.val) {\n            return false;\n        }\n        return check(p.left, q.left) && check(p.right, q.right);\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"105-完全二叉树的节点个数.md","path":"002-数据结构与算法/007-二叉树/105-完全二叉树的节点个数.md","content":"### [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)\n\n满二叉树 = 2^树深度 - 1 （根节点深度为1）\n\n```\n// 1 2 4 8 \n```\n\n#### 方法一：二叉树的性质\n\n分成多个满二叉树，直接用公式计算\n\n![image-20221012210813672](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/12/21081316655800931665580093768i2rLPJ-image-20221012210813672.png)\n\n##### 写法一\n\n都以左子树的深度作为该树的深度\n\n左=右 => 左一定是满二叉树\n\n左!=右  => 右一定是满二叉树，左不一定是\n\n```java\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n\n        int leftDepth = getDepth(root.left);\n        int rightDepth = getDepth(root.right);\n        if(leftDepth == rightDepth) { // 左=右 => 左一定是满二叉树\n            //  左（满二叉树：2^leftDepth - 1） + 右 + 根  \n            return ((1 << leftDepth) - 1) + countNodes(root.right) + 1;\n        } else { // 右一定是满二叉树，左不一定是\n             return ((1 << rightDepth) - 1) + countNodes(root.left) + 1;\n        }\n    }\n\n\n    public int getDepth(TreeNode root) {\n        int depth = 0;\n        while(root != null) {\n            root = root.left;\n            depth++;\n        }\n        return depth;\n    }\n}\n```\n\n[参考：java写法](https://programmercarl.com/0222.完全二叉树的节点个数.html#完全二叉树)\n\n\n\n##### 写法二\n\n![image-20221012211710085](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/12/211710166558063016655806301658Py1z0-image-20221012211710085.png)\n\n左子树depth = 右子树depth => 该树是满二叉树\n\n```java\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n\n        TreeNode l = root.left;\n        TreeNode r = root.right;\n        int leftDepth = 0;\n        int rightDepth = 0;\n        while(l != null) {  // 左子树深度：以左子树深度作为深度\n            l = l.left;\n            leftDepth++;\n        }\n        while(r != null) {  // 右子树深度：以右子树深度作为深度\n            r = r.right;\n            rightDepth++;\n        }\n        if(leftDepth == rightDepth) { // 该树是满二叉树\n            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0\n        }\n      \n      \t// 错解：left > right 并不能说明左就是完全二叉树\n      \t// if(leftDepth > rightDepth) {\n        //     return 1 + (2 << leftDepth) - 1 + countNodes(root.right);\n        // }\n        // return 1 + (2 << rightDepth) - 1 + countNodes(root.left); \n      \n        return countNodes(root.left) + countNodes(root.right) + 1;\n    }\n}\n```\n\n[参考：C++写法](https://programmercarl.com/0222.完全二叉树的节点个数.html#完全二叉树)","timestamp":1694699764227},{"name":"106-平衡二叉树.md","path":"002-数据结构与算法/007-二叉树/106-平衡二叉树.md","content":"### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)\n\n#### 方法一：自顶向下递归\n\n```java\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if(root == null) return true;\n\n        return Math.abs(getHeight(root.left) - getHeight(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);\n    }\n\n    public int getHeight(TreeNode root) {\n        if(root == null) return 0;\n\n        int left = getHeight(root.left);\n        int right = getHeight(root.right);\n\n        return Math.max(left, right) + 1;\n    }\n}\n```\n\n### 方法二：自底向上递归\n\n方法一由于是自顶向下递归，因此对于同一个节点，函数 `getHeight` 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 `getHeight` 只会被调用一次。\n\n思路：\n\n在求高度时就判断是否是平衡二叉树，不是则返回-1\n\n```java\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if(root == null) return true;\n\n        return getHeight(root) >= 0;\n    }\n\n    public int getHeight(TreeNode root) {\n        if(root == null) return 0;\n\n        int left = getHeight(root.left);\n        int right = getHeight(root.right);\n        if(left == -1 || right == -1 || Math.abs(left - right) > 1) {\n            return -1;\n        }\n\n        return Math.max(left, right) + 1;\n    }\n}\n```\n\n优化：左子树返回-1就无需递归右子树\n\n```java\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if(root == null) return true;\n\n        return getHeight(root) >= 0;\n    }\n\n    public int getHeight(TreeNode root) {\n        if(root == null) return 0;\n\n        int left = getHeight(root.left);\n        if(left == -1) {\t// 直接返回，无需递归右子树\n          return -1;\n        }\n      \n        int right = getHeight(root.right);\n        if(right == -1 || Math.abs(left - right) > 1) {\n            return -1;\n        }\n\n        return Math.max(left, right) + 1;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"107-二叉树的所有路径.md","path":"002-数据结构与算法/007-二叉树/107-二叉树的所有路径.md","content":"### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)\n\n#### 方法一：回溯法 + 递归\n\n```java\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<>();\n        if(root == null) {\n            return res;\n        }\n        \n        List<Integer> paths = new ArrayList<>();\n        traversal(root, paths, res);\n        return res;\n    }\n\n  \t// paths、res可以设为全局参数\n    public void traversal(TreeNode root, List<Integer> paths, List<String> res) {\n        paths.add(root.val);\n        if(root.left == null && root.right == null) {  // 遍历到叶子节点\n            StringBuilder sb = new StringBuilder();\n            for(int i = 0; i < paths.size() - 1; i++) {\n                sb.append(paths.get(i)).append(\"->\");\n            }\n            sb.append(paths.get(paths.size() - 1));\n            res.add(sb.toString());\n            return;\n        }\n      \n      \t// 写法2\n      \t/*\n      \tif(root.left == null && root.right == null) {\n            StringBuilder sb = new StringBuilder();\n            for(int i = 0; i < path.size(); i++) {\n                sb.append(path.get(i));\n                if(i != path.size() - 1) {\n                    sb.append(\"->\");\n                }\n            }\n            res.add(sb.toString());\n            return;\n        }*/\n      \n        if(root.left != null) {\n            traversal(root.left, paths, res);\n            paths.remove(paths.size() - 1); // 回溯\n        }\n        if(root.right != null) {\n            traversal(root.right, paths, res);\n            paths.remove(paths.size() - 1); // 回溯\n        }\n    }\n}\n```\n\n[参考](https://programmercarl.com/0257.二叉树的所有路径.html#迭代法)\n\n#### 方法二：回溯法 + 迭代 + 栈\n\n栈存放节点，节点后跟这该节点的访问路径，如\n\n【 1, \"1\",   2, \"1->2\",  3, \"1->3\"】\n\n```java\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<>();\n        if(root == null) {\n            return res;\n        }\n        \n        Deque<Object> s = new LinkedList<>();\n        // 节点和路径同时入栈\n        s.push(root);\n        s.push(root.val + \"\");\n        while(!s.isEmpty()) {\n            // 节点和路径同时出栈\n            String path = (String)s.pop(); \n            TreeNode node = (TreeNode)s.pop();\n            \n            // 叶子结点\n            if(node.left == null && node.right == null) { \n                res.add(path);\n            }\n\n            if(node.left != null) {\n                s.push(node.left);\n                s.push(path +  \"->\" + node.left.val);\n            }\n\n            if(node.right != null) {\n                s.push(node.right);\n                s.push(path +  \"->\" +node.right.val);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n[参考](https://programmercarl.com/0257.二叉树的所有路径.html#迭代法)\n\n\n\n#### 方法三：递归\n\n```java\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<>();\n        \n        buildPath(root, \"\", res);\n        return res;\n    }\n\n    public void buildPath(TreeNode root, String path, List<String> res) {\n        if(root == null) {\n            return;\n        }\n\n        if(root.left == null && root.right == null) {\n            res.add(path + root.val);\n            return;\n        }\n\n        buildPath(root.left, path + root.val + \"->\", res);\n        buildPath(root.right, path + root.val + \"->\", res);\n    }\n}\n```\n\n#### 方法四：回溯 + 迭代 + 队列\n\n层序遍历改写\n\n```java\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<>();\n        \n        Deque<TreeNode> q = new LinkedList<>();   // 节点栈\n        Deque<String> pathQ = new LinkedList<>();\t// 节点栈中对应节点的访问路径\n        q.offer(root);\n        pathQ.offer(root.val + \"\");\n\n        while(!q.isEmpty()) {\n            TreeNode node = q.poll();\n            String path = pathQ.poll();\n\n            // 遍历到子节点\n            if(node.left == null && node.right == null) {\n                res.add(path);\n            }\n\n            if(node.left != null) {\n                q.offer(node.left);\n                pathQ.offer(path + \"->\" + node.left.val);\n            }\n            if(node.right != null) {\n                q.offer(node.right);\n                pathQ.offer(path + \"->\" + node.right.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"108-左叶子之和.md","path":"002-数据结构与算法/007-二叉树/108-左叶子之和.md","content":"### [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)\n\n#### 方法一：递归\n\n递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和\n\n```java\nclass Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        if(root == null) return 0;\n\n        int leftValue = sumOfLeftLeaves(root.left);\t// 左\n        // 通过父节点判断是不是左叶子节点\n        if(root.left != null && root.left.left == null && root.left.right == null) {\n            leftValue = root.left.val;\n        }\n\n        int rightValue = sumOfLeftLeaves(root.right);\t// 右\n\n        int sum = leftValue + rightValue;\t// 中\n      \n        return sum;   \n    }\n}\n```\n\n精简写法\n\n```java\nclass Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        if(root == null) return 0;\n\n      \tint leftValue = 0;\n        // 通过父节点判断是不是左叶子节点\n        if(root.left != null && root.left.left == null && root.left.right == null) {\n            leftValue = root.left.val;\n        }      \n      \n        return leftValue + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);\n    }\n}\n```\n\n[参考](https://programmercarl.com/0404.左叶子之和.html#递归法)\n\n方式二：\n\n```java\nclass Solution {\n    int res = 0;\n    public int sumOfLeftLeaves(TreeNode root) {\n        traversal(root);\n        return res;\n    }\n\n    public void traversal(TreeNode root) {\n        if(root == null) return;\n        if(root.left != null && root.left.left == null && root.left.right == null) {\n            res += root.left.val;\n            // return; // 错误1\n        }\n        traversal(root.left);\n        traversal(root.right);\n    }\n}\n```\n\n\n\n#### 方法二：迭代 - 层序遍历\n\n常规遍历的基础上，通过父节点判断node.left是不是左叶子节点\n\n```java\nclass Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        if(root == null) return 0;\n\n        int res = 0;\n        Deque<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            TreeNode node = q.poll();\n            // 通过父节点判断node.left是不是左叶子节点\n            if(node.left != null && node.left.left == null && node.left.right == null) {\n                res += node.left.val;\n            } \n\n            if(node.left != null) q.offer(node.left);\n            if(node.right != null) q.offer(node.right);\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"109-找树左下角的值.md","path":"002-数据结构与算法/007-二叉树/109-找树左下角的值.md","content":"### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)\n\n#### 方法一：层序遍历\n\n常规层序遍历，返回最后一层的第一个元素。\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Deque<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        List<Integer> list = new ArrayList<>();\n        while(!q.isEmpty()) {\n            int len = q.size();\n            list.clear();\n            while(len-- > 0) {\n                TreeNode node = q.poll();\n                list.add(node.val);\n\n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);\n            }\n        }\n\n        return list.get(0);\n    }\n}\n```\n\n优化：空间优化，只记录每一层的第一个\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Deque<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        int res = 0;\n        while(!q.isEmpty()) {\n            int len = q.size();\n            for(int i=0; i<len; i++) {\n                TreeNode node = q.poll();\n                if(i == 0) {\n                    res = node.val;\n                }\n\n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n#### 方法二：递归 + 回溯\n\n```java\nclass Solution {\n    public int maxDepth = -1;   // 全局变量 记录最大深度\n    public int res;     // 全局变量 最大深度最左节点的数值\n\n    public int findBottomLeftValue(TreeNode root) {\n        traversal(root, 0);\n        return res;\n    }\n\n    public void traversal(TreeNode root, int depth) {\n        if(root == null) return;\n\n        // 找到叶子节点\n        if(root.left == null && root.right == null) {   // 中\n            if(depth > maxDepth) {\n                maxDepth = depth;\n                res = root.val;\n                return;\n            }\n        }\n\n        if(root.left != null) {     // 左\n            depth++;    // 深度 + 1\n            traversal(root.left, depth);    // 进入下一层\n            depth--;    // 回溯\n        }\n\n        if(root.right != null) {    // 右\n            depth++;\n            traversal(root.right, depth);\n            depth--;\n        }\n    }\n}\n```\n\n精简写法：隐藏回溯\n\n```java\nclass Solution {\n    public int maxDepth = -1;   // 全局变量 记录最大深度\n    public int res;     // 全局变量 最大深度最左节点的数值\n\n    public int findBottomLeftValue(TreeNode root) {\n        traversal(root, 0);\n        return res;\n    }\n\n    public void traversal(TreeNode root, int depth) {\n        if(root == null) return;\n\n        // 找到叶子节点\n        if(root.left == null && root.right == null) {   // 中\n            if(depth > maxDepth) {\n                maxDepth = depth;\n                res = root.val;\n                return;\n            }\n        }\n\n        // if(root.left != null) {     // 左\n            traversal(root.left, depth + 1);    // 进入下一层\n        // }\n\n        // if(root.right != null) {    // 右\n            traversal(root.right, depth + 1);\n        // }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"110-路径总和.md","path":"002-数据结构与算法/007-二叉树/110-路径总和.md","content":"### [112. 路径总和](https://leetcode.cn/problems/path-sum/)\n\n找是否存在路径和=target， 存在一条即可\n\n#### 方法一：递归 + 回溯\n\n```java\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if(root == null) return false;\n        return traversal(root, 0, targetSum);\n    }\n\n    public boolean traversal(TreeNode root, int curSum, int targetSum) {\n        \n        if(root.left == null && root.right == null && curSum + root.val== targetSum) { // 遇到叶子节点，并且和为targetSum\n            return true;\n        }\n        if(root.left == null && root.right == null) { // 遇到叶子节点直接返回:没什么实际用处\n            return false;\n        }\n\n        if(root.left != null) {  // 左\n            curSum += root.val;  // 递归，处理节点;\n            if(traversal(root.left, curSum, targetSum)) {\n                return true;    \n            }\n            curSum -= root.val;  // 回溯，撤销处理结果\n        }\n\n        if(root.right != null) {    // 右\n            curSum += root.val;\n            if(traversal(root.right, curSum, targetSum)) {\n                return true;\n            }\n            curSum -= root.val;\n        }\n        return false;\n    }\n}\n```\n\n方式二：\n\n```java\nclass Solution {\n    // LinkedList<TreeNode> path = new LinkedList<>();  // 不需要记录路径\n    int pathSum = 0;\t// 区别\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if(root == null) return false;\n        return traversal(root, targetSum);\n    }\n\n    public boolean traversal(TreeNode root, int targetSum) {\n        // if(root == null) return;  // 可省略，下面已经判断，进入递归root一定不为null\n        // if(pathSum > targetSum) return false;\t// 错误：数节点可能为负数\n        if(root.left == null && root.right == null && pathSum + root.val == targetSum) return true;\n        if(root.left != null) {\n            pathSum += root.val; \n            // path.add(root);  // 不需要\n            if(traversal(root.left, targetSum)) return true;\t// 需要处理返回值，及时返回，不然继续遍历下去，无意义，并且会错过正确答案返回最后遍历的那一条路径结果\n            // path.removeLast(); // 不需要\n            pathSum -= root.val;\n        }\n\n        if(root.right != null) {\n            pathSum += root.val;\n            if(traversal(root.right, targetSum)) return true;\n            pathSum -= root.val;\n        }\n\n        return false;\n    }\n}\n```\n\n优化：改用减法，就不需要传两个参数\n\n```java\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if(root == null) return false;\n        return traversal(root, targetSum - root.val);  // 区别1\n    }\n\n    public boolean traversal(TreeNode root, int count) {\n        \n        if(root.left == null && root.right == null && count == 0) {\n            return true;\n        }\n        if(root.left == null && root.right == null) return false;\n\n        if(root.left != null) {  \t\t// 左\n            count -= root.left.val;  // 递归，处理节点;  \t// 区别2\n            if(traversal(root.left, count)) {\n                return true;    \n            }\n            count += root.left.val;  // 回溯，撤销处理结果\n        }\n\n        if(root.right != null) {    // 右\n            count -= root.right.val;\n            if(traversal(root.right, count)) {\n                return true;\n            }\n            count += root.right.val;\n        }\n        return false;\n    }\n}\n```\n\n简写：隐藏回溯过程\n\n```java\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if(root == null) return false;\n        return traversal(root, targetSum - root.val);\n    }\n\n    public boolean traversal(TreeNode root, int count) {\n        \n        if(root.left == null && root.right == null && count == 0) {\n            return true;\n        }\n        if(root.left == null && root.right == null) return false;\n\n        if(root.left != null) {  // 左\n            if(traversal(root.left, count - root.left.val)) {\n                return true;    \n            }\n        }\n\n        if(root.right != null) {    // 右\n            if(traversal(root.right, count - root.right.val)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n简写\n\n```java\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if(root == null) return false;\n        if(root.left == null && root.right == null && targetSum - root.val == 0) {\n            return true;\n        }\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n    }\n}\n```\n\n\n\n#### 方法二：迭代\n\n原理同[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)，遍历的过程中，将遍历到该节点的路径和也添加到队列中\n\n还可以用两个栈 / 队列，一个节点栈，一个路径和栈， [参考](https://programmercarl.com/0112.路径总和.html#java)\n\n```java\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if(root == null) return false;\n        \n        Deque<Object> q = new LinkedList<>();\n        q.offer(root);\n        q.offer(root.val);\n        while(!q.isEmpty()) {\n            \n            TreeNode node = (TreeNode)q.poll();\n            int sum = (Integer)q.poll();\n\n            if(node.left == null && node.right == null && sum == targetSum) {\n                return true;\n            }\n\n            if(node.left != null) {\n                q.offer(node.left);\n                q.offer(sum + node.left.val);\n            }\n\n            if(node.right != null) {\n                q.offer(node.right);\n                q.offer(sum + node.right.val);\n            }\n        }\n        return false;\n    }\n}\n```\n\n\n\n\n\n### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)\n\n找所有路径和=target\n\n\n\n#### 方法一：递归 + 回溯\n\n##### 方式1: 减法\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    \n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        \n        if(root == null) return res;\n\n        List<Integer> path = new ArrayList<>();\n        path.add(root.val);\n        traversal(root, path, targetSum - root.val);\n        return res;\n    }\n\n    \n    public void traversal(TreeNode root, List<Integer> path, int count) {\n        if(root == null) return;\n        // 遍历到叶子节点，并且路径和为0\n        if(root.left == null && root.right == null && count == 0) {\n            res.add(new ArrayList<>(path));  // 此处不能用res.add(path)，后续的修改会影响path\n            return;\n        }\n        // 叶子节点提前结束\n        if(root.left == null && root.right == null) return;\n\n        if(root.left != null) {\n            path.add(root.left.val);\n            traversal(root.left, path, count - root.left.val);\n            path.remove(path.size() - 1);  // 回溯\n        }\n\n        if(root.right != null) {\n            path.add(root.right.val);\n            traversal(root.right, path, count - root.right.val);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n\n\n写法1: 本质上和上面写法相同 \n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    LinkedList<Integer> path = new LinkedList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        if(root == null) {\n            return res;\n        }\n        traversal(root, targetSum);\n        return res;\n    }\n\n    public void traversal(TreeNode root, int count) {\n        if(root == null) return;\n\n        count -= root.val;\n        path.add(root.val);\n        if(count == 0  && root.left == null && root.right == null) {\n            res.add(new LinkedList(path));\n        }\n\n        if(root.left != null) {\n            traversal(root.left, count);\n            path.removeLast();\n\n        }\n\n        if(root.right != null) {\n            traversal(root.right, count);\n            path.removeLast();\n        }\n    }\n}\n```\n\n写法2（主要）\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    LinkedList<Integer> path = new LinkedList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        if(root == null) {\n            return res;\n        }\n        traversal(root, targetSum);\n        return res;\n    }\n\n    public void traversal(TreeNode root, int count) {\n        if(root == null) return;\n\n        count -= root.val;\n        path.add(root.val);\n        if(count == 0  && root.left == null && root.right == null) {\n            res.add(new LinkedList(path));\n        }\n\t\t\t\t// 区别\n        traversal(root.left, count);\n        traversal(root.right, count);\n        path.removeLast();\n    }\n}\n```\n\n思考：为什么有的时候在左右分支各需要回溯一次，有的时候左右总共只需要回溯一次？\n\n```\n写法2是以根节点为对象，遍历左右，然后删除自己以回溯\n写法1是以左（右）节点为对象，左节点存在则遍历，遍历完删除左节点以回溯；\n```\n\n\n\n##### 方式2： 加法\n\n原始写法，路径相加 = targetSum，不用减法。加法需要多传一个参数\n\n方式一: pathSum为全局变量\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    int pathSum = 0;\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        if(root == null) return res;\n        traversal(root, targetSum);\n        return res;\n    }\n\n    public void traversal(TreeNode root, int targetSum) {\n        if(root == null) return;\n        path.add(root.val);\n        pathSum += root.val;\n        if(targetSum == pathSum  && root.left == null && root.right == null) {\n            res.add(new LinkedList(path));\n            // return;\t// 错误：不能return，否则就不能回溯，会漏其他路径\n        }\n\n        traversal(root.left, targetSum);\n        traversal(root.right, targetSum);\n        path.remove(path.size() - 1);\n        pathSum -= root.val;\n    }\n}\n```\n\n方式二（更优）：pathSum为局部变量，隐藏了pathSum的回溯\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    LinkedList<Integer> path = new LinkedList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        if(root == null) {\n            return res;\n        }\n        traversal(root, targetSum, 0);\n        return res;\n    }\n\n    public void traversal(TreeNode root, int targetSum, int pathSum) {\n        if(root == null) return;\n        path.add(root.val);\n        pathSum += root.val;\n        if(targetSum == pathSum  && root.left == null && root.right == null) {\n            res.add(new LinkedList(path));\n            // return;  // 错误\n        }\n        traversal(root.left, targetSum, pathSum);\n        traversal(root.right, targetSum, pathSum);\n        path.removeLast();\n      \t// pathSum -= root.val;  // 区别：局部变量隐藏了pathSum的回溯\n    }\n}\n```\n\n\n\n#### 方法二：迭代 - 广搜\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    Map<TreeNode, TreeNode> map = new HashMap<>();\n\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        if(root == null) return res;\n        Deque<TreeNode> qNode = new LinkedList<>();\n        Deque<Integer> qSum = new LinkedList<>();\n        qNode.offer(root);\n        qSum.offer(0);\n\n        while(!qNode.isEmpty()) {\n            TreeNode node = qNode.poll();\n            Integer sum = qSum.poll() + node.val;\n            if(sum == targetSum && node.left == null && node.right == null) {\n                res.add(getPath(node));\n            }\n\n            // if(node.left != null && sum < targetSum) {\n            if(node.left != null) {\n                map.put(node.left, node);\n                qNode.offer(node.left);\n                qSum.offer(sum);\n            }\n            if(node.right != null) {\n                map.put(node.right, node);\n                qNode.offer(node.right);\n                qSum.offer(sum);\n            }\n        }\n\n        return res;\n    }\n\n    public List<Integer> getPath(TreeNode node) {\n        List<Integer> path = new ArrayList<>();\n        while(node != null) {\n            path.add(node.val);\n            node = map.get(node);\n        }\n        Collections.reverse(path);\n        return path;\n    }\n}\n```\n\nhttps://leetcode.cn/problems/path-sum-ii/solution/lu-jing-zong-he-ii-by-leetcode-solution/\n","timestamp":1694699764227},{"name":"111-从中序与后序遍历序列构造二叉树.md","path":"002-数据结构与算法/007-二叉树/111-从中序与后序遍历序列构造二叉树.md","content":"### [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n思路：\n\n取后序数组中最后一个元素x，在中序数组中找到x的位置切分，左边为左子树，右边为右子树。根据左、右子树的长度，分别在后序数组中找到对应的后序遍历数组，递归左右子树。\n\n递归函数\n\n-   第一步：如果数组大小为零的话，说明是空节点了。\n-   第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。\n-   第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点\n-   第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）\n-   第五步：切割后序数组，切成后序左数组和后序右数组\n-   第六步：递归处理左区间和右区间\n\n[参考](https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html#思路)\n\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if(inorder.length == 0 || postorder.length == 0) return null;\n        return traversal(inorder, postorder);\n    }\n\n    public TreeNode traversal(int[] inorder, int[] postorder) {\n        if(inorder.length == 0) return null;\n\n        // 后序遍历数组最后一个元素，就是当前的中间节点\n        TreeNode root = new TreeNode(postorder[postorder.length - 1]);\n\n        // 叶子节点, 可以省略\n        if(postorder.length == 1) return root;\n\n        // 找到中序遍历的切割点\n        int index;\n        for(index = 0; index < inorder.length; index++) {\n            if(inorder[index] == root.val) break;\n        }\n\n        // 切割中序数组\n        // 左闭右开区间：[0, index)\n        int[] leftInorder = Arrays.copyOfRange(inorder, 0, index);\n        int[] rightInorder = Arrays.copyOfRange(inorder, index + 1, inorder.length);\n\n        // 切割后序数组\n        // 依然左闭右开，注意这里使用了左中序数组大小作为切割点\n        // [0, leftInorder.length - 1)\n        int[] leftPostorder = Arrays.copyOfRange(postorder, 0, leftInorder.length);  // leftInorder.length可以替换成index，index就是左数组的个数\n        int[] rightPostorder = Arrays.copyOfRange(postorder, leftInorder.length, postorder.length - 1); // 每次去掉postorder最后一个元素\n\n        root.left = traversal(leftInorder, leftPostorder);\n        root.right = traversal(rightInorder, rightPostorder);\n\n        return root;\n    }\n}\n```\n\n优化：在原数组使用下标进行操作，无需复制数组\n\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if(inorder.length == 0 || postorder.length == 0) return null;\n      \n        return traversal(inorder, 0, inorder.length, postorder, 0, postorder.length);\n    }\n\n    public TreeNode traversal(int[] inorder, int inL, int inR, int[] postorder, int postL, int postR) {\n      \t// 不满足左闭右开，说明没有元素，返回空树\n        if(inL >= inR || postL >= postR) {\n            return null;\n        }\n\n        // 后序遍历数组最后一个元素，就是当前的中间节点\n        TreeNode root = new TreeNode(postorder[postR - 1]);\n\n        // 提前结束，也可省略\n        // if(postR - postL == 1) return root;\n\n        // 找到中序遍历的切割点\n        int index;\n        for(index = inL; index < inR; index++) {\n            if(inorder[index] == root.val) break;\n        }\n\n        root.left = traversal(inorder, inL, index, postorder, postL, postL + (index - inL));\n        root.right = traversal(inorder, index + 1, inR, postorder, postL + (index - inL), postR - 1);\n\n        return root;\n    }\n}\n```\n\n优化：可以先遍历一遍inorder，用map存<值，下标>，方便找到中序遍历的切割点(前提：无重复元素)\n\n见下一题\n\n\n\n### 105.从前序与中序遍历序列构造二叉树\n\n```java\nclass Solution {\n\n    Map<Integer, Integer> map = new HashMap<>();\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if(preorder.length == 0 || inorder.length == 0) {\n            return null;\n        }\n\n        for(int i=0; i<inorder.length; i++) {\n            map.put(inorder[i], i);\n        }\n\n        return traversal(preorder, 0, preorder.length, inorder, 0, inorder.length);\n    }\n\n  \t// [)\n    public TreeNode traversal(int[] preorder, int preL, int preR, int[] inorder, int inL, int inR) {\n        if(preL >= preR || inL >= inR) {\n            return null;\n        }\n\n        // 根据前序遍历的第一个元素构造根节点\n        TreeNode root = new TreeNode(preorder[preL]);\n\n        // 找到中序遍历切割点\n        int index = map.get(root.val);  // 根节点下标\n        int leftLen = index - inL;  // 左子树长度\n\n        root.left = traversal(preorder, preL + 1, preL + 1 + leftLen, inorder, inL, index);\n        root.right = traversal(preorder, preL + 1 + leftLen, preR, inorder, index + 1, inR);\n\n        return root;\n    }\n}\n```\n\n\n\n### 889. 前序 + 后序 构造二叉树\n\n```java\nclass Solution {\n    HashMap<Integer, Integer> valToIndex = new HashMap<>();\n\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\n        for (int i = 0; i < postorder.length; i++) {\n            valToIndex.put(postorder[i], i);\n        }\n\n        return build(preorder, 0, preorder.length, postorder, 0, postorder.length);\n    }\n\n  \t// [)\n    public TreeNode build(int[] preorder, int preL, int preR, int[] postorder, int postL, int postR) {\n        if(preL >= preR || postL >= postR) return null;\n        if(preL + 1 == preR || postL + 1 == postR) return new TreeNode(preorder[preL]); // 此处为[），用[]好理解一点\n        TreeNode root = new TreeNode(preorder[preL]);\n        int index = valToIndex.get(preorder[preL + 1]);\n\n        int leftLen = index - postL + 1;    // + 1 找的是左子树的根节点\n        root.left = build(preorder, preL + 1, preL + 1 + leftLen, postorder, postL, index + 1);\n        root.right = build(preorder, preL + 1 + leftLen, preR, postorder, index + 1, postR - 1);\n\n        return root;\n    }   \n}\n```\n\n","timestamp":1694699764227},{"name":"112-最大二叉树.md","path":"002-数据结构与算法/007-二叉树/112-最大二叉树.md","content":"### [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)\n\n常规题，找到最大值的下标构建节点，递归构建左、右子树\n\n```java\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        return traversal(nums, 0, nums.length);\n    }\n\n   // [)]\n    public TreeNode traversal(int[] nums, int start, int end) {\n        if(start >= end) {\n            return null;\n        }\n\n        // 找到最大值下标\n        int maxIndex = start;\n        for(int i = start; i < end; i++) {\n            if(nums[i] > nums[maxIndex]) {\n                maxIndex = i;\n            }\n        }\n\n        TreeNode root = new TreeNode(nums[maxIndex]);\n        root.left = traversal(nums, start, maxIndex);  // 左闭右开：[left, maxIndex)\n        root.right = traversal(nums, maxIndex + 1, end);\n\n        return root;\n    }\n}\n```\n\n更细化的边界\n\n```java\nif (rightIndex - leftIndex < 1) {\t\t// 没有元素了\n  \treturn null;\n}\nif (end - start == 1) {\t\t// 只有一个元素\n  \treturn new TreeNode(nums[start]);\n}\n```\n\n","timestamp":1694699764227},{"name":"113-合并二叉树.md","path":"002-数据结构与算法/007-二叉树/113-合并二叉树.md","content":"### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)\n\n#### 方法一：递归\n\n```java\nclass Solution {\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {   \n        if(root1 == null) return root2;\n        if(root2 == null) return root1;\n\n        root1.val = root1.val + root2.val;\n        root1.left = mergeTrees(root1.left, root2.left);\n        root1.right = mergeTrees(root1.right, root2.right);\n\n        return root1;\n    }\n}\n```\n\n\n\n#### 方法二：迭代 + 队列\n\n-   如何同时遍历两颗树？\n-   遍历的时候处理的是根节点，还是子节点？\n-   空节点要不要放到队列里？\n\n```java\nclass Solution {\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {   \n        if(root1 == null) return root2;\n        if(root2 == null) return root1;\n\n        Deque<TreeNode> q = new LinkedList<>();\n        q.offer(root1);\n        q.offer(root2);\n        while(!q.isEmpty()) {\n            // int len = q.size();\n            TreeNode n1 = q.poll();\n            TreeNode n2 = q.poll();\n            n1.val += n2.val;\n\n            if(n1.left != null && n2.left != null) {\n                q.offer(n1.left);\n                q.offer(n2.left);\n            }\n\n            if(n1.right != null && n2.right != null) {\n                q.offer(n1.right);\n                q.offer(n2.right);\n            }\n\n          \t// 有一边为null，直接采用另一棵树的子树，无需加入队列中处理后序节点\n            if(n1.left == null && n2.left != null) {\n                n1.left = n2.left;\n            }\n\n            if(n1.left != null && n2.left == null) {\n                // 不用处理，以root1为基准\n            }\n\n            if(n1.right == null && n2.right != null) {\n                n1.right = n2.right;\n            }\n\n            if(n1.right != null && n2.right == null) {\n                // 不用处理，以root1为基准\n            } \n        }\n\n        return root1;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"114-二叉搜索树.md","path":"002-数据结构与算法/007-二叉树/114-二叉搜索树.md","content":"### [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)\n\n二叉搜索树是一个有序树：\n\n-   若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n-   若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n-   它的左、右子树也分别为二叉搜索树\n\n\n\n#### 方法一：递归\n\n```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null || root.val == val) {\n        \t return root;\n        }\n        \n        if(root.val > val){\n            return searchBST(root.left, val);\n        } else {\n            return searchBST(root.right, val);\n        }\n    }\n}\n```\n\n\n\n#### 方法二：迭代\n\n```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        while(root != null) {\n            if(root.val == val) return root;\n            if(root.val > val) {\n                root = root.left;\n            } else {\n                root = root.right;\n            }\n        }\n        \n        return null;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"115-98. 验证二叉搜索树.md","path":"002-数据结构与算法/007-二叉树/115-98. 验证二叉搜索树.md","content":"### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)\n\n#### 错解\n\n-   没有判断左右子树 = 根\n-   只判断左 < 根，根 > 右，没有保证右的所有节点 > 根\n\n```java\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        if(root == null) {\n            return true;\n        }\n        if(root.left != null && root.left.val >= root.val) {\n            return false;\n        }\n        if(root.right != null && root.right.val <= root.val) {\n            return false;\n        }\n        return isValidBST(root.left) && isValidBST(root.right);\n    }\n}\n```\n\n\n\n#### 方法一：递归 + 特性\n\n思路\n\n中序遍历下，输出的二叉搜索树节点的数值是有序序列\n\n```java\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        List<Integer> inorder = new ArrayList<>();\n        traversal(root, inorder);\n        for(int i = 1; i < inorder.size(); i++) {\n            if(inorder.get(i) <= inorder.get(i-1)) {\n                return false;\n            }\n        }\n        return true; \n    }\n\n    public void traversal(TreeNode root, List<Integer> inorder) {\n        if(root == null) return;\n        traversal(root.left, inorder);\n        inorder.add(root.val);\n        traversal(root.right, inorder);\n    }\n}\n```\n\n优化：不用转变成数组，可以在递归遍历的过程中直接判断是否有序。\n\n注意：不能直接在`inorder.add(root.val);`替换为判断左 < 根、右 < 根，否则出现的问题同错解\n\n思路：记录一个当前最大值maxValue，在遍历过程中，一直更新maxValue，如果出现maxValue > 节点的情况，则不是有序的\n\n```java\nclass Solution {\n    long maxValue = Long.MIN_VALUE;\n  \n    public boolean isValidBST(TreeNode root) {\n        if(root == null) return true;\n        boolean left = isValidBST(root.left);\n\n        if(maxValue < root.val) {\n            maxValue = root.val;\n        } else {\n            return false;\n        }\n\n        boolean right = isValidBST(root.right);\n        return left && right;\n    } \n}\n```\n\n问题：后台数据有int最小值测试用例，所以都把maxVal改成了longlong最小值，如果测试数据中有 longlong的最小值，怎么办？\n\n思路：避免初始化最小值，如下方法取到最左面节点的数值来比较。\n\n```java\nclass Solution {\n    TreeNode pre = null;\n  \n    public boolean isValidBST(TreeNode root) {\n        if(root == null) return true;\n        boolean left = isValidBST(root.left);\n\n        if(pre != null && pre.val >= root.val) {\n            return false;\n        }\n        pre = root;\n\n        boolean right = isValidBST(root.right);\n        \n        return left && right;\n    } \n}\n```\n\n\n\n其他写法\n\nhttps://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-7b3e4/\n\n```java\nboolean isValidBST(TreeNode root) {\n    return isValidBST(root, null, null);\n}\n\n/* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */\nboolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\n    // base case\n    if (root == null) return true;\n    // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST\n    if (min != null && root.val <= min.val) return false;\n    if (max != null && root.val >= max.val) return false;\n    // 限定左子树的最大值是 root.val，右子树的最小值是 root.val\n    return isValidBST(root.left, min, root) \n        && isValidBST(root.right, root, max);\n}\n```\n\n\n\n#### 方法二：迭代法  + 中序遍历\n\n```java\nclass Solution {\n \n    public boolean isValidBST(TreeNode root) {\n        if(root == null) return true;\n        \n        Deque<TreeNode> s = new LinkedList<>();\n        TreeNode cur = root;\n        TreeNode pre = null;\n        while(cur != null || !s.isEmpty()) {\n            while(cur != null) {\n                s.push(cur);\n                cur = cur.left;\n            }\n            cur = s.pop();\n\n            if(pre != null && pre.val >= cur.val) {\n                return false;\n            }\n            pre = cur;\n            cur = cur.right;\n        }\n        \n        return true;\n    } \n}\n```\n\n优化：cur节点可省略，直接用root节点（无伤大雅）\n\n```java\nclass Solution {\n    TreeNode pre = null;\n    public boolean isValidBST(TreeNode root) {\n        if(root == null) return true;\n        \n        Deque<TreeNode> s = new LinkedList<>();\n        TreeNode pre = null;\n        while(root != null || !s.isEmpty()) {\n            while(root != null) {\n                s.push(root);\n                root = root.left;\n            }\n\n            TreeNode node = s.pop();\n            if(pre != null && pre.val >= node.val) {\n                return false;\n            }\n            pre = node;\n\n            root = node.right;\n        }\n\n        return true;\n    } \n}\n```\n\n","timestamp":1694699764227},{"name":"116-530.二叉搜索树的最小绝对差.md","path":"002-数据结构与算法/007-二叉树/116-530.二叉搜索树的最小绝对差.md","content":"### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)\n\n-   解题思路同98.验证二叉搜索树\n\n\n\n#### 错解一\n\n只比较根与左、右的差值。当树为`[236,104,701,null,227,null,911]`是，最小差值为236 与其左子树的右子树227的差值\n\n```java\nclass Solution {\n\n    public int min = Integer.MAX_VALUE;\n\n    public int getMinimumDifference(TreeNode root) {\n        if(root == null) return 0;\n        if(root.left != null) {\n            min = Math.min(min, root.val - root.left.val);\n        }\n        if(root.right != null) {\n            min = Math.min(min, root.right.val - root.val);\n        }\n        getMinimumDifference(root.left);\n        getMinimumDifference(root.right);\n        return min;\n    }\n}\n```\n\n\n\n#### 方法一：有序数组上求差值\n\n注意是二叉搜索树，二叉搜索树可是有序的。\n\n遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。\n\n```java\nclass Solution {\n    List<Integer> inorder = new ArrayList<>();\n\n    public int getMinimumDifference(TreeNode root) {\n        traversal(root);\n        int res = Integer.MAX_VALUE;\n        for(int i = 1; i < inorder.size(); i++) {\n            res = Math.min(res, inorder.get(i) - inorder.get(i - 1));\n        }\n\n        return res;\n    }\n\n    public void traversal(TreeNode root) {\n        if(root == null) return;\n        traversal(root.left);\n        inorder.add(root.val);\n        traversal(root.right);\n    }\n}\n```\n\n\n\n#### 方法二：递归 + 中序遍历\n\n```java\nclass Solution {\n\n    public int min = Integer.MAX_VALUE;\n    public TreeNode pre = null;\n\n    public int getMinimumDifference(TreeNode root) {\n        if(root == null) return 0;\n        traversal(root);\n        return min;\n    }\n\n    public void traversal(TreeNode root) {\n        if(root == null) return;\n        traversal(root.left);\n        \n        if(pre != null) {\n            min = Math.min(min, root.val - pre.val);\n        }\n        pre = root;\n\n        traversal(root.right);\n    }\n}\n```\n\n\n\n#### 方法三：迭代 + 中序遍历\n\n```java\nclass Solution {\n\n    public int min = Integer.MAX_VALUE;\n    public TreeNode pre = null;\n\n    public int getMinimumDifference(TreeNode root) {\n        if(root == null) return 0;\n        inOrder(root);\n        return min;\n    }\n\n    public void inOrder(TreeNode root) {\n        if(root == null) return;\n        Deque<TreeNode> s = new LinkedList<>();\n        TreeNode pre = null;\n        while(root != null || !s.isEmpty()) {\n            while(root != null) {\n                s.push(root);\n                root = root.left;\n            }\n            root = s.pop();\n            if(pre != null) {\n                min = Math.min(min, root.val - pre.val);\n            }\n            pre = root;\n            root = root.right;\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"117-501. 二叉搜索树中的众数.md","path":"002-数据结构与算法/007-二叉树/117-501. 二叉搜索树中的众数.md","content":"### [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)\n\n#### 方法一：暴力法\n\n问题：\n\n-   采用的辅助空间太多\n-   没有利用二叉搜索树，当作普通树求解\n-   优化：可以省略掉inorder，直接在遍历的时候就map统计\n\n```java\nclass Solution {\n\n    public List<Integer> inorder = new ArrayList<>();\n    public Map<Integer, Integer> map = new HashMap<>();\n\n    public int[] findMode(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) {\n            return new int[]{};\n        }\n\n        // 中序遍历将树转为[]\n        traversal(root);\n\n        // 统计评率，找最大值\n        int max = 0;\n        for(int n : inorder) {\n            map.put(n, map.getOrDefault(n, 0) + 1);\n            max = Math.max(max, map.get(n));\n        }\n\n        // 找频率为max的值\n        for (Integer key : map.keySet()) {\n            if(map.get(key) == max) {\n                res.add(key);\n            }\n        }\n        \n\t\t\t\t// list转为[]\n        int[] d = new int[res.size()];\n        for(int i = 0;i<res.size();i++){\n            d[i] = res.get(i);\n        }\n        return d;\n    }\n\n     public void traversal(TreeNode root) {\n        if(root == null) return;\n        traversal(root.left);\n        inorder.add(root.val);\n        traversal(root.right);\n    }\n}\n```\n\n#### 方法二：递归 + 中序遍历\n\n思路：\n\n利用二叉搜索树的特性，中序遍历后为有序数组\n\n```java\nclass Solution {\n\n    List<Integer> res = new ArrayList<>();\n    int maxCount = 0;\t\t// 最大频率\n    int count = 0;\t\t\t// 频率\n    TreeNode pre = null;\t// 前节点\n\n    public int[] findMode(TreeNode root) {\n        if(root == null) {\n            return new int[]{};\n        }\n        inOrder(root);\n        return res.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n     public void inOrder(TreeNode root) {\n        if(root == null) return;\n        inOrder(root.left);  // 左\n        \n        // 计数\n        if(pre == null || pre.val != root.val) {\n            count = 1;\n        } else {\n            count++;\n        }\n\n        // 有新的众数，先清空原先已经失效的结果集，再添加\n        if(count > maxCount) {\n            maxCount = count;  // 更新最大频率\n            res.clear();\t\t\t // 清空失效结果集\n            res.add(root.val);\n        } else if(count == maxCount) {  // 如果和最大值相同，放进result中\n            res.add(root.val);\n        }\n        pre = root;\n\n        inOrder(root.right);    // 右\n    }\n}\n```\n\n[参考](https://programmercarl.com/0501.二叉搜索树中的众数.html#递归法)\n\n#### 方法三：迭代 + 中序遍历 TODO","timestamp":1694699764227},{"name":"118-701. 二叉搜索树中的插入操作.md","path":"002-数据结构与算法/007-二叉树/118-701. 二叉搜索树中的插入操作.md","content":"### [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)\n\n#### 方法一：递归\n\n```java\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if(root == null) return new TreeNode(val);\n        if(val < root.val) {\n            root.left = insertIntoBST(root.left, val);\n        }\n        if(val > root.val) {\n            root.right = insertIntoBST(root.right, val);\n        }\n        return root;\n    }\n}\n```\n\n#### 方法二：迭代\n\n```java\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if(root == null) return new TreeNode(val);\n        \n        TreeNode pre = null;\n        TreeNode cur = root;\n        while(cur != null) {\n            pre = cur;\n            if(val < cur.val) {\n                cur = cur.left;\n            } else {\n                cur = cur.right;\n            }\n        }\n        if(val > pre.val) {\n            pre.right = new TreeNode(val);\n        } else {\n            pre.left = new TreeNode(val);\n        }\n\n        return root;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"119-450. 删除二叉搜索树中的节点.md","path":"002-数据结构与算法/007-二叉树/119-450. 删除二叉搜索树中的节点.md","content":"### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)\n\n-   判断root==key ？，还是判断root的左、右子树 是否等于 key\n    -   判断root == key 会导致找到节点后，删除的是父节点的左 or 右子树？\n\n\n\n有以下五种情况：\n\n-   第一种情况：没找到删除的节点，遍历到空节点直接返回了\n\n-   找到删除的节点\n\n    -   第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点\n    -   第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点\n    -   第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点\n    -   第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。\n\n    ![450.删除二叉搜索树中的节点](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/19/14521016661623301666162330566AosAkp-008eGmZEly1gnbj3k596mg30dq0aigyz.gif)\n\n#### 方法一：递归\n\n```java\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        // // 情况1：没找到删除的节点，遍历到空节点直接返回了\n        if(root == null) return root;\n\n        // 找到要删除的节点\n        if(key == root.val) {\n            // 情况2: 为叶子节点\n            if(root.left == null && root.right == null) {\n                return null;\n            }\n\n            // 情况3: 左空，右不空\n            if(root.left == null && root.right != null) {\n                return root.right;\n            }\n\n            // 情况4: 左不空，右空\n            if(root.left != null && root.right == null) {\n                return root.left;\n            }\n\n            // 情况5: 左、右都不空\n            if(root.left != null && root.right != null) {\n                // 找到右子树最左下节点\n                TreeNode tmp = root.right;\n                while(tmp.left != null) {\n                    tmp = tmp.left;\n                }\n                // 将删除节点左子树 移到 右子树最左下\n                tmp.left = root.left;\n\n                return root.right;\n            }\n        }\n\n        if(key < root.val) {\n            root.left = deleteNode(root.left, key);\n        }\n        if(key > root.val) {\n            root.right = deleteNode(root.right, key);\n        }\n\n        return root;\n    }\n}\n```\n\n[参考](https://programmercarl.com/0450.删除二叉搜索树中的节点.html#迭代法)\n\n#### 方法二：迭代法 TODO\n\n[参考](https://programmercarl.com/0450.删除二叉搜索树中的节点.html#迭代法)","timestamp":1694699764227},{"name":"120-669. 修剪二叉搜索树.md","path":"002-数据结构与算法/007-二叉树/120-669. 修剪二叉搜索树.md","content":"### [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)\n\n#### 错解一：\n\n直接复用，删除二叉搜索树的代码\n\n**问题：**\n\n 如[2,1,3]，low=3, high=4 , 预期输出[3], 实际输出[3, 1]\n\n根节点2 不在区间，说明左子树也都不在区间，右子树不一定都在区间\n\n```java\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        if(root == null) return root;\n\n        if(root.val < low || root.val > high) {\n            // 叶子节点\n            if(root.left == null && root.right == null) {\n                return null;\n            }\n\n            // 左空，右不空\n            if(root.left == null && root.right != null) {\n                return root.right;\n            }\n\n            // 左不空，右空\n            if(root.left != null && root.right == null) {\n                return root.left;\n            }\n\n\n            // 都不为空\n            if(root.left != null && root.right != null) {\n                // 将左子树放到 右子树最左下\n                TreeNode tmp = root.right;\n                while(tmp.left != null) {\n                    tmp = tmp.left;\n                }\n                tmp.left = root.left;\n\n                return root.right;\n            }\n        }\n\n        root.left = trimBST(root.left, low, high);\n        root.right = trimBST(root.right, low, high);\n\n        return root;\n    }\n}\n```\n\n#### 方法一：递归\n\n```java\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        if(root == null) return root;\n\n        // 小于范围，左子树都不在区间，在右子树中寻找\n        if(root.val < low) {\n            TreeNode right = trimBST(root.right, low, high);\n            return right;\n        }\n\n        // 大于范围，右子树都不在区间，在左子树中寻找\n        if(root.val > high) {\n            TreeNode left = trimBST(root.left, low, high);\n            return left;\n        }\n\n        root.left = trimBST(root.left, low, high);\n        root.right = trimBST(root.right, low, high);\n\n        return root;\n    }\n}\n```\n\n优化\n\n```java\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        if(root == null) return null;\n      \t\n        if(root.val < low) return trimBST(root.right, low, high);\t// 左子树一定都不符合，废弃当前root，修建好右子树，将右子树返回，作为父节点的左子树\n        if(root.val > high) return trimBST(root.left, low, high);\n        root.left = trimBST(root.left, low, high);\n        root.right = trimBST(root.right, low, high);\n\n        return root;\n    }\n}\n```\n\n\n\n#### 方法二：迭代 TODO\n\n[参考](https://programmercarl.com/0669.修剪二叉搜索树.html#迭代法)\n\n```java\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        if(root == null) return null;\n        \n        // 让root处于合法区间\n        while(root != null && (root.val < low || root.val > high)) {\n            if(root.val < low) {\n                root = root.right;\n            } else {\n                root = root.left;\n            }\n        }\n\n        // 处理左孩子元素小于L的情况\n        TreeNode cur = root;\n        while(cur != null) {\n            while(cur.left != null && cur.left.val < low) {  // 根符合，右节点一定符合\n                cur.left = cur.left.right;\n            }\n            cur = cur.left;\n        }\n\n        // 处理右孩子大于R的情况\n        cur = root;\n        while(cur != null) {\n            while(cur.right != null && cur.right.val > high) {  // 根符合，左子树一定符合\n                cur.right = cur.right.left;\n            }\n            cur = cur.right;\n        }\n\n        return root;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"121-108. 将有序数组转换为二叉搜索树.md","path":"002-数据结构与算法/007-二叉树/121-108. 将有序数组转换为二叉搜索树.md","content":"### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)\n\n#### 方法一：递归\n\n```java\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return buildTree(nums, 0, nums.length - 1);\n    }\n\n    public TreeNode buildTree(int[] nums, int l, int r) {\n        if(l > r) {\n            return null;\n        }\n        int mid = l + ((r - l) >> 1);\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = buildTree(nums, l, mid - 1);\n        root.right = buildTree(nums, mid + 1, r);\n\n        return root;\n    }\n}\n```\n\n#### 方法二：迭代 TODO","timestamp":1694699764227},{"name":"122-538. 把二叉搜索树转换为累加树.md","path":"002-数据结构与算法/007-二叉树/122-538. 把二叉搜索树转换为累加树.md","content":"### [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)\n\n思路：\n\n从最右下开始遍历，每次遍历将当前值 + 前一个节点的值。右 、 中 、左 ，即反向中序遍历。\n\n就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]\n\n```java\nclass Solution {\n    TreeNode pre = null;\n    public TreeNode convertBST(TreeNode root) {\n        if(root == null) return root;\n        convertBST(root.right); // 右\n\n        // 中\n        if(pre != null) {\n            root.val += pre.val;\n        }\n        pre = root;\n\n        convertBST(root.left);  // 左\n\n        return root;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"123-额外1382.将二叉搜索树变平衡 .md","path":"002-数据结构与算法/007-二叉树/123-额外1382.将二叉搜索树变平衡 .md","content":"","timestamp":1694699764227},{"name":"00-总结.md","path":"002-数据结构与算法/008-回溯法/01-组合问题/00-总结.md","content":"![image-20230711170612540](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/11/17061216890663721689066372731gdhAG4-image-20230711170612540.png)","timestamp":1694699764227},{"name":"01-77. 组合.md","path":"002-数据结构与算法/008-回溯法/01-组合问题/01-77. 组合.md","content":"### [77. 组合](https://leetcode.cn/problems/combinations/)\n\n\n\n```java\nclass Solution {\n\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>(); // 优化：LinkedList<Integer> path = new LinkedList<>();\n\n    public List<List<Integer>> combine(int n, int k) {\n        trackback(1, n, k);\n\n        return res;\n    }\n\n    public void trackback(int startIndex, int n, int k) {\n        if(path.size() == k) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = startIndex; i <= n; i++) {\n            path.add(i);    // 处理节点\n            trackback(i + 1, n, k);     // 递归，下一层， 此处是i + 1， 不是startIndex+1, 问题见下方\n            path.remove(path.size() - 1);   // 回溯\n        }\n    }\n}\n```\n\n如果是trackback(startIndex + 1, n, k); \n\n```\n如startIndex为1，\n遍历完第一个分支（即第一次取1）,\nfor(int i = startIndex; i <= n; i++)开始横向遍历下一个节点，即取2\npath.add(2)\t// 取2\ntrackback(startIndex + 1 = 2, n, k)  // 进入下一层， i = 2, path.add（2）,会导致重复\n\n4 2\n输出：[[1,2],[1,3],[1,4],[2,2],[2,3],[2,4],[3,2],[3,3],[3,4],[4,2],[4,3],[4,4]]\n预期：[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n```\n\n**优化：剪枝**\n\n![image-20221020144841245](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/20/14484116662485211666248521351PPcsDf-image-20221020144841245.png)\n\n-   已经选择的个数：path.size()\n-   需要的个数：k - path.size();\n-   n个元素中极限的遍历起始位置 n - (k - path.size()) + 1;\n    -   例题中，第一层，从2开始，只有三个元素，已经达不到要求的k=4个元素，剪枝\n    -   为什么要+1？ n = 4, k = 4, path.size() = 0 时，n - (k - path.size())  = 0。根据实际情况，至少会包含起始位置\n\n```java\nclass Solution {\n\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> combine(int n, int k) {\n        trackback(1, n, k);\n\n        return res;\n    }\n\n    public void trackback(int startIndex, int n, int k) {\n        if(path.size() == k) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = startIndex; i <= n - (k - path.size()) + 1; i++) {\t// 剪枝\n            path.add(i);    // 处理节点\n            trackback(i + 1, n, k);     // 递归，下一层，\n            path.remove(path.size() - 1);   // 回溯\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n","timestamp":1694699764227},{"name":"02-216. 组合总和 III.md","path":"002-数据结构与算法/008-回溯法/01-组合问题/02-216. 组合总和 III.md","content":"### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)\n\n```java\nclass Solution {\n\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    int pathSum = 0;\n\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        trackback(n, k, 1);\n        return res;\n    }\n\n    public void trackback(int target, int k, int startIndex) {\n        if(pathSum == target && path.size() == k) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = startIndex; i <= 9; i++) {\n            path.add(i);\n            pathSum += i;\n          \n            trackback(target, k, i + 1);\n          \n            path.remove(path.size() - 1);\n            pathSum -= i;\n        }\n    }\n}\n```\n\n剪枝\n\n```java\nclass Solution {\n\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    int pathSum = 0;\n\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        trackback(n, k, 1);\n        return res;\n    }\n\n    public void trackback(int target, int k, int startIndex) {\n        // 剪枝2: 总和已经超过target\n        if(pathSum > target) {\n            return;\n        }\n        if(pathSum == target && path.size() == k) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) {  // 剪枝1：极限起始点\n            path.add(i);\n            pathSum += i;\n            trackback(target, k, i + 1);\n            path.remove(path.size() - 1);\n            pathSum -= i;\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"03-39. 组合总和.md","path":"002-数据结构与算法/008-回溯法/01-组合问题/03-39. 组合总和.md","content":"\n\n### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)\n\n![image-20221021101144121](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/21/13190216663295421666329542095IDpPXK-10114416663183041666318304237D8ptwh-image-20221021101144121.png)\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    Integer pathSum = 0;\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        trackback(candidates, target, 0);\n        return res;\n    }\n\n    public void trackback(int[] nums, int target, int start) {\n        // 结束条件\n        if(pathSum == target) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        // // 剪枝1: 超出后结束\n         if(pathSum > target) {\n             return;\n         }\n\n        for(int i = start; i < nums.length; i++) {  // 剪枝2: 加上pathSum + nums[i] <= target\n            // if(pathSum > target) { // 剪枝(在上边剪枝更优)\n            //    continue;\n            // }\n            path.add(nums[i]);\n            pathSum += nums[i];\n\n            trackback(nums, target, i);\n\n            path.remove(path.size() - 1);\n            pathSum -= nums[i];\n        }\n    }\n}\n```\n[参考](https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/)\n\n","timestamp":1694699764227},{"name":"04-40. 组合总和 II.md","path":"002-数据结构与算法/008-回溯法/01-组合问题/04-40. 组合总和 II.md","content":"### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)\n\n与39.组合总和的不同处在于：\n\n-   集合有重复元素\n-   要求不能重复使用\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    int pathSum = 0;\n\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\t// 区别1: 先排序，用于限制使用相同元素\n        trackback(candidates, target, 0);\n        return res;\n    }\n\n    public void trackback(int[] candidates, int target, int start) {\n        if(pathSum == target) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        if(pathSum > target) {\n            return;\n        }\n\n        for(int i = start; i < candidates.length; i++) {\n            if(i > start && candidates[i] == candidates[i - 1]) {\t // 区别1: 元素不能重复使用\n                continue;\n            }\n\n            path.add(candidates[i]);\n            pathSum += candidates[i];\n\n            trackback(candidates, target, i + 1);  // 区别3: 从i+1下一个元素开始\n\n            path.remove(path.size() - 1);\n            pathSum -= candidates[i];\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"05-17. 电话号码的字母组合.md","path":"002-数据结构与算法/008-回溯法/01-组合问题/05-17. 电话号码的字母组合.md","content":"### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)\n\n```java\nclass Solution {\n    List<String> res = new ArrayList<>();\n    String[] letterMap = new String[]{\n        \"\",     // 0\n        \"\",     // 1\n        \"abc\",  // 2\n        \"def\",  // 3\n        \"ghi\",  // 4\n        \"jkl\",  // 5\n        \"mno\",  // 6\n        \"pqrs\", // 7\n        \"tuv\",  // 8\n        \"wxyz\", // 9\n    };\n    String str = \"\";\n\n    public List<String> letterCombinations(String digits) {\n        if(\"\".equals(digits)) {    // 此处不能用==\n            return res;\n        }\n        trackback(digits, 0);\n        return res;\n    }\n\n    public void trackback(String digits, int start) {  // start：遍历到的digits的下标\n        // 结束条件，递归层数 = digits的长度\n        if(str.length() == digits.length()) {\n            res.add(str);\n            return;\n        }\n\n        String letterStr = letterMap[digits.charAt(start) - \'0\'];  // 以digits[0]对应的字符串作为树根\n        for(int i = 0; i < letterStr.length(); i++) {  \n            str += letterStr.charAt(i);\n\n            trackback(digits, start + 1);\n\n            str = str.substring(0, str.length() - 1);\n        }\n    }\n}\n```\n\n优化：使用StringBuilder\n\n```java\nclass Solution {\n    List<String> res = new ArrayList<>();\n    String[] letterMap = new String[]{\n        \"\",     // 0\n        \"\",     // 1\n        \"abc\",  // 2\n        \"def\",  // 3\n        \"ghi\",  // 4\n        \"jkl\",  // 5\n        \"mno\",  // 6\n        \"pqrs\", // 7\n        \"tuv\",  // 8\n        \"wxyz\", // 9\n    };\n    // String str = \"\";\n    StringBuilder sb = new StringBuilder();\n\n    public List<String> letterCombinations(String digits) {\n        if(\"\".equals(digits)) {    // 此处不能用==\n            return res;\n        }\n        trackback(digits, 0);\n        return res;\n    }\n\n    public void trackback(String digits, int start) {  // start：遍历到的digits的下标\n        // 结束条件，递归层数 = digits的长度\n        if(start == digits.length()) {\n            res.add(sb.toString());\n            return;\n        }\n\n        String letterStr = letterMap[digits.charAt(start) - \'0\'];  // 以digits[0]对应的字符串作为树根\n        for(int i = 0; i < letterStr.length(); i++) {  \n            sb.append(letterStr.charAt(i));\n\n            trackback(digits, start + 1);\n\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-46. 全排列.md","path":"002-数据结构与算法/008-回溯法/02-排列问题/01-46. 全排列.md","content":"### [46. 全排列](https://leetcode.cn/problems/permutations/)\n\n![image-20221022115431243](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/22/11543116664108711666410871351OvvpEi-image-20221022115431243.png)\n\n不重复元素全排列\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>(); // 频繁增删用LinkedList\n\n    public List<List<Integer>> permute(int[] nums) {\n        trackback(nums, new boolean[nums.length]);\n        return res;\n    }\n\n    public void trackback(int[] nums,  boolean[] used) {\n        if(path.size() == nums.length) {\n            res.add(new ArrayList<>(path));\t// 易错点\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(used[i]) {\t\t// used[i]==true 说明同一树枝使用过\n                continue;\n            }\n\n            path.add(nums[i]);\n            used[i] = true;\n\n            trackback(nums, used);\n\n            used[i] = false;\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n**优化：**\n\n不使用used，直接在path中判断是否存在该数字来判断是否已经使用\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> permute(int[] nums) {\n        trackback(nums);\n        return res;\n    }\n\n    public void trackback(int[] nums) {\n        if(path.size() == nums.length) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            // 如果path中已有，则跳过\n            if (path.contains(nums[i])) {\n                continue;\n            } \n\n            path.add(nums[i]);\n\n            trackback(nums);\n\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n其他写法：频繁增删用LinkedList\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n\n    public List<List<Integer>> permute(int[] nums) {\n        LinkedList<Integer> path = new LinkedList<>();\n        boolean[] used = new boolean[nums.length];\n        backtrack(nums, path, used);\n        return res;\n    }\n\n    public void backtrack(int[] nums, LinkedList<Integer> path, boolean[] used) {\n        if(path.size() == nums.length) {\n            res.add(new LinkedList(path));\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(used[i]) {\n                continue;\n            }\n\n            used[i] = true;\n            path.add(nums[i]);\n            backtrack(nums, path, used);\n            path.removeLast();\n            used[i] = false;\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-47. 全排列 II.md","path":"002-数据结构与算法/008-回溯法/02-排列问题/02-47. 全排列 II.md","content":"### [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)\n\n包含重复元素的全排列\n\n#### 写法1: 树枝去重\n\n![image-20230713135753288](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/13/13575316892278731689227873425K8WHBe-image-20230713135753288.png)\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        trackback(nums, new boolean[nums.length]);\n        return res;\n    }\n\n    public void trackback(int[] nums, boolean[] used) {\n        if(path.size() == nums.length) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(i > 0 && nums[i] == nums[i-1] && used[i-1]) {  // 树枝去重\n                continue;\n            }\n            if(used[i]) {  // 树枝去重，已使用过的元素\n                continue;\n            }\n\n            used[i] = true;\n            path.add(nums[i]);\n\n            trackback(nums, used);\n\n            used[i] = false;\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n#### 写法2: 树层去重\n\n优化\n\n![image-20221022145505061](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/22/14550516664217051666421705203uD1Rvn-image-20221022145505061.png)\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        trackback(nums, new boolean[nums.length]);\n        return res;\n    }\n\n    public void trackback(int[] nums, boolean[] used) {\n        if(path.size() == nums.length) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(i > 0 && nums[i] == nums[i-1] && used[i-1] == false) {  // 树层去重\n                continue;\n            }\n            if(used[i]) {  // 树枝去重，已使用过的元素\n                continue;\n            }\n\n            used[i] = true;\n            path.add(nums[i]);\n\n            trackback(nums, used);\n\n            used[i] = false;\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n[参考](https://programmercarl.com/0047.全排列II.html#拓展)\n\n\n\n为什么需要`used[i-1]`\n\n```\nnums = [1, 1, 2]\n\n如果没有used[i-1]， if(i > 0 && nums[i] == nums[i-1]) \n该条件会把所有情况过滤掉\n\n第一次选1， 剩余[1, 2]\nused[0] = true\n下一层, \n\ti = 0: 由于used[0] = true，continue\n\ti = 1: i > 0 && nums[i] == nums[i-1], 本该选择1，但会直接过滤掉\n\n```\n\n为什么used[i-1]==0表示树层去重\n\n```\nfor循环表示横向遍历\ni=1时，i=0的分支已经遍历完了，used[i]就会回溯为0，\nnums[i] == nums[i - 1]表示前一个分支和当前分支相同\n```\n\n","timestamp":1694699764227},{"name":"03-n 51. N 皇后.md","path":"002-数据结构与算法/008-回溯法/03-n 51. N 皇后.md","content":"#### [51. N 皇后](https://leetcode.cn/problems/n-queens/)\n\n#### 错解\n\n不能通过`(i < n-1 && used[i+1]) || (i > 0 && used[i-1])`判断是否在同一斜线，隔行后不适用\n\n```java\nclass Solution {\n    List<List<String>> res = new ArrayList<>();\n    List<String> path = new ArrayList();\n    // List<Integer> location = new ArrayList();\n\n    public List<List<String>> solveNQueens(int n) {\n        trackback(n, new boolean[n]);\n        return res;\n\n    }\n\n    public void trackback(int n, boolean[] used) {\n        if(path.size() == n) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i=0; i<n; i++) {\n            if(used[i]) {  // 同一列\n                continue;\n            }\n            if((i < n-1 && used[i+1]) || (i > 0 && used[i-1])) {  // 同一斜线\n                continue;\n\n            }\n\n            used[i] = true;\n            path.add(buildStr(i));\n\n            trackback(n, used);\n\n            used[i] = false;\n            path.remove(path.size() - 1);\n\n        }\n    }\n\n    public String buildStr(int i) {\n        StringBuilder sb = new StringBuilder(\"....\");\n        sb.setCharAt(i, \'Q\');\n        return sb.toString();\n    }\n}\n```\n\n![image-20221023104747966](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/23/1047481666493268166649326815890zpR9-image-20221023104747966.png)\n\n```java\nclass Solution {\n    List<List<String>> res = new ArrayList<>();\n\n    public List<List<String>> solveNQueens(int n) {\n        char[][] chessboard = new char[n][n];\n        for (char[] c : chessboard) {\n            Arrays.fill(c, \'.\');\t\t// x\n        }\n\n        trackback(n, 0, chessboard);\n        return res;\n\n    }\n\n    public void trackback(int n, int row, char[][] chessboard) {\t// x\n        if(row == n) {\n            res.add(Array2List(chessboard));\n            return;\n        }\n\n        for(int col=0; col<n; col++) {\n            if(!isValid(row, col, n, chessboard)) {\n                continue;\n            }\n\n            chessboard[row][col] = \'Q\';\n            trackback(n, row + 1,  chessboard);\n            chessboard[row][col] = \'.\';\n        }\n    }\n\n    public List Array2List(char[][] chessboard) {\n        List<String> list = new ArrayList<>();\n\n        for (char[] c : chessboard) {\n            list.add(String.copyValueOf(c));\t\t// x\n        }\n        return list;\n    }\n\n    public boolean isValid(int row, int col, int n, char[][] chessboard) {\n        // 同列\n        for(int i=0; i<row; i++) {\n            if(chessboard[i][col] == \'Q\') {\n                return false;\n            }\n        }\n\n        // 45度斜线\n        for(int i=row-1, j=col+1; i>=0 && j<n; i--, j++) {\n            if(chessboard[i][j] == \'Q\') {\n                return false;\n            }\n        }\n\n        // 135度斜线\n        for(int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {\n            if(chessboard[i][j] == \'Q\') {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"04- 52. N皇后 II.md","path":"002-数据结构与算法/008-回溯法/04- 52. N皇后 II.md","content":"### [52. N皇后 II](https://leetcode.cn/problems/n-queens-ii/)\n\n解题过程同n皇后1\n\n```\nclass Solution {\n\n    int res = 0;\n\n    public int totalNQueens(int n) {\n        int[][] chessboard = new int[n][n];\n        trackback(chessboard, n, 0);\n        return res;\n    }\n\n    public void trackback(int[][] chessboard, int n, int row) {\n        if(row == n) {\n            res++;\n            return;\n        }\n\n        for(int col = 0; col < n; col++) {\n            if(!isValid(chessboard, n, row, col)) {\n                continue;\n            }\n\n            chessboard[row][col] = 1;\n            trackback(chessboard, n, row + 1);\n            chessboard[row][col] = 0;\n        }\n    }\n\n    public boolean isValid(int[][] chessboard, int n, int row, int col) {\n        // 同列\n        for(int i = 0; i < row; i++) {\n            if(chessboard[i][col] == 1) return false;\n        }\n\n        // 45度\n        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n            if(chessboard[i][j] == 1) return false;\n        }\n\n        // 135度\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if(chessboard[i][j] == 1) return false;\n        }\n\n        return true;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-总结.md","path":"002-数据结构与算法/008-回溯法/100-总结.md","content":"#### 回溯算法模板框架\n\n```java\nvoid backtracking(参数) {\n    if (终止条件) {\n        存放结果;\n        return;\n    }\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n        处理节点;\n        backtracking(路径，选择列表); // 递归\n        回溯，撤销处理结果\n    }\n}i\n```\n\n要理解下图，对应回溯法框架\n\nfor循环是横向遍历，递归是纵向遍历\n\n![image-20221021104517409](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/21/10454516663203451666320345588zvSNh6-104517166632031716663203175055IL4q3-image-20221021104517409.png)\n\n\n\n\n\n#### [总结](https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/)\n\n怎么样写回溯算法(从上而下，※代表难点，根据题目而变化)\n\n-   ①画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※\n-   ②根据题意，确立结束条件\n-   ③找准选择列表(与函数参数相关),与第一步紧密关联※\n-   ④判断是否需要剪枝\n-   ⑤作出选择，递归调用，进入下一层\n-   ⑥撤销选择\n\n\n\n#### 什么时候需要start来控制起始位置？\n\n-   组合问题\n\n如果是一个集合来求组合的话，就需要startIndex，例如：[回溯算法：求组合问题！ (opens new window)](https://programmercarl.com/0077.组合.html)，[回溯算法：求组合总和！](https://programmercarl.com/0216.组合总和III.html)\n\n如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：[回溯算法：电话号码的字母组合](https://programmercarl.com/0017.电话号码的字母组合.html)\n\n-   排列问题","timestamp":1694699764227},{"name":"101-子集.md","path":"002-数据结构与算法/008-回溯法/101-子集.md","content":"\n\n### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)\n\n![image-20221021101144121](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/21/10114416663183041666318304237D8ptwh-image-20221021101144121.png)\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    Integer pathSum = 0;\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        trackback(candidates, target, 0);\n        return res;\n    }\n\n    public void trackback(int[] nums, int target, int start) {\n        // 结束条件\n        if(pathSum == target) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        // // 剪枝1: 超出后结束\n        // if(pathSum > target) {\n        //     return;\n        // }\n\n        for(int i = start; i < nums.length; i++) {\n            if(pathSum > target) { //剪枝\n                continue;\n            }\n            path.add(nums[i]);\n            pathSum += nums[i];\n\n            trackback(nums, target, i);\n\n            path.remove(path.size() - 1);\n            pathSum -= nums[i];\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"102-131.分割回文串.md","path":"002-数据结构与算法/008-回溯法/102-131.分割回文串.md","content":"### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)\n\n![image-20221021192512426](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/21/19251216663515121666351512542yauzQN-image-20221021192512426.png)\n\n```java\nclass Solution {\n    List<List<String>> res = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n\n    public List<List<String>> partition(String s) {\n        trackback(s, 0);\n        return res;\n    }\n\n    public void trackback(String s, int start) {\n        if(start == s.length()) {\n            res.add(new ArrayList<>(path));\n        }\n\n        for(int i = start; i < s.length(); i++) { // 横向遍历：从start开始，每次截取1，2，...长度的字符串\n            String str = s.substring(start, i + 1);\n            if(!isPalindrome(str)) {  // 不是回文串，结束该分支遍历\n                continue;\n            }\n            path.add(str);\n\n            trackback(s, i + 1);\n\n            path.remove(path.size() - 1);\n        }\n    }\n\n    // 判断是否是回文串\n    public boolean isPalindrome(String s) {\n        if(s.equals(\"\")) return false;\n\n        StringBuffer sb = new StringBuffer();\n        for(int i=0; i<s.length(); i++) {\n            char ch = s.charAt(i);\n            if(Character.isLetterOrDigit(ch)) {\n                sb.append(ch);\n            }\n        }\n        String newS = sb.toString().toLowerCase();\n        String reverse = sb.reverse().toString().toLowerCase();;\n        return reverse.equals(newS);\n    }\n}\n```\n\n写法2\n\n```java\nclass Solution {\n    List<List<String>> res = new ArrayList<>();\n    LinkedList<String> path = new LinkedList<>();\t\t// 区别\n\n    public List<List<String>> partition(String s) {\n        backtrack(s, 0);\n        return res;\t\n    }\n\n    public void backtrack(String s, int startIndex) {\n        if(startIndex == s.length()) {\n            res.add(new ArrayList(path));\n            return; \t\t// 区别\n        }\n\n        for(int i = startIndex; i < s.length(); i++) {\n            String str = s.substring(startIndex, i + 1);\n            if(!check(str)) continue;\n            path.add(str);\n            backtrack(s, i + 1);\n            path.removeLast();\n        }\n    }\n\n    public boolean check(String s) {\t\t// 区别\n        int l = 0, r = s.length() - 1;\n        while(l < r) {\n            if(s.charAt(l) != s.charAt(r)) return false;\n            l++;\n            r--;\n        } \n\n        return true;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"103-93. 复原 IP 地址.md","path":"002-数据结构与算法/008-回溯法/103-93. 复原 IP 地址.md","content":"### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)\n\n![image-20221021205122525](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/21/20512216663566821666356682631GtLKZR-image-20221021205122525.png)\n\n```java\nclass Solution {\n    List<String> res = new ArrayList<>();\n    StringBuilder sb = new StringBuilder();\n\n    public List<String> restoreIpAddresses(String s) {\n        trackback(s, 0, 0);\n        return res;\n    }\n\n    // number: ip段的数量； start：切割的起始位置\n    public void trackback(String s, int start, int number) {    \n        if(start == s.length() && number == 4) {\n            res.add(sb.toString());\n            return;\n        }\n        if(start == s.length() || number == 4) {\n            return;\n        }\n\n        for(int i = start; i < s.length(); i++) {\n            String str = s.substring(start, i + 1);\n            // 剪枝1: 子串长度 > 1, 不能以0开头\n            // if(str.length() > 1 && s.charAt(start) - \'0\' == 0) { // 写法二\n            if(str.length() > 1 && str.charAt(0) - \'0\' == 0) {\n                continue;\n            }\n\n            // 剪枝2\n            if(str.length() > 3 || Integer.parseInt(str) > 255) {\n                continue;\n            }\n\n            sb.append(str);\n            if(number < 3) {\n                sb.append(\".\");\n            }\n            number++;\n\n            trackback(s, i + 1, number);\n\n            number--;\n            sb.delete(start + number, i + 1 + number + 1);   // // 删除最后一个网段（即str），要考虑.的数量\n            // number--;  // 放这，上一句不+1为啥不行？起始位置也有number啊，傻狗\n        }\n    }\n}\n```\n\n直接用`LinkedList<String> path`，效果不如上面好\n\n```java\nclass Solution {\n    List<String> res = new ArrayList<>();\n    LinkedList<String> path = new LinkedList<>();\n    int n = 0;\t\t// 也可以放到backtrack参数\n\n    public List<String> restoreIpAddresses(String s) {\n        backtrack(s, 0);\n        return res;\n    }\n\n    public void backtrack(String s, int startIndex) {\n        if(n == 4 && startIndex == s.length()) {\n            String tmp = \"\";\n            for(int i = 0; i < path.size(); i++) {\n                tmp += path.get(i);\n            }\n            tmp = tmp.substring(0, tmp.length() - 1);\n            res.add(tmp);\n            return;\n        }\n        if(path.size() > 4 || n >= 4) return;\n\n        for(int i = startIndex; i < s.length(); i++) {\n            String str = s.substring(startIndex, i + 1);\n            if(str.length() > 1 && str.charAt(0) == \'0\') {\n                continue;\n            }\n\n            if(str.length() > 3 || Integer.parseInt(str) > 255) {\n                continue;\n            }\n\n\n            path.add(str + \".\");\n            n++;\n            backtrack(s, i + 1);\n            n--;\n            path.removeLast();\n        }\n    }  \n    \n}\n```\n\n","timestamp":1694699764227},{"name":"104-78. 子集.md","path":"002-数据结构与算法/008-回溯法/104-78. 子集.md","content":"\n\n[参考](https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/)\n\n### [78. 子集](https://leetcode.cn/problems/subsets/)\n\n![image-20221021094146037](/Users/kuan/Library/Application%2520Support/typora-user-images/image-20221021094146037.png)\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> subsets(int[] nums) {\n        trackback(nums, 0);\n        return res;\n    }\n\n    public void trackback(int[] nums, int startIndex) {\n \n\n        res.add(new ArrayList<>(path));\n        for(int i = startIndex; i < nums.length; i++) {\n            path.add(nums[i]);\n            trackback(nums, i + 1);\t\t// 搞清楚是start + 1还是i + 1\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"105-90.子集2.md","path":"002-数据结构与算法/008-回溯法/105-90.子集2.md","content":"### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)\n\n![image-20221021095907507](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/22/1043301666406610166640661087311GE5V-095907166631754716663175475984VADef-image-20221021095907507.png)\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        trackback(nums, 0);\n    \n        return res;\n    }\n\n    public void trackback(int[] nums, int start) {\n        res.add(new ArrayList<>(path));\n\n        for(int i = start; i < nums.length; i++) {\n            // 剪枝：去除重复元素\n            if(i > start && nums[i] == nums[i-1]) {\n                continue;\n            }\n\n            path.add(nums[i]);\n            trackback(nums, i + 1);     \n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"106-491. 递增子序列.md","path":"002-数据结构与算法/008-回溯法/106-491. 递增子序列.md","content":"### [491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/)]\n\n易错题：在[90.子集II](https://programmercarl.com/0090.子集II.html)中我们是通过排序，再加一个标记数组来达到去重的目的，在这不能排序\n\n![image-20221022145829308](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/22/14582916664219091666421909442ZdDIrb-image-20221022145829308.png)\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        // Arrays.sort(nums);  // 坑1: 不能排序，排序后就打乱顺序了，求的是原数组的各元素相对顺序\n        trackback(nums, 0);\n        \n        return res;\n    }\n\n    public void trackback(int[] nums, int start) {\n        if(path.size() >= 2) {\n            res.add(new ArrayList<>(path));\n            // return;  // 坑2: 要取树上的所有节点，不需要return\n        }\n\n        int[] used = new int[201];  // 不需要写到trackback参数中，只负责本层元素去重，也可以用map\n        for(int i = start; i < nums.length; i++) {\n          \t// if(i > startIndex && nums[i] == nums[i - 1]) continue; // 坑2，nums并非有序，同层不能使用重复元素，该用used去重\n            if((!path.isEmpty() && nums[i] < path.get(path.size() - 1)) || used[nums[i] + 100] == 1) {  // 去重 && 保证递增\n                continue;\n            }\n            used[nums[i] + 100] = 1;\n            path.add(nums[i]);\n\n            trackback(nums, i + 1);\n\n            path.remove(path.size() - 1);\n            // used[nums[i] + 100] = 0;     // 坑3: 新层used都会重新定义（清空），used只负责本层\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"107-332. 重新安排行程.md","path":"002-数据结构与算法/008-回溯法/107-332. 重新安排行程.md","content":"### [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)\n\n```java\nclass Solution {\n    LinkedList<String> res;\n    LinkedList<String> path = new LinkedList<>();\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        Collections.sort(tickets, (a, b) -> a.get(1).compareTo(b.get(1)));  // 排序，找字典序最小的\n        path.add(\"JFK\");\n        boolean[] used = new boolean[tickets.size()];\n        trackback((ArrayList)tickets, used);\n\n        return res;\n    }\n\n    // 返回值boolean： 只需要找一条路径，已经拍过序，最先找到的就是答案\n    public boolean trackback(ArrayList<List<String>> tickets, boolean[] used) {\n        if(path.size() == tickets.size() + 1) { // n个航班, 飞n+1个机场\n            res = new LinkedList(path);\n            return true;\n        }\n\n        for(int i = 0; i < tickets.size(); i++) {\n            List<String> ticket = tickets.get(i);\n            if(used[i] || !ticket.get(0).equals(path.getLast())) { // 已经使用过 or 起点不等于上一航班的终点\n                continue;\n            }\n\n            path.add(ticket.get(1));\n            used[i] = true;\n\n            if(trackback(tickets, used)) {  // 找到直接返回\n                return true;\n            }\n\n            used[i] = false;\n            path.removeLast();\n        }\n\n        return false;\n    }\n}\n```\n\n不能不使用用used，直接判断path中是否出现过，以下为错解，有可能出现来回飞的情况\n\n![image-20221022193805127](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/22/19380516664386851666438685289DIkvas-image-20221022193805127.png)\n\n错解\n\n```java\nclass Solution {\n    LinkedList<String> res;\n    LinkedList<String> path = new LinkedList<>();\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        Collections.sort(tickets, (a, b) -> a.get(1).compareTo(b.get(1))); \n        path.add(\"JFK\");\n        // boolean[] used = new boolean[tickets.size()];\n        trackback((ArrayList)tickets);\n\n        return res;\n    }\n\n    // 返回值boolean： 只需要找一条路径\n    public boolean trackback(ArrayList<List<String>> tickets) {\n        if(path.size() == tickets.size() + 1) { // n个航班, 飞n+1个机场\n            res = new LinkedList(path);\n            return true;\n        }\n\n        for(int i = 0; i < tickets.size(); i++) {\n            List<String> ticket = tickets.get(i);\n            if(path.contains(ticket.get(1)) || !ticket.get(0).equals(path.getLast())) { // 已经使用过 or 起点不等于上一航班的终点\n                continue;\n            }\n\n            path.add(ticket.get(1));\n            // used[i] = true;\n\n            if(trackback(tickets)) {  // 找到直接返回\n                return true;\n            }\n\n            // used[i] = false;\n            path.removeLast();\n        }\n\n        return false;\n    }\n}\n```\n\n错误\n\n```java\nclass Solution {\n    Map<String, List<String>> map = new HashMap<>();\n    List<String> res = null;\n    List<String> path = new ArrayList<>();\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        \n        for(List<String> ticket : tickets) {\n            String key = String.valueOf(ticket.get(0));\n            boolean flag = map.containsKey(key);\n            List<String> value = new ArrayList<>();;\n            if(flag) {\n                value = map.get(key);\n            }\n            value.add(String.valueOf(ticket.get(1)));\n            map.put(key, value);\n        }\n\n        List<String> keyList = new ArrayList<>();\n        for(String key : map.keySet()) {\n            keyList.add(key);\n        }\n\n        trackback(keyList, 0);\n        return res;\n    }\n\n    public void trackback(List<String> list, int start) {\n        if(list == null) return;\n        if(path.size() == map.size()) {\n            // 比较字典序\n            if(res == null) {\n                res = new ArrayList<>(path);\n                return;\n            }\n\n\n            return;\n        }\n\n        for(int i = start; i < list.size(); i++) {\n            if(path.contains(list.get(i))) {\n                continue;\n            }\n\n            path.add(list.get(i));\n\n            trackback(map.get(i), i + 1);\n\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"108-37. 解数独.md","path":"002-数据结构与算法/008-回溯法/108-37. 解数独.md","content":"### [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)\n\n```java\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        trackback(board);\n    }\n\n    public boolean trackback(char[][] board) {\n        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，\n        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」\n        for(int i=0; i<9; i++) {    // 遍历行\n            for(int j=0; j<9; j++) {    // 遍历列\n                if(board[i][j] != \'.\') {    // 跳过默认数字\n                    continue;\n                }\n\n                for(char k=\'1\'; k<=\'9\'; k++) {  // (i, j) 这个位置放k是否合适\n                    if(isValid(i, j, board, k)) {    // 符合数独规则\n                        board[i][j] = k;\n                        if(trackback(board)) {  // 如果找到合适一组立刻返回\n                            return true;\n                        }\n                        board[i][j] = \'.\';\n                    }\n                }\n                // 9个数都试完了，都不行，那么就返回false\n                return false;\n                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！\n                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」\n            }\n        }\n        // 遍历完没有返回false，说明找到了合适棋盘位置了\n        return true;\n    }\n\n    /**\n     * 判断棋盘是否合法有如下三个维度:\n     *     同行是否重复\n     *     同列是否重复\n     *     9宫格里是否重复\n     */\n    public boolean isValid(int row, int col, char[][] board, char val) {\n        // 同行重复\n        for(int i=0; i<9; i++) {\n            if(board[row][i] == val) {\n                return false;\n            }\n        }\n\n        // 同列重复\n        for(int i=0; i<9; i++) {\n            if(board[i][col] == val) {\n                return false;\n            }\n        }\n\n        // 九宫格重复\n        int startRow = (row / 3) * 3;   // 除3找到第几块，乘3找到起始下标\n        int startCol = (col / 3) * 3;\n        for(int i = startRow; i < startRow + 3; i++) {\n            for(int j = startCol; j < startCol + 3; j++) {\n                if(board[i][j] == val) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-455. 分发饼干.md","path":"002-数据结构与算法/009-贪心法/100-455. 分发饼干.md","content":"### [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)\n\n#### 方法一：\n\n优先考虑饼干，小饼干喂小胃口\n\n```java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int res = 0;\n        int i = 0;  // g的下标\n\n        // 优先考虑饼干，小饼干喂小胃口\n        for(int j = 0; j < s.length && i < g.length; j++) {\n            if(s[j] - g[i] >= 0) {\n                i++;\n                res++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法二\n\n胃口优先，先喂饱大的\n\n```java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int res = 0;\n        int j = s.length - 1;  // s的下标\n\n        // 胃口优先，先喂饱大的\n        for(int i = g.length - 1; i >= 0 && j >= 0; i--) {\n            if(g[i] <= s[j]) {\n                j--;\n                res++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"101-376. 摆动序列.md","path":"002-数据结构与算法/009-贪心法/101-376. 摆动序列.md","content":"### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)\n\n#### 方法一：贪心\n\n如果出现连续递增，则取最大的；如果出现连续递减，则取最小的\n\n```java\nclass Solution {\n    public int wiggleMaxLength(int[] nums) {\n        int cnt = 1;\n        int preDiff = 0;    // 前一组数的差\n        for(int i = 1; i < nums.length; i++) {\n            int curDiff = nums[i] - nums[i - 1];    // 当前组数的差\n            if(preDiff == 0 && curDiff != 0) {  // 初始值，可降可升\n                cnt++;\n                preDiff = curDiff;\n            } else if(preDiff > 0 && curDiff < 0) {  // 前面升，则现在降\n                cnt++;\n                preDiff = curDiff;\n            } else if(preDiff < 0 && curDiff > 0) {  // 前面降，则现在升\n                cnt++;\n                preDiff = curDiff;\n            }\n        }\n\n        return cnt;\n    }\n}\n```\n\n优化写法\n\n```java\nclass Solution {\n    public int wiggleMaxLength(int[] nums) {\n      \tint count = 1;\n        \n        int preDiff = 0;\t//上一个差值\n        for (int i = 1; i < nums.length; i++) {\n            int curDiff = nums[i] - nums[i - 1];\t// 当前差值\n            //如果当前差值和上一个差值为一正一负\n            //等于0的情况表示初始时的preDiff\n            if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {\n                count++;\n                preDiff = curDiff;\n            }\n        }\n        return count;\n    }\n}\n```\n\n\n\n#### 方法二：dp TODO","timestamp":1694699764227},{"name":"102-53. 最大子数组和.md","path":"002-数据结构与算法/009-贪心法/102-53. 最大子数组和.md","content":"### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)\n\n#### 方法一：贪心\n\n**局部最优：**当前连续和  < 0，立即放弃，从下一个元素重新开始。因为负数加上下一个元素 “连续和”只会越来越小。\n\n**全局最优：**选取最大“连续和”\n\n\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int max = Integer.MIN_VALUE;\n\n        int cnt = 0;\t// 当前计数区间和\n        for(int i = 0; i < nums.length; i++) {\n            cnt += nums[i];\t\t// 更新连续和\n            if(cnt > max) {\t\t// 取区间累计的最大值，不断确定最大子序终止位置\n                max = cnt;\n            }\n            if(cnt < 0) {\t\t// 当前连续和 < 0，放弃，重制起始位置\n                cnt = 0;\n            }\n        }\n\n        return max;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"103-122. 买卖股票的最佳时机 II.md","path":"002-数据结构与算法/009-贪心法/103-122. 买卖股票的最佳时机 II.md","content":"### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)\n\n原先的想法：与摆动序列联系，从左到右遍历，找到最低谷买，最高峰卖，行不太通。\n\n\n\n#### 方法一：贪心\n\n分解利润：第1天买，第三天卖，利润 =（ 第一天买，第二天卖） + （第二天买，第三天卖）\n\n![image-20221025112815212](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/25/11281516666684951666668495367MyVRrM-image-20221025112815212.png)\n\n**局部最优：收集每天的正利润，全局最优：求得最大利润**。\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int res = 0;\n\n        // int[] profit = new int[prices.length - 1];   // 不需要实际用数组记录\n        for(int i = 1; i < prices.length; i++) {\n            int diff = prices[i] - prices[i - 1]\n            if(diff > 0) {\n                res += diff;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n#### 方法二：动态规划 TODO","timestamp":1694699764227},{"name":"104-55. 跳跃游戏.md","path":"002-数据结构与算法/009-贪心法/104-55. 跳跃游戏.md","content":"### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)\n\n贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），\n\n整体最优解：最后得到整体最大覆盖范围，看是否能到终点。\n\n![image-20221025141643612](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/25/14164316666786031666678603758NbkboP-image-20221025141643612.png)\n\n```java\nclass Solution {\n    public boolean canJump(int[] nums) {\n        if(nums.length == 0) return true;\n        int cover = nums[0];\n\n        for(int i = 0; i <= cover; i++) {\n            cover = Math.max(cover, i + nums[i]);\n            if(cover >= nums.length - 1) {\n                return true;\n            }\n        }\n\n        return cover >= nums.length - 1;\n\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"105-45. 跳跃游戏 II.md","path":"002-数据结构与算法/009-贪心法/105-45. 跳跃游戏 II.md","content":"### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)\n\n![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/16/16005916869024591686902459028s49qV0-1.jpg)\n\n```java\nclass Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        int end = 0;        // 当前能走的最远距离\n        int farthest = 0;   // 下一步能跳到的最远距离\n        int jumps = 0;      // 跳跃次数\n        for(int i = 0; i < n - 1; i++) {\n            farthest = Math.max(farthest, nums[i] + i);\n            if(i == end) {\n                jumps++;\n                end = farthest;\n            }\n        }\n\n        return jumps;\n    }\n}\n```\n\n[参考](https://labuladong.github.io/algo/di-er-zhan-a01c6/tan-xin-le-9bedf/ru-he-yun--48a7c/)\n\n\n\n\n\n![image-20221025152635006](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/25/15263516666827951666682795123vYFHA4-image-20221025152635006.png)\n\n好理解\n\n```java\nclass Solution {\n    public int jump(int[] nums) {\n        int res = 0;\n\n        int curDistance = 0;    // 下一步可覆盖位置\n        int nextDistance = 0;   // 当前覆盖位置\n        for(int i = 0; i < nums.length; i++) {\n            nextDistance = Math.max(nextDistance, i + nums[i]);  // 记录下一次可以跳到的最远范围\n            if(i == curDistance) {  // 走到当前覆盖位置最远处\n                if(i == nums.length - 1) {  // 走到终点\n                    return res;\n                }\n                curDistance = nextDistance;\n                res++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n写法二\n\n```java\nclass Solution {\n    public int jump(int[] nums) {\n        int res = 0;\n\n        int curDistance = 0;    // 下一步可覆盖位置\n        int nextDistance = 0;   // 当前覆盖位置\n        for(int i = 0; i < nums.length - 1; i++) {\t// 区别1: 注意这里是-1 ???\n            nextDistance = Math.max(nextDistance, i + nums[i]);  // 记录下一次可以跳到的最远范围\n            if(i == curDistance) {  // 走到当前覆盖位置最远处\n                // if(i == nums.length - 1) {  //  区别2\n                //     return res;\n                // }\n                curDistance = nextDistance;\n                res++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"106-1005. K 次取反后最大化的数组和.md","path":"002-数据结构与算法/009-贪心法/106-1005. K 次取反后最大化的数组和.md","content":"### [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)\n\n\n\n```java\nclass Solution {\n    public int largestSumAfterKNegations(int[] nums, int k) {\n        int res = 0;\n\n        // 排序，将绝对值最大的反转\n        Arrays.sort(nums);\n        for(int i = 0; i < nums.length && k > 0; i++) {\n            if(nums[i] <= 0) {\n                nums[i] = 0 - nums[i];\n                k--;\n            }\n        }\n\n        // k反转两次会抵消，还有剩余将最小的反转\n        k = k % 2;\n        if(k != 0) {\n            Arrays.sort(nums);\n            nums[0] = 0 - nums[0];\n        }\n        \n        // 求和\n        for(int i = 0; i < nums.length; i++) {\n            res += nums[i];\n        }\n\n        return res;\n    }\n} \n```\n\n优化：只用排序一次\n\n-   一开始按照绝对值最大的排倒序\n-   遇到负数 变 正数\n-   k还剩余，则将最后的数反转（两次反转会抵消，所以只需要将最后一个元素反转）\n-   求和","timestamp":1694699764227},{"name":"107-134. 加油站.md","path":"002-数据结构与算法/009-贪心法/107-134. 加油站.md","content":"### [134. 加油站](https://leetcode.cn/problems/gas-station/)\n\n#### 错解\n\n-   判断能不回走一圈，即gas总和 > cost总和\n\n-   找到第一个gas > cost的地方\n\n    ```\n    [5,1,2,3,4]\n    [4,4,1,5,1]\n    输出：0； 预期：4\n    ```\n\n```java\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int res = 0;\n\n        // 判断能不回走一圈，即gas总和 > cost总和\n        for(int g : gas) {\n            res += g;\n        }\n        for(int c : cost) {\n            res -= c;\n        }\n\n        if(res < 0) {\n            return -1;\n        }\n\n        // 找到第一个gas > cost的地方\n        for(int i = 0; i < gas.length; i++) {\n            if(gas[i] > cost[i]) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n}\n```\n\n#### 方法一\n\n不太理解，为什么从后往前找使min>=0的就是解\n\n```java\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int cnt = 0;\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < gas.length; i++) {\n            int rest = gas[i] - cost[i];\n            cnt += rest;\n            if(cnt < min) {\n                min = cnt;\n            }\n        }\n        if(cnt < 0) return -1;\n        if(min >= 0) return 0;\n\n        for(int i = gas.length - 1; i >= 0; i--) {\n            int res = gas[i] - cost[i];\n            min += res;\n            if(min >= 0) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n}\n```\n\n#### 方法二\n\n-   剩余油量总和 < 0，不管从任何地方开始都无法走完\n-   从startIndex开始，尝试找出发点，记录剩余的油量，如果碰到油量为负数，说明从startIndex无法走完\n    -   startIndex = i + 1。 问：[如何理解startIndex ～ i之间的点也不符合？](https://programmercarl.com/0134.加油站.html#贪心算法-方法一)\n        -   答：反证法，如果区间内存在，则startIndex早就已经更新了\n\n```java\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int restSum = 0;    // 剩余油量总和\n        int curRestSum = 0;\n        int startIndex = 0;\n      \t// 遍历一遍，要么有解，要么无解。有解时restSum一定大于0\n        for(int i = 0; i < gas.length; i++) {\n            int rest = gas[i] - cost[i];    // 剩余量\n            restSum += rest;\n            curRestSum += rest;\n            if(curRestSum < 0) {    // 从startIndex位置开始，出现供应不足\n                startIndex = i + 1; // 从下一个位置开始计算起始位置(? 为什么不能是startIndex 与 i之间的位置。 自己举例 )\n                curRestSum = 0;     // 置0\n            }\n        }\n\n        if(restSum < 0) {   // 补给 < 消耗，走不了一圈\n            return -1;\n        }\n\n        return startIndex;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"108-135. 分发糖果.md","path":"002-数据结构与算法/009-贪心法/108-135. 分发糖果.md","content":"### [135. 分发糖果](https://leetcode.cn/problems/candy/)\n\n[1,3,2,2,1]\n\n从左遍历，处理右边比左边大的情况\n\n从右边遍历，处理左边比右边大大情况\n\n```java\nclass Solution {\n    public int candy(int[] ratings) {\n        int candy[] = new int[ratings.length];\n        Arrays.fill(candy, 1);\n        \n        // 从前向后\n        for(int i = 1; i < ratings.length; i++) {\n            if(ratings[i] > ratings[i - 1] && candy[i] <= candy[i - 1]) {\n                candy[i] = candy[i - 1] + 1;\n            }\n        }\n\n        // 从后向前\n        for(int i = ratings.length - 2; i >= 0; i--) {\n            if(ratings[i] > ratings[i + 1] && candy[i] <= candy[i + 1]) {\n                candy[i] = candy[i + 1] + 1;\n            }\n        }\n        \n        int res = 0;\n        for(int c : candy) {\n            res += c;\n        }\n\n        return res;\n    }\n}\n```\n\n写法二\n\n```java\nclass Solution {\n    public int candy(int[] ratings) {\n        if(ratings.length == 1) return 1;\n        int[] res = new int[ratings.length];\n        Arrays.fill(res, 1);\n        for(int i = 1; i < ratings.length; i++) {\n            if(ratings[i] > ratings[i - 1]) {\n                res[i] = res[i - 1] + 1;\n            }\n        }\n        // System.out.println(Arrays.toString(res));\n        for(int i = ratings.length - 2; i >= 0; i--) {\n            if(ratings[i] > ratings[i + 1]) {\n                res[i] = Math.max(res[i + 1] + 1, res[i]);\n            }\n        }\n\n        int cnt = 0;\n        for(int i : res) {\n            cnt += i;\n        }\n\n        // System.out.println(Arrays.toString(res));\n        return cnt;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"109-860. 柠檬水找零.md","path":"002-数据结构与算法/009-贪心法/109-860. 柠檬水找零.md","content":"### [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)\n\n贪心策略：先用大钱补\n\n```java\nclass Solution {\n    public boolean lemonadeChange(int[] bills) {\n        int n5 = 0;\n        int n10 = 0;\n\n        for(int i = 0; i < bills.length; i++) {\n            // 5元：直接收\n            if(bills[i] == 5) {\n                n5++;\n                continue;\n            }\n          \n            // 10元：补一个5元\n            if(bills[i] == 10) {\n                if(n5 == 0) {\n                    return false;\n                }\n                n10++;\n                n5--;\n            }\n          \n            // 20元：补15元，先用10块，再用5块\n            if(bills[i] == 20) {\n                bills[i] -= 5;\n                while(n10 != 0 && bills[i] - 10 > 0) {\n                    n10--;\n                    bills[i] -= 10;\n                }\n                while(bills[i] != 0 && n5 > 0) {\n                    bills[i] -= 5;\n                    n5--;\n                }\n                if(bills[i] > 0) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n```\n\n**优化写法**\n\n都假设能找补，最后判断是否透支\n\n```java\nclass Solution {\n    public boolean lemonadeChange(int[] bills) {\n        int n5 = 0;\n        int n10 = 0;\n\n        for(int i = 0; i < bills.length; i++) {\n            if(bills[i] == 5) {\n                n5++;\n            } else if(bills[i] == 10) {\n                n10++;\n                n5--;\n            } else if(bills[i] == 20) {\n                if(n10 > 0) {\n                    n10--;\n                    n5--;\n                } else {\n                    n5 -= 3;\n                }\n            }\n            if(n5 < 0 || n10 < 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"110-406. 根据身高重建队列.md","path":"002-数据结构与算法/009-贪心法/110-406. 根据身高重建队列.md","content":"### [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)\n\n两个维度考虑，参考分发糖果，先从一个维度考虑完后再考虑另一个维度\n\n按身高从大到小排列，前面的都是高于后面的，再根据第二个维度，进行调整插入\n\n![image-20221027151605034](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/27/151605166685496516668549651744uKetd-image-20221027151605034.png)\n\n```java\nclass Solution {\n    public int[][] reconstructQueue(int[][] people) {\n        // 按身高h降序\n        Arrays.sort(people, (a, b) -> {\n            if(a[0] == b[0]) return a[1] - b[1];\n            return b[0] - a[0];\n        });\n\n        // 按k调整插入(插入排序)\n        for(int i = 1; i < people.length; i++) {\n            int k = people[i][1];\n            int index = i;\n            while(k < index && index > 0) {\n                int[] tmp = people[index - 1];\n                people[index - 1] = people[index];\n                people[index] = tmp;\n                index--;\n            }\n        }\n\n        return people;\n    }\n}\n```\n\n优化：用链表\n\n```java\nclass Solution {\n    public int[][] reconstructQueue(int[][] people) {\n        // 按身高h降序\n        Arrays.sort(people, (a, b) -> {\n            if(a[0] == b[0]) return a[1] - b[1];\n            return b[0] - a[0];\n        });\n\n        // 按k调整插入\n        LinkedList<int[]> q = new LinkedList<>();\n        for(int[] p : people) {\n            q.add(p[1], p);\n        }\n\n        return q.toArray(new int[people.length][]);\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"111-452. 用最少数量的箭引爆气球.md","path":"002-数据结构与算法/009-贪心法/111-452. 用最少数量的箭引爆气球.md","content":"### [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)\n\n#### 错解\n\n升序排列，全部入队列，取出第一个气球，按最右边界来射，将队列中包含右边界的气球都取出，用同一箭射\n\n问题1：会越界\n\n**[[-2147483646,-2147483645],[2147483646,2147483647]]** 排序负数会在后面，可改用`Integer.compare(x[1], y[1]);`\n\n问题2: 策略就不可行\n\n```\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\n输出：1\n预期：2\n```\n\n![image-20221027173037339](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/27/173037166686303716668630374673yRb0x-image-20221027173037339.png)\n\n```java\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        // 按x升序，x相同按y升序\n        Arrays.sort(points, (x, y) -> {\n            if(x[0] == y[0]) return x[1] - y[1];\n            return x[0] - y[0];\n        });\n\n        Deque<int[]> q = new LinkedList<>();\n        for(int[] p : points) {\n            q.offer(p);\n        }\n\n        int res = 0;\n        while(!q.isEmpty()) {\n            int[] p = q.poll();\n            res++;\n            while(!q.isEmpty() && p[1] >= q.peek()[0]) {\n                q.poll();\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法1\n\n```java\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n      // Arrays.sort(points, (a, b)->{\t\t// 问题：大数溢出\n        //     // if(a[0] == b[0]) return a[1] - b[1];\t// 可省略\n        //     return a[0] - b[0];\n        // });\n        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));\n\n        int count = 1; // points不为空至少一支箭\n        for(int i = 1; i < points.length; i++) {\n            if(points[i][0] > points[i - 1][1]) {   // i和i-1不挨着\n                count++;    // 需要一支箭\n            } else {\n                points[i][1] = Math.min(points[i][1], points[i - 1][1]);  // 以最小的那个右边界射的气球\n            }\n        }\n\n        return count;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"112-435. 无重叠区间.md","path":"002-数据结构与算法/009-贪心法/112-435. 无重叠区间.md","content":"### [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)\n\n#### 方法一：左边界排序\n\n借鉴 452.用最少数量的箭引爆气球\n\n按左边界排序，然后遍历，如果当前的起始端在前一个区间内，则需要删除。\n\n只需要关注左边界，左边界在区间内则需要去除，右边界不管在不在都要删除\n\n```java\nclass Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n      \t// 升序\n        Arrays.sort(intervals, (a, b) -> {\n            if(a[0] == b[0]) return a[1] - b[1];\n            return a[0] - b[0];\n        });\n\n        int res = 0;\n        for(int i = 1; i < intervals.length; i++) {  // 默认第一个区间是不需要删除的\n            int[] pre = intervals[i - 1];\t\t// 前一个区间\n            int[] cur = intervals[i];\t\t\t\t// 当前区间\n            if(pre[0] <= cur[0] && cur[0] < pre[1]) {\t\t// 当前区间起始点在前一个区间内\n                res++;\t// 需要删除\n                cur[1] = Math.min(cur[1], pre[1]);\t// 将删除区间的末端更新为上一个区间末端，模拟删除区间\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法二：右边界排序\n\n右边界排序，所以第一个右边界一定是最小的，如果区间包含end则过滤，知道下一个区间在end之后。\n\n```java\nclass Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        Arrays.sort(intervals, (a, b)->Integer.compare(a[1], b[1]));\n\n        int cnt = 1;    // 非交叉区间个数\n        int end = intervals[0][1];\t// 右边界\n        for(int i = 1; i < intervals.length; i++) {\n            if(end <= intervals[i][0]) {\t// 找到下一个在end之后的区间，更新end\n                cnt++;\n                end = intervals[i][1];\n            }  \n        }\n\n        return intervals.length - cnt;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"113-763. 划分字母区间.md","path":"002-数据结构与算法/009-贪心法/113-763. 划分字母区间.md","content":"### [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)\n\n#### 错解\n\n思路：找到起始字符0的最远边界index，用map统计这区间内(0 ~ index)的所有字符（标记属于这个集合），超过最远边界后，继续向后遍历，如果map中有，那么就加入该集合，如果没有，那么结束，寻找下一个集合。\n\n这类`hijhklij`字符串中的`k`并不适用\n\n```java\nclass Solution {\n    List<Integer> res = new ArrayList<>();\n\n    public List<Integer> partitionLabels(String s) {\n        solve(s, 0, s.length() - 1);\n        return res;\n    }\n\n    public void solve(String s, int start, int end) {\n        if(s.length() == start) {\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n\n        Map<Character, Integer> map = new HashMap<>();\n\n        int index = s.length() - 1;     // 最右边与s[start]相同的字符\n        while(start < index && s.charAt(index) != s.charAt(start)) {\n            index--;\n        }\n        int i;\n        for(i = start; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if(i <= index) {\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\n            } \n            \n            if(map.containsKey(ch)) {\n                sb.append(ch);\n            } else {\n                break;\n            }\n            \n        }\n        res.add(sb.toString().length());\n        solve(s, i, end);\n    }\n}\n```\n\n#### 方法一：\n\n思路：\n\n先遍历一遍，记录各个字符的最远距离。\n\n再遍历一遍，初始区间只有第0个字符，其最远边界为end，片段至少为[0, end]，遍历过程中根据字符不断更新end，当i==end时，当前片段遍历结束。开始寻找下一个片段\n\n```java\nclass Solution {\n\n    public List<Integer> partitionLabels(String s) {\n        List<Integer> res = new ArrayList<>();\n        if(s.length() == 0) return res;\n\n        // 找每个字符的最远边界\n        Map<Character, Integer> map = new HashMap<>();\n        for(int i = 0; i < s.length(); i++) {\n            map.put(s.charAt(i), i);\n        }\n\n        int start = 0;  // 起始位置\n        int end = map.get(s.charAt(0));     // 集合的最远边界\n        for(int i = 0; i < s.length(); i++) {\n            end = Math.max(end, map.get(s.charAt(i)));\n            if(i == end) {\n                res.add(end - start + 1);\n                start = i + 1;\n                continue;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"114-56. 合并区间.md","path":"002-数据结构与算法/009-贪心法/114-56. 合并区间.md","content":"### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)\n\n思路：\n\n按左边界排序，从左到右遍历，\n\n-   遇到不重复的区间，直接把上一个区间加入结果集；\n-   有重复，更新更新最小左边界，最大右边界\n\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        List<int[]> list = new ArrayList<>();\n        if(intervals.length == 0) return new int[][]{};\t// 可省略\n\n        // 左边界排序\n        Arrays.sort(intervals, (a, b) -> {\n            return a[0] - b[0];\n        });\n\n        for(int i = 1; i < intervals.length; i++) {\n            int[] cur = intervals[i];\n            int[] pre = intervals[i - 1];\n            if(cur[0] <= pre[1]) {  // 有重叠\n                cur[0] = Math.min(cur[0], pre[0]);\n                cur[1] = Math.max(cur[1], pre[1]);\n            } else {    // 无重叠\n                list.add(pre);\n            }\n        }\n        list.add(intervals[intervals.length - 1]);\n\n        int[][] res = new int[list.size()][2];\n        for(int i = 0; i < list.size(); i++) {\n            res[i] = list.get(i);\n        }\n\n        return res;\n    }\n}\n```\n\n**优化**\n\nlist转数组\n\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        List<int[]> list = new ArrayList<>();\n        if(intervals.length == 0) return new int[][]{};\n\n        // 排序\n        Arrays.sort(intervals, (a, b) -> {\n            return a[0] - b[0];\n        });\n      \n       // 排序2:可以防止越界\n       // Arrays.sort(intervals, (a, b)->Integer.compare(a[0], b[0]));\n\n        for(int i = 1; i < intervals.length; i++) {\n            int[] cur = intervals[i];\n            int[] pre = intervals[i - 1];\n            if(cur[0] <= pre[1]) {  // 有重叠\n                cur[0] = Math.min(cur[0], pre[0]);\t\t\n                cur[1] = Math.max(cur[1], pre[1]);\n            } else {    // 无重叠\n                list.add(pre);\n            }\n        }\n        list.add(intervals[intervals.length - 1]);\n\n      \t// 优化2\n        return list.toArray(new int[list.size()][]);\n    }\n}\n```\n\n思路2:\n\n遇到新的无重复区间先加入结果集，然后继续往后遍历，如果有重叠区间，则去更新结果集最后一个数据的右边界\n\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b)->Integer.compare(a[0], b[0]));\n        List<int[]> list = new ArrayList<>();\n        list.add(intervals[0]);\n      \n        for(int i = 1; i < intervals.length; i++) {\n            int[] pre = list.get(list.size() - 1);\n            int[] cur = intervals[i];\n            if(cur[0] >= pre[0] && cur[0] <= pre[1]) {\n                list.get(list.size() - 1)[1] = Math.max(cur[1], pre[1]);\t// 重复区间则修改右边界\n            } else {\n                list.add(cur);\t // 新的无重复区间直接添加\n            }\n        }\n\n        return list.toArray(new int[list.size()][]);\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"115-738. 单调递增的数字.md","path":"002-数据结构与算法/009-贪心法/115-738. 单调递增的数字.md","content":"### [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)\n\n如若num[i - 1] > num[i]，则num[i - 1]--，num[i]变为9\n\n#### 错解\n\n存在不同位，同值的情况，会漏将后面的数改为9\n\n输入100，结果为90，预期为99\n\n```java\nclass Solution {\n    public int monotoneIncreasingDigits(int n) {\n        String s = String.valueOf(n);\n        char[] chars = s.toCharArray();\n\n        for(int i = chars.length - 1; i > 0; i--) {\n            if(chars[i] < chars[i - 1]) {\t\t// 改为<=后，101不行\n                flag = i;\n                chars[i] = \'9\';\n                chars[i-1]--;\n            }\n        }\n\n        return Integer.parseInt(String.valueOf(chars));\n    }\n}\n```\n\n#### 方法一\n\n```java\nclass Solution {\n    public int monotoneIncreasingDigits(int n) {\n        String s = String.valueOf(n);\n        char[] chars = s.toCharArray();\n\n        int flag = chars.length;    // 变成9的起始位置\n        for(int i = chars.length - 1; i > 0; i--) {\n            if(chars[i] < chars[i - 1]) {\n                flag = i;\n                chars[i-1]--;\n            }\n        }\n\n        for(int i = flag; i < chars.length; i++) {\n            chars[i] = \'9\';\n        }\n\n        return Integer.parseInt(String.valueOf(chars));\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"116-714. 买卖股票的最佳时机含手续费.md","path":"002-数据结构与算法/009-贪心法/116-714. 买卖股票的最佳时机含手续费.md","content":"### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices, int fee) {\n        int res = 0;\n        int low = prices[0];    // 最低值\n        for(int i = 1; i < prices.length; i++) {\n            // 更新最低值,想当于买入\n            low = Math.min(low, prices[i]);\n\n            // 此时卖会亏本\n            if (prices[i] >= low && prices[i] <= low + fee) {\n                continue;\n            }\n\n            // 顶峰预售，但不真正卖出，还可以最后更高价卖出\n            if(prices[i] - low > fee) {\n                res += (prices[i] - low - fee);\n                low = prices[i] - fee;   // 预售的时候已经出过fee了，之后如果再卖这股不需要再出fee\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"117-968. 监控二叉树.md","path":"002-数据结构与算法/009-贪心法/117-968. 监控二叉树.md","content":"### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)\n\n从下往上遍历，优先根节点的父节点安摄像头\n\n-   0：该节点无覆盖\n-   1：本节点有摄像头\n-   2：本节点有覆盖\n\n```java\nclass Solution {\n    int res = 0;\n\n    public int minCameraCover(TreeNode root) {\n        // 情况4: 遍历完后根节点没有覆盖\n        if(traversal(root) == 0) {\n            res++;\n        }\n        return res;\n    }\n\n    public int traversal(TreeNode root) {\n        // 空节点置为覆盖状态\n        if(root == null) return 2;\n\n        int left = traversal(root.left);\n        int right = traversal(root.right);\n\n        // 情况1:左右节点都有覆盖, 当前节点不用放摄像头\n        if(left == 2 && right == 2) {\n            return 0;\n        }\n\n        // 情况2: 左右节点有一个不覆盖\n        if(left == 0 || right == 0) {\n            res++;\n            return 1;\n        }\n\n        // 情况3: 左右有一个摄像头\n        if(left == 1 || right == 1) {\n            return 2;\n        }\n\n        return -1;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-121. 买卖股票的最佳时机.md","path":"002-数据结构与算法/010-动态规划/01-买卖股票问题/01-121. 买卖股票的最佳时机.md","content":"### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)\n\n只能交易一次\n\n```\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n注意：只能买一次，所以不能用[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)拆分利润的方法\n\n#### 方法一：贪心\n\n找低谷与顶峰\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n        int res = 0;\n\n        int min = prices[0];\n        for(int i = 1; i < prices.length; i++) {\n            min = Math.min(min, prices[i]);\n            int diff = prices[i] - min;\n            res = Math.max(res, diff);\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法二：动态规划\n\ndp含义\n\n```\ndp[i] 前i项利润最大值\n```\n\n递推公式\n\n```\ndp[i] = Math.max(prices[i] - min, dp[i - 1]);\n```\n\n源码\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n\n        int[] dp = new int[prices.length];\n        int min = prices[0];\n        dp[0] = 0;\n        for(int i = 1; i < prices.length; i++) {\n            dp[i] = Math.max(prices[i] - min, dp[i - 1]);\n            min = Math.min(min, prices[i]);\n        }\n\n        return dp[prices.length - 1];\n    }\n}\n```\n\n优化：滚动数组\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n\n        int res = 0;\n        int pre = 0;\n        int min = prices[0];\n        for(int i = 1; i < prices.length; i++) {\n            res = Math.max(prices[i] - min, pre);\n            min = Math.min(min, prices[i]);\n            pre = res;\n        }\n\n        return res;\n    }\n}\n```\n\n### 方法三：动态规划2\n\n方式1（为主）\n\n[参考](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/yi-ge-fang-3b01b/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        // dp[i][0]: 第i天不持有股票所得最多现金\n        // dp[i][1]: 第i天持有股票所得最多现金\n        int[][] dp = new int[n][2];  \n        dp[0][0] = 0;   \n        dp[0][1] = -prices[0];\n        for(int i = 1; i < n; i++) {\n            // 今天不持有： 1 昨天不持有 2 昨天持有，今天卖\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            // 今天持有： 1 昨天持有 2 昨天不持有，今天买\n            dp[i][1] = Math.max(dp[i - 1][1], - prices[i]);    // 解释1\n        }\n\n        return dp[n - 1][0];\n    }\n}\n```\n\n解释1:`为什么不是Math.max(dp[i - 1][1],  dp[i - 1][0] - prices[i]);`\n\n```\n因为只买卖一次，昨天不持有说明昨天及之前都没有发生过交易，持有的现金肯定是0\n而dp[i - 1][0]可能包含了两种情况，1 一直没持有； 2 持有过但卖了。\n而现在已经确定了今天要买，并且题目要求只能交易一次，所以只能取dp[i - 1][0]的第一种情况，也就是0\n```\n\n\n\n\n\n方式2\n\n<img src=\"/Users/kuan/Library/Application%20Support/typora-user-images/image-20221222123200226.png\" alt=\"image-20221222123200226\" style=\"zoom: 33%;\" />\n\n```\ndp[i][0] 就是用来记录最低谷的\ndp[i][1] 记录当前最大利润\n```\n\n\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n\n        int[][] dp = new int[prices.length][2];\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i = 1; i < prices.length; i++) {\n            dp[i][0] = Math.max(-prices[i], dp[i - 1][0]);\n            dp[i][1] = Math.max(prices[i] + dp[i-1][0], dp[i - 1][1]);\n        }\n\n        return dp[prices.length - 1][1];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-122. 买卖股票的最佳时机 II.md","path":"002-数据结构与算法/010-动态规划/01-买卖股票问题/02-122. 买卖股票的最佳时机 II.md","content":"### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)\n\n不限交易\n\n```\n给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n\n返回 你能获得的 最大 利润 。\n\n输入：prices = [7,1,5,3,6,4]\n输出：7\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n     总利润为 4 + 3 = 7 。\n```\n\n\n\n#### 方法一：贪心\n\n```\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int res = 0;\n        int[] dif = new int[prices.length];\n        for(int i = 1; i < prices.length; i++) {\n            dif[i] = prices[i] - prices[i - 1];\n            if(dif[i] > 0) res += dif[i];\n        }\n        return res;\n    }\n}\n```\n\n\n\n#### 方法二：dp\n\n##### 方式1（为主）\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        if(n == 0) return 0;\n\n        int[][] dp = new int[n][2];\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        for(int i = 1; i < n; i++) {\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); // 与121.对比\n        }\n        return dp[n - 1][0];\n    }\n}\n```\n\n优化: 滚动数组\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        if(n == 0) return 0;\n\n        int pre0 = 0;\n        int pre1 = -prices[0];\n        for(int i = 1; i < n; i++) {\n            pre0 = Math.max(pre0, pre1 + prices[i]);\n            pre1 = Math.max(pre1, pre0 - prices[i]);\n        }\n        return pre0;\n    }\n}\n```\n\n[参考](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/yi-ge-fang-3b01b/)\n\n##### 方式2\n\n与方式1的区别在于`dp[i][0]和dp[i`][1]相反\n\n[参考](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int[][] dp = new int[prices.length][2];\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i = 1; i < prices.length; i++) {\n            dp[i][0] = Math.max(dp[i-1][1] - prices[i], dp[i-1][0]);\n            dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]);\n        }\n\n        return dp[prices.length- 1][1];\n    }\n}\n```\n\n\n\n```\n7 1 2 5 3 6 4\n\n-7  0\n-1  0\n-1  1\n-4  4\n 1  4\n-2  7\n```\n\n","timestamp":1694699764227},{"name":"03-123. 买卖股票的最佳时机 III.md","path":"002-数据结构与算法/010-动态规划/01-买卖股票问题/03-123. 买卖股票的最佳时机 III.md","content":"### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)\n\n交易两次\n\n```\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n输入：prices = [3,3,5,0,0,3,1,4]\n输出：6\n解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n```\n\n\n\n#### 方法一：三维dp\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int k = 2;\n        if(n == 0) return 0;\n        int[][][]dp = new int[n][k + 1][2];\n        dp[0][1][0] = 0;\n        dp[0][1][1] = -prices[0];\n        dp[0][2][0] = 0;\n        dp[0][2][1] = -prices[0];\n        for(int i = 1; i < n; i++) {\n            for(int j = 1; j <= 2; j++) {\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n\n        return dp[n - 1][k][0];\n    }\n}\n```\n\n优化初始化过程\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int k = 2;\n        if(n == 0) return 0;\n        int[][][]dp = new int[n][k + 1][2];\n        for(int i = 0; i < n; i++) {\n            for(int j = 1; j <= 2; j++) {\n                if(i == 0) {\n                    dp[i][j][0] = 0;\n                    dp[i][j][1] = -prices[i];\n                    continue;\n                }\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n\n        return dp[n - 1][k][0];\n    }\n}\n```\n\nk倒着写才符合语义\n\n第0天还没开始卖，所以最大交易次数应该为k_max\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int k = 2;\n        if(n == 0) return 0;\n        int[][][]dp = new int[n][k + 1][2];\n        for(int i = 0; i < n; i++) {\n            for(int j = k; j >= 1; j--) {\n                if(i == 0) {\n                    dp[i][j][0] = 0;\n                    dp[i][j][1] = -prices[i];\n                    continue;\n                }\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n\n        return dp[n - 1][k][0];\n    }\n}\n```\n\n优化：k次数较小，可以直接列举，滚动数组\n\n```java\n// 状态转移方程：\n// dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\n// dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\n// dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\n// dp[i][1][1] = max(dp[i-1][1][1], -prices[i])\n\n// 空间复杂度优化版本\nint maxProfit_k_2(int[] prices) {\n    // base case\n    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;\n    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;\n    for (int price : prices) {\n        dp_i20 = Math.max(dp_i20, dp_i21 + price);\n        dp_i21 = Math.max(dp_i21, dp_i10 - price);\n        dp_i10 = Math.max(dp_i10, dp_i11 + price);\n        dp_i11 = Math.max(dp_i11, -price);\n    }\n    return dp_i20;\n}\n\n```\n\n\n\n空间优化2: 本质上还是因为k的次数较小，可以直接列举，缩小一个纬度\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int[][] dp = new int[prices.length][5];\n        dp[0][1] = -prices[0];\n        dp[0][3] = -prices[0];\n\n        for(int i = 1; i < prices.length; i++) {\n            dp[i][0] = dp[i-1][0];\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n        }\n\n        return dp[prices.length - 1][4];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"04-188. 买卖股票的最佳时机 IV.md","path":"002-数据结构与算法/010-动态规划/01-买卖股票问题/04-188. 买卖股票的最佳时机 IV.md","content":"### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)\n\n交易k次\n\n```\n给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n输入：k = 2, prices = [2,4,1]\n输出：2\n解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\n```\n\n\n\n```\nclass Solution {\n    public int maxProfit(int k, int[] prices) {\n        int[][] dp = new int[prices.length][2 * k + 1];\n        for(int i = 1; i < k*2; i += 2) {\n            dp[0][i] = -prices[0];\n        }\n\n        for(int i = 1; i < prices.length; i++) {\n            for(int j = 0; j < k*2 - 1; j += 2) {\n                dp[i][j + 1] = Math.max(dp[i-1][j + 1], dp[i-1][j] - prices[i]);\n                dp[i][j + 2] = Math.max(dp[i-1][j + 2], dp[i-1][j + 1] + prices[i]);\n            }\n        }\n\n        return dp[prices.length - 1][k*2];\n    }\n}\n```\n\n三维数组\n\n```\n\n```\n\n","timestamp":1694699764227},{"name":"05-309. 最佳买卖股票时机含冷冻期.md","path":"002-数据结构与算法/010-动态规划/01-买卖股票问题/05-309. 最佳买卖股票时机含冷冻期.md","content":"### [309最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)\n\n有冷冻期\n\n```\n给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n输入: prices = [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n```\n\n\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int[][] dp = new int[n][2];\n\n        for(int i = 0; i < n; i++) {\n            if(i - 1 == -1) {\n                dp[i][0] = 0;\n                dp[i][1] = -prices[0];\n                continue;\n            }\n            if(i - 2  == -1) {\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n                dp[i][1] = Math.max(dp[i-1][1], - prices[i]);\n                continue;\n            }\n\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n            // 当天持有：1 前一天持有  2 前一天没有&没有卖 今天买\n            dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);  // 解释1\n        }\n\n        return dp[n - 1][0];\n    }\n}\n```\n\n解释1：为什么是`dp[i-2][0] - prices[i]`\n\n```\n题目要求：1 卖出股票后，第二天不能买； 2 有切仅持有1支股票\n所以当前持有分为两种情况\n- 情况1：前一天持有\n- 情况2: 今天刚买。按要求1 那么就要求昨天不能卖； 按要求2 昨天不能持有\n\n为什么不能是dp[i - 1][0] - prices[i]呢？\ndp[i-1][0]有两个含义：1 前天买昨天卖； 2 前天没有，昨天也没有；\n现在已经明确今天要买，只能是“前天没有，昨天也没有”这种情况\n```\n\n","timestamp":1694699764227},{"name":"06-714. 买卖股票的最佳时机含手续费.md","path":"002-数据结构与算法/010-动态规划/01-买卖股票问题/06-714. 买卖股票的最佳时机含手续费.md","content":"### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)\n\n含手续费\n\n```\n给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。\n\n你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n\n返回获得利润的最大值。\n注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n\n输入：prices = [1, 3, 2, 8, 4, 9], fee = 2\n输出：8\n解释：能够达到的最大利润:  \n在此处买入 prices[0] = 1\n在此处卖出 prices[3] = 8\n在此处买入 prices[4] = 4\n在此处卖出 prices[5] = 9\n总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8\n```\n\n\n\n\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices, int fee) {\n        int n = prices.length;\n        int[][] dp = new int[n][2];\n        for(int i = 0; i < n; i++) {\n            if(i - 1 < 0) {\n                dp[i][0] = 0;\n                dp[i][1] = -prices[0];\n                continue;\n            }\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);\t// 与模版的唯一区别\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n        }\n\n        return dp[n - 1][0];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-72. 编辑距离.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/01-编辑距离问题/01-72. 编辑距离.md","content":"### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)\n\n思路同[583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)\n\n```java\nclass Solution {\n    public int minDistance(String word1, String word2) {\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\n        for(int i = 0; i <= word1.length(); i++) dp[i][0] = i;\n        for(int j = 0; j <= word2.length(); j++) dp[0][j] = j;\n\n        for(int i = 1; i <= word1.length(); i++) {\n            for(int j = 1; j <= word2.length(); j++) {\n                if(word1.charAt(i - 1)== word2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j - 1], dp[i - 1][j]);\n                }\n            }\n        }\n\n        return dp[word1.length()][word2.length()];\n    }\n\n    public int min(int a, int b, int c) {\n        return Math.min(a, Math.min(b, c));\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-392. 判断子序列.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/01-编辑距离问题/02-392. 判断子序列.md","content":"### [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)\n\n```\n输入：s = \"abc\", t = \"ahbgdc\"\n输出：true\n```\n\n\n\n#### 方法一：双指针\n\n```java\nclass Solution {\n    public boolean isSubsequence(String s, String t) {\n        int i = 0;\n        int j = 0;\n        while(i < s.length() && j < t.length()) {\n            if(s.charAt(i) == t.charAt(j)) {\n                i++;\n            }\n            j++;\n        }\n\n        return i == s.length();\n    }\n}\n```\n\n\n\n### 方法二：dp\n\n#### 方式1\n\n```java\nclass Solution {\n    public boolean isSubsequence(String s, String t) {\n        int n1 = s.length();\n        int n2 = t.length();\n        int[][]dp = new int[n1 + 1][n2 +1];\n        Arrays.fill(dp[0], 1);\n        for(int i = 1; i <= n1; i++) {\n            for(int j = 1; j <= n2; j++) {\n                if(s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = dp[i][j - 1];\n                }\n            }\n\n            System.out.println(Arrays.toString(dp[i]));\n        }\n\n        return dp[n1][n2] == 1;  \n    }\n}\n```\n\n#### 方式2\n\n转为求最长公共子序列，判断s与t的最长公共子序列是否=s的长度\n\n```\n\n```\n\n","timestamp":1694699764227},{"name":"03-115. 不同的子序列.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/01-编辑距离问题/03-115. 不同的子序列.md","content":"### [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)\n\n#### 方式一：\n\n注：该写法与题解的横纵坐标相反，t为纵坐标，s为横坐标\n\n```\n以s：\"baegg\"，t：\"bag\"为例，\n\n\tb a e g g \nb\na\ng\n\n题解为:\n\tb a g\nb\na\ne\ng\ng\n```\n\n\n\n```java\nclass Solution {\n    public int numDistinct(String s, String t) {\n        int[][] dp = new int[t.length() + 1][s.length() + 1];\n        for(int j = 1; j <= s.length(); j++) {\n            if(t.charAt(0) == s.charAt(j - 1)) {\n                dp[1][j] = 1 + dp[1][j - 1];\n            } else {\n                dp[1][j] = dp[1][j - 1];\n            }\n        }\n\n\n        // for(int[] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        for(int i = 2; i <= t.length(); i++) {\n            char chT = t.charAt(i - 1);\n            for(int j = 1; j <= s.length(); j++) {\n                char chS = s.charAt(j - 1);\n                if(chT == chS) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];\n                } else {\n                    dp[i][j] = dp[i][j - 1];\n                }\n            }\n        }\n\n        // System.out.println();\n        // for(int[] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        return dp[t.length()][s.length()];\n    }\n}\n```\n\n#### 方式二（为主）：\n\n重点看初始化的地方与方式一的区别，方式一直接考虑第一个字符\n\n`dp[i][j]`含义\n\n```\n表示 s[0:i-1] 中出现 t[0:j-1]的子序列数\n```\n\n递推公式\n\n![image-20221231184923838](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/12/31/18492316724837631672483763951oDUd0T-image-20221231184923838.png)\n\n```\n- s[i - 1] 与 t[j - 1] 不相等，如dp[2][2]\n\te与g不同，相当于用ba中寻找子串bag，即dp[1][2]\n\n- s[i - 1] 与 t[j - 1] 相等, 如dp[4][2]\n\t- 情况1: 使用s[4]与t[2]匹配，则匹配剩余字符，即在baeg中找子串ba\n\t- 情况2: 不使用s[4]与t[2]匹配, 即在baeg中找子串bag\n\t\t\ndp[i][j] = {\n\tdp[i - 1][j - 1] + dp[i - 1][j]; \t\t\ts[i-1] == t[j-1]\n\tdp[i][j] = dp[i - 1][j];\t\t\t\t\t\t\ts[i-1] != t[j-1]\n}\n```\n\n初始化\n\n```\n从递推公式可以看出dp[i][0] 和dp[0][j]是一定要初始化的。\ndp[i][0] 表示s[0~i-1] 中出现 空字符串 的个数，即都是1\ndp[0][j] 表示 空字符串 中出现 t[0~j-1]的个数，即都是0\n```\n\n代码\n\n```java\nclass Solution {\n    public int numDistinct(String s, String t) {\n        int[][] dp = new int[s.length() + 1][t.length() + 1];\n        for(int i = 0; i <= s.length(); i++) {\n            dp[i][0] = 1;\n        }\n\n        for(int i = 1; i <= s.length(); i++) {\n            for(int j = 1; j <= t.length(); j++) {\n                if(j > i) continue;\n                if(s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n\n        // for(int[] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        return dp[s.length()][t.length()];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"00-总结.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/02-子序列问题/00-总结.md","content":"![image-20230906212236168](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/06/21223616940065561694006556336v5FZ0p-image-20230906212236168.png)","timestamp":1694699764227},{"name":"01-300. 最长递增子序列.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/02-子序列问题/01-300. 最长递增子序列.md","content":"### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)\n\n```\ndp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度\n```\n\n\n\n```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        if(nums.length <= 1) return nums.length;\n        int[] dp = new int[nums.length];\n        for(int i = 0; i < nums.length; i++) dp[i] = 1;\t // Arrays.fill(dp, 1)\n      \n        int res = 0;\n        for(int i = 1; i < nums.length; i++) {\n            for(int j = 0; j < i; j++) {\n                if(nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); // 不是和dp[i]比较，而是取dp[j] + 1最大值\n            }\n            res = Math.max(res, dp[i]);\n        }\n\n        // System.out.println(Arrays.toString(dp));\n\n        return res;\n    }\n}\n```\n\n数组初始化为1\n\n```\nArrays.fill(dp, 1);\n```\n\n","timestamp":1694699764227},{"name":"02-674. 最长连续递增序列.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/02-子序列问题/02-674. 最长连续递增序列.md","content":"### [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)\n\n#### 方法一：dp\n\n```java\nclass Solution {\n    public int findLengthOfLCIS(int[] nums) {\n        if(nums.length <= 1) return nums.length;\n        int[] dp = new int[nums.length];\n        dp[0] = 1;\n        int res = 1;\n        for(int i = 1; i < nums.length; i++) {\n            if(nums[i] > nums[i-1]) {\n                dp[i] = dp[i-1] + 1;\n            } else {\n                dp[i] = 1;\n            }\n            res = Math.max(res, dp[i]);\n        }\n\n        return res;\n    }\n}\n```\n\n方法二：贪心","timestamp":1694699764227},{"name":"03--1035. 不相交的线.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/02-子序列问题/03--1035. 不相交的线.md","content":"### [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)\n\n等同于求两个字符串的最长公共子序列\n\n![image-20221230123117493](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/12/30/12311716723746771672374677599O85gs4-image-20221230123117493.png)\n\n```\nclass Solution {\n    public int maxUncrossedLines(int[] nums1, int[] nums2) {\n        int[][] dp = new int[nums1.length + 1][nums2.length + 1];\n        for(int i = 1; i <= nums1.length; i++) {\n            for(int j = 1; j <= nums2.length; j++) {\n                if(nums1[i - 1] == nums2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[nums1.length][nums2.length];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"04-673. 最长递增子序列的个数.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/02-子序列问题/04-673. 最长递增子序列的个数.md","content":"### [673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)\n\nhttps://programmercarl.com/0673.最长递增子序列的个数.html\n\n```\n给定一个未排序的整数数组 nums ， 返回最长递增子序列的个数。\n注意 这个数列必须是 严格 递增的。\n\n输入: [1,3,5,4,7]\n输出: 2\n解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。\n```\n\n\n\n```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int len = nums.length;\n        int[] dp = new int[len];\n        int[] count = new int[len];\n        Arrays.fill(dp, 1);\n        Arrays.fill(count, 1);\n\n        int maxLen = 1;\n        for(int i = 1; i < dp.length; i++) {\n            for(int j = 0; j < i; j++) {\n                if(nums[i] > nums[j]) {\n                    if(dp[j] + 1 > dp[i]) {\n                        count[i] = count[j];\n                        dp[i] = dp[j] + 1;\n                    } else if(dp[j] + 1 == dp[i]) {\n                        count[i] += count[j];\t\t// 解释1: 为什么是+=，不是 =\n                    } \n                }\n            }\n\n            if(dp[i] > maxLen) maxLen = dp[i];\n        }\n\n        int res = 0;\t\n        for(int i = 0; i < len; i++) {\t// 解释2: 为什么要遍历一遍求和？\n            if(dp[i] == maxLen) res += count[i];\n        }\n\n        System.out.println(Arrays.toString(dp));\n\n        return res;\n    }\n}\n```\n\n解释1:\n\n```\n因为要求所有长度为n的情况\n\n[1, 4, 3, 8]\ndp:\t\t [1, 2, 2, 3]\ncount: [1, 1, 1, 2]\n\n148 138长度都为3\ncount[3] = count[1] + count[2]\n```\n\n解释2:\n\n```\n求所有长度为maxLen的情况\n\n[1, 2, 8, 7, 6]\ndp: \t [1, 2, 3, 3, 3]\ncount: [1, 1, 1, 1, 1]\nmaxLen = 3， 可以是 128  127 126\n```\n\n","timestamp":1694699764227},{"name":"05-718.最长重复子数组.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/02-子序列问题/05-718.最长重复子数组.md","content":"### [718.最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/)\n\n```\n给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。\n\n输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n输出：3\n解释：长度最长的公共子数组是 [3,2,1] 。\n```\n\n\n\ndp数组\n\n```\ndp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 \n（特别注意： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）\n\ndp[0][5]对应7，7在nums2中是nums[5-1] = nums[4]\n```\n\n定义`dp[i][j]`为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。不行么？\n\n行倒是行！ 但实现起来就麻烦一点，需要单独处理初始化部分\n\n![image-20221229171246639](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/11/22193516838147751683814775530sDft8r-17124616723051661672305166836EFLQqv-image-20221229171246639.png)\n\n```java\nclass Solution {\n    public int findLength(int[] nums1, int[] nums2) {\n        int res = 0;\n        int[][] dp = new int[nums1.length + 1][nums2.length + 1];\n        for(int i = 1; i <= nums1.length; i++) {\n            for(int j = 1; j <= nums2.length; j++) {\n                if(nums1[i - 1] == nums2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }\n                res = Math.max(res, dp[i][j]);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n滚动数组\n\n```java\nclass Solution {\n    public int findLength(int[] nums1, int[] nums2) {\n        int res = 0;\n        int[] dp = new int[nums2.length + 1];\n        for(int i = 1; i <= nums1.length; i++) {\n            for(int j = nums2.length; j > 0; j--) {\n                if(nums1[i - 1] == nums2[j - 1]) {\n                    dp[j] = dp[j - 1] + 1;\n                } else {\n                    dp[j] = 0;\t// 注意一定要置0\n                }\n                res = Math.max(res, dp[j]);\n\n            }\n            //  System.out.println(Arrays.toString(dp));\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-1143. 最长公共子序列.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/03-公共子序列/01-1143. 最长公共子序列.md","content":"### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)\n\ndp定义\n\n```\ndp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]\n```\n\n![image-20221230114223703](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/12/30/11422316723717431672371743862wSpDZC-image-20221230114223703.png)\n\n```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int[][] dp = new int[text1.length() + 1][text2.length() + 1];\n        for(int i = 1; i <= text1.length(); i++) {\n            for(int j = 1; j <= text2.length(); j++) {\n                if(text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[text1.length()][text2.length()];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-583. 两个字符串的删除操作.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/03-公共子序列/02-583. 两个字符串的删除操作.md","content":"### [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)\n\n#### 题目\n\n```\n给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。\n每步 可以删除任意一个字符串中的一个字符。\n\n输入: word1 = \"sea\", word2 = \"eat\"\n输出: 2\n解释: 第一步将 \"sea\" 变为 \"ea\" ，第二步将 \"eat \"变为 \"ea\"\n```\n\n\n\n#### 方法一：dp\n\n同[1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)\n\n求完公共子序后，多余的字符串就是要操作的次数\n\n```java\nclass Solution {\n    public int minDistance(String word1, String word2) {\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\n        for(int i = 1; i <= word1.length(); i++) {\n            for(int j = 1; j <= word2.length(); j++) {\n                if(word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        int len = dp[word1.length()][word2.length()];\n        return (word1.length() - len) + (word2.length() - len);\n    }\n}\n```\n\n#### 方法二：dp\n\n[115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)的变种\n\n\n\ndp\n\n```\ndp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。\n```\n\n递推公式\n\n```\n- word1[i - 1] == word2[j - 1]\n\t即不同考虑当前字符串，情况和dp[i-1][j-1]同\n\n- word1[i - 1] != word2[j - 1]\n  情况1：考虑删除word1[i - 1]，把word1[0 ~ i-2]变成word2， \n  情况2：考虑删除word2[j - 1], 把word2[0 ~ j-2]变成word1\n \t取代价最小的一个，即1 + min(dp[i - 1][j], dp[i][j - 1])\n```\n\n![image-20230101122702887](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/01/01/12270316725472231672547223017Nv6toS-image-20230101122702887.png)\n\njava\n\n```java\nclass Solution {\n    public int minDistance(String word1, String word2) {\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\n        for(int i = 0; i <= word1.length(); i++) dp[i][0] = i;\n        for(int j = 0; j <= word2.length(); j++) dp[0][j] = j;\n        for(int i = 1; i <= word1.length(); i++) {\n            for(int j = 1; j <= word2.length(); j++) {\n                if(word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1;\n                }\n            }\n        }\n\n        return dp[word1.length()][word2.length()];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"03-712. 两个字符串的最小ASCII删除和.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/03-公共子序列/03-712. 两个字符串的最小ASCII删除和.md","content":"### [712. 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)\n\n```\n给定两个字符串s1 和 s2，返回 使两个字符串相等所需删除字符的 ASCII 值的最小和 。\n\n输入: s1 = \"sea\", s2 = \"eat\"\n输出: 231\n解释: 在 \"sea\" 中删除 \"s\" 并将 \"s\" 的值(115)加入总和。\n在 \"eat\" 中删除 \"t\" 并将 116 加入总和。\n结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。\n```\n\n\n\n\n\n```java\nclass Solution {\n    public int minimumDeleteSum(String s1, String s2) {\n        int n1 = s1.length();\n        int n2 = s2.length();\n\n\n        int[][] dp = new int[n1 + 1][n2 + 1];\n\n        for(int j = 1; j <= n2; j++) dp[0][j] = dp[0][j - 1] + (int)s2.charAt(j - 1);\n        for(int j = 1; j <= n1; j++) dp[j][0] = dp[j - 1][0] + (int)s1.charAt(j - 1);\n\n        for(int i = 1; i <= n1; i++) {\n            for(int j = 1; j <= n2; j++) {\n                int ch1 = (int)s1.charAt(i - 1);\n                int ch2 = (int)s2.charAt(j - 1);\n                if(ch1 == ch2) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.min(dp[i - 1][j] + ch1, dp[i][j - 1] + ch2);\n                }\n            }\n        } \n\n        return dp[n1][n2];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"00-总结.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/04-回文串/00-总结.md","content":"![image-20230906212935699](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/06/21293516940069751694006975807zqIPJm-image-20230906212935699.png)","timestamp":1694699764227},{"name":"01-647. 回文子串.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/04-回文串/01-647. 回文子串.md","content":"### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)\n\n```\n给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。\n\n输入：s = \"abc\"\n输出：3\n解释：三个回文子串: \"a\", \"b\", \"c\"\n```\n\n\n\n```java\nclass Solution {\n    public int countSubstrings(String s) {\n        int res = 0;\n        int[][] dp = new int[s.length()][s.length()];\n        // 从下到上，从左到右遍历\n        for(int i = s.length() - 1; i >= 0; i--) {\n            for(int j = i; j < s.length(); j++) {\n                if(s.charAt(i) == s.charAt(j)) {\n                    if(j - i <= 1) {\n                        res++;\n                        dp[i][j] = 1;\n                    } else if(dp[i + 1][j - 1] == 1) {\n                        res++;\n                        dp[i][j] = 1;\n                    }\n                } \n            }\n        }\n\n        // for(int [] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        return res;\n    }\n}\n```\n\n\n\n```\n\"abccb\"  7\n\n[1, 0, 0, 0, 0]\n[0, 1, 0, 0, 1]\n[0, 0, 1, 1, 0]\n[0, 0, 0, 1, 0]\n[0, 0, 0, 0, 1]\n```\n\n","timestamp":1694699764227},{"name":"02-516. 最长回文子序列.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/04-回文串/02-516. 最长回文子序列.md","content":"### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)\n\n```\n给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。\n子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\n\n输入：s = \"bbbab\"\n输出：4\n解释：一个可能的最长回文子序列为 \"bbbb\" 。\n```\n\n注：可以删除某些字符\n\n\n\ndp含义\n\n```\ndp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。\n```\n\n错解\n\n```java\nclass Solution {\n    public int longestPalindromeSubseq(String s) {\n        int len = s.length();\n        int[][] dp = new int[len][len];\n        for(int i = 0; i < len; i++) dp[i][i] = 1;\n\n        for(int i = len - 1; i >= 0; i--) {\n            for(int j = i; i < len; j++) {\n                if(s.charAt(i) == s.charAt(j)) {\n                    if(dp[i + 1][j - 1] != 0) {\t\t\t// 考虑越界 b、bb\n                        dp[i][j] = 2 + dp[i + 1][j - 1];\n                    }\n                } else {\n                    dp[i][j] = Math.max(dp[i][ j - 1], dp[i + 1][j]);\n                }\n            }\n        }\n\n        return dp[0][len - 1];\n    }\n}\n```\n\n正解\n\n```java\nclass Solution {\n  \t// s: bbbab\n    public int longestPalindromeSubseq(String s) {\n        int len = s.length();\n        int[][] dp = new int[len][len];\n        for(int i = len - 1; i >= 0; i--) {\n            for(int j = i; j < len; j++) {\n                if(s.charAt(i) == s.charAt(j)) {\n                    if(j == i) {\t// b\n                        dp[i][j] = 1;\n                    } else if(j - i == 1) {  // bb\n                        dp[i][j] = 2;\n                    } else {  // bab  baab  babb  bacb\n                        dp[i][j] = 2 + dp[i + 1][j - 1];\n                    }\n                } else {  // bbba\n                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[0][len - 1];\n    }\n}\n```\n\n\n\n```java\n[1, 2, 3, 3, 4]\n[0, 1, 2, 2, 3]\n[0, 0, 1, 1, 3]\n[0, 0, 0, 1, 1]\n[0, 0, 0, 0, 1]\n```\n\n优化：直接初始化对角线为1\n\n```java\nclass Solution {\n    public int longestPalindromeSubseq(String s) {\n        int len = s.length();\n        int[][] dp = new int[len][len];\n        for(int i = len - 1; i >= 0; i--) {\n            dp[i][i] = 1;\t\t// 区别1\n            for(int j = i + 1; j < len; j++) {\t// 区别2： 不再处理对角线元素, 防止j-1越界\n                if(s.charAt(i) == s.charAt(j)) {  // bab  baab  babb\n                    dp[i][j] = 2 + dp[i + 1][j - 1];\n                    \n                } else {  // bbba\n                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        // for(int [] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        return dp[0][len - 1];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"03-5. 最长回文子串.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/04-回文串/03-5. 最长回文子串.md","content":"### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)\n\n#### 方法一：中心扩散法\n\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        String res = \"\";\n        for(int i = 0; i < s.length(); i++) {\n            String s1 = extend(s, i, i);\n            res = s1.length() > res.length() ? s1 : res; // 以i为中心，奇数情况\t\taba\n\n            String s2 = extend(s, i, i + 1);\n            res = s2.length() > res.length() ? s2 : res;\t// 以i和i+1为中心，偶数情况 \tabba\n        }\n        \n        return res;\n    }\n\n    public String extend(String s, int i, int j) {\n        String tmp = \"\";\n        while(i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {\n            if(j - i + 1 > tmp.length()) {\n                tmp = s.substring(i, j + 1);\n            }\n            i--;\n            j++;\n        }\n\n        return tmp;\n    }\n}\n```\n\n\n\n#### 方法二：dp\n\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        int len = s.length();\n        boolean[][] dp = new boolean[len][len];\n\n        int left = 0;\n        int right = 0;\n        int maxLen = 0;\n        for(int i = len - 1; i >= 0; i--) {\n            for(int j = i; j < len; j++) {\n                if(s.charAt(i) == s.charAt(j)) {\n                    if(j - i <= 1) {    // a  aa \n                        dp[i][j] = true;\n                    } else {    // aba  abca\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                }\n\n                if(dp[i][j] && j - i + 1 > maxLen) {\n                    left = i;\n                    right = j;\n                    maxLen = j - i + 1;\n                }\n            }\n        }\n\n        // for(boolean[] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        return s.substring(left, right + 1);\n    }\n}\n```\n\n方式2\n\n需要单独处理特殊情况\n\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        if(n <= 1) return s;\n        String res = String.valueOf(s.charAt(0));\t// a ac\n        int[][] dp = new int[n][n];\n\n        for(int i = n - 1; i >= 0; i--) {\n            dp[i][i] = 1;\n            for(int j = i + 1; j < n; j++) {\n                if(s.charAt(i) == s.charAt(j)) {\n                    if(j - i <= 1) {\n                        dp[i][j] = 1;\n                    } else {\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                } \n\n                if(dp[i][j] == 1 && j - i + 1 > res.length()) {\n                    res = s.substring(i, j + 1);\n                    // System.out.println(res);\n                }\n            }\n        }\n\n        for(int[] d : dp) {\n            System.out.println(Arrays.toString(d));\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"04-132. 分割回文串 II.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/04-回文串/04-132. 分割回文串 II.md","content":"### [132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)\n\n`s[0 : i]` 要切割为回文串\n\n-   `s[0 : i]`本身就是回文串\n-   在`j`处切割，则要求`s[j + 1 : i] `为回文，则切割数为`s[j] + 1`\n\n```java\nclass Solution {\n    public int minCut(String s) {\n        int len = s.length();\n        boolean[][] isPalindromic = new boolean[len][len];\n\n        // 从下到上，从左到右遍历, 记录字符是否是回文\n        for(int i = len - 1; i >= 0; i--) {\n            for(int j = i; j < len; j++) {\n                if(s.charAt(i) == s.charAt(j)) {\n                    if(j - i <= 1) {\n                        isPalindromic[i][j] = true;\n                    } else {\n                        isPalindromic[i][j] = isPalindromic[i + 1][j - 1];\n                    }\n                }\n            }\n        }\n\n        // for(boolean[] d : isPalindromic) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        int[] dp = new int[len];\t\t// s[0 : i]是回文串的最少分割次数为dp[i]\n        for(int i = 0; i < len; i++) dp[i] = i;\n        for(int i = 1; i < len; i++) {\n            if(isPalindromic[0][i]) {  // s[0:i]是回文无需切割\n                dp[i] = 0;\n            } else {    // 找到最小的切割次数\n                for(int j = 0; j < i; j++) {\n                    if(isPalindromic[j + 1][i]) {  // s[j+1 : i]也是回文，则是一种切割方案\n                        dp[i] = Math.min(dp[i], dp[j] + 1);\t// 解释1： 为什么是dp[j] + 1\n                    }  \n                }\n            }\n\n        }\n\n        // for(int d : dp) {\n        //     System.out.print(d + \" \");\n        // }\n\n        return dp[len - 1];\n    }\n}\n```\n\n解释1\n\n```\n如果要对长度为[0, i]的子串进行分割，分割点为j\n那么如果分割后，区间[j + 1, i]是回文子串，那么dp[i] 就等于 dp[j] + 1。\n\n为什么不看[0, j]区间是不是回文子串呢？\ndp[i]表示s[0 : i]是回文串的最少分割次数，即dp[j]已经表示把s[0:j]进行切割成回文串了\n\nj = 0, 1, ..., i都可能是切割点，所以要取最小值。isPalindromic[j + 1][i] = true则表示可以在该点j切割\n```\n\n\n\n\n\n\n\n#### 错解\n\n`dp[i][j]`记录`s[i : j]`切割成回文串的最小切割数\n\n```\n0 1 2 3 4 5\na b b c b c\n\n    0  1\t2\t 3\t4\t 5\n0  [0, 1, 1, 2, 2, 3]\n1  [0, 0, 0, 1, 1, 2]\n2  [0, 0, 0, 1, 0, 1]\n3  [0, 0, 0, 0, 1, 0]\n4  [0, 0, 0, 0, 0, 1]\n5  [0, 0, 0, 0, 0, 0]\n\nchar[i] == char[j]:\n  0 1 2 3\n  b b c b \n  dp03 = {\n    dp12\n    dp13 + 1\n    dp02 + 1\n  }\n\nchar[i] != char[j]:\n\t0 1 2 3 4 5\n\ta b b c b c    =\ta\t bb\tcbc\n\tdp05 = {\n\t\tdp04 + 1 = 3\n\t\tdp15 + 1 = 3\t\t此处有误,dp15最好的分法是bb\tcbc，按此解法只有dp14 + 1, dp25 + 1, dp24 + 2，无法得到最优\n\t\tdp14 + 2 = 3\n\t}\n```\n\n\n\n```java\nclass Solution {\n    public int minCut(String s) {\n        int len = s.length();\n        int[][] dp = new int[len][len];\n\n        // 从下到上，从左到右遍历\n        for(int i = len - 1; i >= 0; i--) {\n            dp[i][i] = 0;   // 初始化对角线，可省略\n            for(int j = i + 1; j < len; j++) {\n                if(s.charAt(i) == s.charAt(j)) {\n                    if(dp[i + 1][j - 1] == 0) {\n                        dp[i][j] = dp[i + 1][j - 1];\n                    } else {\n                        dp[i][j] = Math.min(dp[i + 1][j - 1] + 2, dp[i + 1][j] + 1);\n                        dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1);\n                    }  \n                } else {\n                    dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;\n                }\n            }\n        }\n\n        for(int[] d : dp) {\n            System.out.println(Arrays.toString(d));\n        }\n\n        return dp[0][len - 1];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"05-1312. 让字符串成为回文串的最少插入次数.md","path":"002-数据结构与算法/010-动态规划/02-子序列类问题/04-回文串/05-1312. 让字符串成为回文串的最少插入次数.md","content":"### [1312. 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)\n\n```\n给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。\n请你返回让 s 成为回文串的 最少操作次数 。\n「回文串」是正读和反读都相同的字符串。\n\n输入：s = \"mbadm\"\n输出：2\n解释：字符串可变为 \"mbdadbm\" 或者 \"mdbabdm\" 。\n```\n\n\n\n二维\n\n```\nclass Solution {\n    public int minInsertions(String s) {\n        int len = s.length();\n        int[][] dp = new int[len][len];\n        for(int i = len - 1; i >= 0; i--) {\n            // dp[i][i] = 0;       // 自己本身就是回文串\n            for(int j = i + 1; j < len; j++) {\n                if(s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[i + 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + Math.min(dp[i + 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[0][len - 1];\n    }\n}\n```\n\n一维\n\n```\nclass Solution {\n    public int minInsertions(String s) {\n        int len = s.length();\n        int[] dp = new int[len];\n        for(int i = len - 1; i >= 0; i--) {\n            int pre = 0;\n            for(int j = i + 1; j < len; j++) {\n                // 记录覆盖前的值\n                int temp = dp[j];\n                if(s.charAt(i) == s.charAt(j)) {\n                    dp[j] = pre;\n                } else {\n                    dp[j] = 1 + Math.min(dp[j - 1], dp[j]);\n                }\n                pre = temp;\n            }\n        }\n\n        return dp[len - 1];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-70. 爬楼梯.md","path":"002-数据结构与算法/010-动态规划/03-爬楼梯问题/01-70. 爬楼梯.md","content":"### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)\n\n可以跳一步、两步，所以分解为跳到n-1然后再跳一步 + 跳到n-2 再跳 2步\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        if(n <= 2) return n;\n        int[] dp = new int[n + 1];\n        // dp[0] = 0;\n        dp[1] = 1;\n        dp[2] = 2;\n        for(int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n\n        return dp[n];\n    }\n}\n```\n\n优化空间\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        if(n <= 2) return n;\n        int[] dp = new int[3];\n        dp[1] = 1;\n        dp[2] = 2;\n        for(int i = 3; i <= n; i++) {\n            int sum = dp[1] + dp[2];\n            dp[1] = dp[2];\n            dp[2] = sum;\n        }\n\n        return dp[2];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-746. 使用最小花费爬楼梯.md","path":"002-数据结构与算法/010-动态规划/03-爬楼梯问题/02-746. 使用最小花费爬楼梯.md","content":"### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)\n\ndp[i] ：跳到第i个台阶的最小代价\n\n```java\ndp[i] = {\n\tdp[i] = Math.min(cost[i-2], dp[i-1] + cost[i-1])    \t\t\t\t\ti <= 3\n\tdp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1])\t\t其他\n}\n```\n\n\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        if(n <= 1) return Math.min(cost[0], cost[1]);\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = cost[0];\n        dp[2] =  Math.min(cost[0], cost[1]);\n        for(int i = 3; i <= n; i++) {\n            if(i - 2 <= 1) {\n                dp[i] = Math.min(cost[i-2], dp[i-1] + cost[i-1]);\n            } else {\n                dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]);\n            }\n            \n        }\n        \n        return dp[n];\n    }\n}\n```\n\n优化：\n\n初始化时搭配dp[0] 和 dp[1] 为0\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]);\n        }\n        \n        return dp[n];\n    }\n}\n```\n\n优化：空间复杂度\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int dp0 = 0;\n        int dp1 = 0;\n        for(int i = 2; i <= cost.length; i++) {\n            int dpi = Math.min(dp0 + cost[i-2], dp1 + cost[i-1]);\n            dp0 = dp1;\n            dp1 = dpi;\n        }\n        \n        return dp1;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"03-爬楼梯进阶.md","path":"002-数据结构与算法/010-动态规划/03-爬楼梯问题/03-爬楼梯进阶.md","content":"参考背包问题","timestamp":1694699764227},{"name":"100-背包问题.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/100-背包问题.md","content":"### 二维dp数组\n\n``` java\ndp[i][j]：  从序号为0～i的物品中选择，放入重量为j的背包 的最大总价值\n推导：\n1. 不放物品i：\n\t\t物品i太重，无法放入，情况与dp[i-1][j]相同\n2. 放入物品i:\n\t\t先发放物品i，背包容量剩余j - weight[i], 再从0 ~ i-1中选择装入\n\t\tvalue[i] + dp[i - 1][j - weight[i]]\n\t\t\n递推公式：\t\t\ndp[i][j] = Math.max(\n\t\t\tdp[i - 1][j], \t\t// 不放物品i\n      dp[i - 1][j - weight[i]] + value[i]  // 放物品i，剩余容量放0～i-1的最大值\n  ); \n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/11/08/09483116678721111667872111722sxwrjX-image-20221108094831559.png\" alt=\"image-20221108094831559\" style=\"zoom: 33%;\" />\n\n初始化\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/11/08/09491816678721581667872158466pXotq2-image-20221108094918378.png\" alt=\"image-20221108094918378\" style=\"zoom: 25%;\" />\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/11/08/154939166789377916678937792377pLUO3-image-20221108154939044.png\" alt=\"image-20221108154939044\" style=\"zoom: 33%;\" />\n\n#### 先放遍历物品，后遍历背包重量（通常做法）\n\n从左到右，从上倒下\n\n```java\npublic class Test {\n\n    public int knapsack(int[] value, int[] weight, int bagweight) {\n        int[][] dp = new int[value.length][bagweight + 1];\n        // for(int i = 0; i < value.length; i++) {  // 下方j=0开始，可省略此步\n        //     dp[i][0] = 0;   \n        // }\n        for(int j = 1; j <= bagweight; j++) {    \n            dp[0][j] = value[0];\n        }\n\n        for(int i = 1; i < weight.length; i++) {    // 遍历物品\n            for(int j = 0; j <= bagweight; j++) {   // 遍历背包容量\n                if(weight[i] > j) {  // 超过背包容量\n                    dp[i][j] = dp[i-1][j];  \n                } else {  // 可以放入\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - weight[i]] + value[i]);\n                }\n            }\n        }\n\n        for(int[] d : dp) {\n            for(int i : d) {\n                System.out.print(i + \" \");\n            }\n            System.out.println();\n        }\n\n\n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        int[] weight = new int[]{1, 3, 4};\n        int[] value = new int[]{15, 20, 30};\n        Test t = new Test();\n        t.knapsack(value, weight, 4);\n    }\n}\n\n\n```\n\n#### 先遍历背包，再遍历物品\n\n从上到下，从左到右\n\n```java\npublic class Test {\n\n    public int knapsack(int[] value, int[] weight, int bagweight) {\n        int[][] dp = new int[value.length][bagweight + 1];\n        // for (int i = 0; i < value.length; i++) {\n        //     dp[i][0] = 0;\n        // }\n        for(int j = 1; j <= bagweight; j++) { // 下方j=0开始，可省略此步\n        dp[0][j] = value[0];\n        }\n\n        for (int j = 0; j <= bagweight; j++) { // 遍历背包容量\n            for (int i = 1; i < weight.length; i++) { // 遍历物品\n                if (weight[i] > j) { // 超过背包容量\n                    dp[i][j] = dp[i - 1][j];\n                } else { // 可以放入\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n                }\n            }\n        }\n\n        for (int[] d : dp) {\n            for (int i : d) {\n                System.out.print(i + \" \");\n            }\n            System.out.println();\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] weight = new int[] { 1, 3, 4 };\n        int[] value = new int[] { 15, 20, 30 };\n        Test t = new Test();\n        t.knapsack(value, weight, 4);\n    }\n}\n\n```\n\n\n\n### 一维dp数组 - 滚动数组\n\n#### 1 dp定义\n\n```\ndp[j]容量为j的背包，所背的物品价值可以最大为dp[j]\n```\n\n可以理解为，每次遍历物品时，将上一层的数组先拷贝到当前层，再更新\n\n#### 2 递推公式\n\n```java\ndp[j] = max(\n\t\tdp[j], \t// 不放物品i\n\t\tdp[j - weight[i]] + value[i]  // 放物品i，剩余容量放0～i-1的最大值\n );\n```\n\n\n\n```\ni = 0\nj = 4  dp4 = max(dp4, dp[4 - weight[0]] + value[0]) = max(0, dp3 + 15) = max(0, 15);\nj = 3  dp3 = max(dp3, dp[3 - weight[0]] + value[0]) = max(0, dp2 + 15) = max(0, 15);\n...\nj = 1  dp1 = max(dp1, dp[1 - weight[0]] + value[0]) = max(0, dp0 + 15) = max(0, 15);\n\n1 = 1\nj = 4  dp4 = max(dp4, dp[4 - weight[1]] + value[1]) = max(15, dp1 + value[1]) = max(15, 35);\n```\n\n#### 3 初始化\n\n都初始化为0\n\n#### 4 遍历顺序\n\n二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。\n\n##### 为什么倒序？\n\n倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！\n\n用二维数组来理解，一维数组是每次将二维数组的上一层复制到当前层再更新\n\n如果`dp[i][j]`要用到`dp[i-1][j-1]`, 在一维数组中，正序遍历还没遍历到`dp[i][j]` 就已经更新了`dp[i-1][j-1]`，而更新`dp[i][j]`是要用到上一层的`dp[i-1][j-1]`而不是当前层的`dp[i-1][j-1]`\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] weight = {1, 3, 4};\n        int[] value = {15, 20, 30};\n        int bagWight = 4;\n        testWeightBagProblem(weight, value, bagWight);\n    }\n\n    public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight){\n        int wLen = weight.length;\n        //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值\n        int[] dp = new int[bagWeight + 1];\n        //遍历顺序：先遍历物品，再遍历背包容量\n        for (int i = 0; i < wLen; i++){\n            for (int j = bagWeight; j >= weight[i]; j--){\n                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);\n            }\n            System.out.println(\"===weight: \" + weight[i] + \"; value: \" + value[i] + \"===\");\n            for (int j = 0; j <= bagWeight; j++){\n                System.out.print(dp[j] + \" \");\n            }\n            System.out.println();\n            System.out.println();\n\n        }\n    }\n}\n```\n倒序遍历\n```\n===weight: 1; value: 15===\n0 15 15 15 15 \n\n===weight: 3; value: 20===\n0 15 15 20 35 \n\n===weight: 4; value: 30===\n0 15 15 20 35 \n```\n\n正序遍历\n\n```\n===weight: 1; value: 15===\n0 15 30 45 60 \n\n===weight: 3; value: 20===\n0 15 30 45 60 \n\n===weight: 4; value: 30===\n0 15 30 45 60 \n```\n\n\n\n问：为啥一定要倒序遍历，折麽写结果也是正确的???\n\n需要先根据物品0初始化dp数组\n\n这个情况应该是特殊情况的一种，\n\n```java\npublic class Test {\n\n    public int knapsack(int[] value, int[] weight, int bagweight) {\n        int[] dp = new int[bagweight + 1];\n\n        for (int i = 1; i <= bagweight; i++)\n            dp[i] = value[0];\n\n        for (int i = 1; i < weight.length; i++) { // 遍历物品\n            for (int j = weight[i]; j <= bagweight; j++) { // 遍历背包容量\n                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);\n                // dp3 = dp[3 - weight[1]] + value[1]] = dp0 + 20 = 0 + 20 = 20\n                // dp4 = dp[4 - weight[1]] + value[1]] = dp1 + 20 = 15 + 20 = 35\n\n            }\n\n            System.out.println(\"===weight: \" + weight[i] + \"; value: \" + value[i] + \"===\");\n            for (int d : dp) {\n                System.out.print(d + \" \");\n            }\n            System.out.println();\n            System.out.println();\n        }\n\n        return dp[bagweight];\n    }\n\n    public static void main(String[] args) {\n        int[] weight = new int[] { 1, 3, 4 };\n        int[] value = new int[] { 15, 20, 30 };\n        Test t = new Test();\n        t.knapsack(value, weight, 4);\n    }\n}\n```\n\n\n\n```\n===weight: 3; value: 20===\n0 15 15 20 35 \n\n===weight: 4; value: 30===\n0 15 15 20 35 \n```\n\n","timestamp":1694699764227},{"name":"101-416. 分割等和子集.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/101-416. 分割等和子集.md","content":"### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)\n\n```\n输入：nums = [1,5,11,5]\n输出：true\n解释：数组可以分割成 [1, 5, 5] 和 [11] \n```\n\n**题目分析：**\n\n对各元素只有取或不取，价值为nums[i], 体积也为nums[i], 所以可以用背包问题\n\n元素只使用一次，属于01背包问题\n\n题目可转换成：集合中的元素能否凑成sum / 2\n\n\n\n**套用01背包的条件：**\n\n-   背包体积为sum/2\n-   重量为num[i]，价值也为nums[i]\n-   背包正好装满，说明找到总和为sum/2的子集\n-   背包中每个元素不能重复放入，每个元素只能使用一次\n\n\n\n#### 一维dp\n\n**动规五部曲：**\n\n1.  确定dp数组以及下标的含义\n\n    ```\n    dp[j] 表示 背包总容量为j，最大可以凑成的子集总和\n    ```\n\n2.   确定递推公式\n\n     ```\n     01背包：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n     本  题：dp[j] = max(dp[j], dp[j - nums[i]] + value[i]);\n     ```\n\n     \n\n     \n\n```java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int target = 0;\n        for(int n : nums) {\n            target += n;\n        }\n        if(target % 2 == 1) return false;\n        target /= 2;\n        \n        int[] dp = new int[10001]; // target <= 1w\n        for(int i = 0; i < nums.length; i++) {\n            for(int j = target; j >= nums[i]; j--) {\n                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);\n            }\n        }\n\n        return dp[target] == target;\n    }\n}\n```\n\n```\n从右往左，从上到下遍历\ndp\n    0 1 1 1 1 1 1 1 1 1 1 \t1 \n    0 1 1 1 1 5 6 6 6 6 6 \t6 \n    0 1 1 1 1 5 6 6 6 6 6 \t11 \n    0 1 1 1 1 5 6 6 6 6 10 \t11 \n \n    \ni = 0 nums[0] = 1\n\tdp[j] = max (dp[j], dp[j - 1] + 1)\n```\n\n\n\n#### 二维dp\n\n先物品后背包\n\n```java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int sum = 0;\n        for(int n : nums) sum += n;\n        if(sum % 2 != 0) return false;\n\n        int target = sum / 2;\n        int[][] dp = new int[nums.length][target + 1];\n        for(int j = nums[0]; j <= target; j++) dp[0][j] = nums[0];\n\n        System.out.println(Arrays.toString(dp[0]));\n\n        for(int i = 1; i < nums.length; i++) {  // 物品\n            for(int j = 1; j <= target; j++) {  // 背包\n                if(j < nums[i]) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);\n                }\n            }\n\n            System.out.println(Arrays.toString(dp[i]));\n        }\n\n        return dp[nums.length - 1][target] == target;\n    }\n}\n```\n\n```\n[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n[0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 6, 6]\n[0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 6, 11]\n[0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 10, 11]\n```\n\n先背包，后物品\n\n```java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        for(int num : nums) sum += num;\n        if(sum % 2 != 0) return false;\n        int target = sum / 2;\n\n        int[][] dp = new int[n + 1][target + 1];\n        for(int j = 1; j <= target; j++) {\n            for(int i = 1; i <= n; i++) {\n                if(j >= nums[i - 1]) {\n                    dp[i][j] = Math.max(dp[i - 1][j], nums[i - 1] + dp[i-1][j - nums[i - 1]]);\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n\n        // for(int[] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n        \n\n        return dp[n - 1][target] == target;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"102-1049. 最后一块石头的重量 II.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/102-1049. 最后一块石头的重量 II.md","content":"### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)\n\n```\n输入：stones = [2,7,4,1,8,1]\n输出：1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n```\n\n**题目分析**\n\n-   对各元素只有取与不取，重量、价值均为stones[i]，属于背包问题\n-   只能取一次，属于01背包\n-   题目转换：与分割等和子集类似，尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，**这样就化解成01背包问题了**。\n\n\n\n#### 一维数组\n\n```java\nclass Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int sum = 0;\n        for(int s : stones) {\n            sum += s;\n        }\n        int target = sum / 2;\n        int[] dp = new int[target + 1];\n        for(int i = 0; i < stones.length; i++) {\t// 遍历物品\n            for(int j = target; j >= stones[i]; j--) {\t\t// 遍历背包\n                dp[j] = Math.max(dp[j], stones[i] + dp[j - stones[i]]);\n            }\n        }\n\n        return (sum - dp[target]) - dp[target]; // target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]\n    }\n}\n```\n\n\n\n#### 二维数组\n\n```java\nclass Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int sum = 0;\n        for(int s : stones) {\n            sum += s;\n        }\n        int target = sum / 2;\n\n        int n = stones.length;\n        int[][] dp = new int[n][target + 1];\n        for(int j = stones[0]; j <= target; j++) dp[0][j] = stones[0];\n\n        for(int i = 1; i < n; i++) {\n            for(int j = 0; j <= target; j++) {\n                if(j < stones[i]) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = Math.max(dp[i-1][j], stones[i] + dp[i-1][j - stones[i]]);\n                }\n            }\n        }\n\n        return (sum - dp[n - 1][target]) - dp[n - 1][target];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"103-494. 目标和.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/103-494. 目标和.md","content":"### [494. 目标和](https://leetcode.cn/problems/target-sum/)\n\n思考如何转为01背包问题？\n\n#### 方法一：dp\n\n##### 一维dp\n\ndp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法\n\n```java\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for(int n : nums)  sum += n;\n        // 和超出范围，无解\n        if(Math.abs(target) > sum) return 0;\n        // 出现小数，无解\n        if((target + sum) % 2 == 1) return 0;\n\n        int newTarget = (sum + target) / 2;\n        if(newTarget < 0) return 0;\n\n        int[] dp = new int[newTarget + 1];  // 和为j的方案有dp[j]种\n        dp[0] = 1;  // 和为0的方案有一种，不装\n        for(int i = 0; i < nums.length; i++) {\n            for(int j = newTarget; j >= nums[i]; j--) {\n              \t// dp[j] = dp[j] + dp[j - nums[i]];  选nums[i] + 不选nums[i]\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n\n        return dp[newTarget];\n    }\n}\n```\n\n##### 二维dp\n\n使用`dp[n + 1`][newTarget] 会比 `dp[n][newTarget]`好处理\n\n```java\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for(int num : nums) sum += num;\n        int newTarget = (sum + target) / 2;\n        // System.out.println(\"newTarget: \" + newTarget);\n\n        if (Math.abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        \n        int n = nums.length;\n        int[][] dp = new int[n + 1][newTarget + 1];\n        dp[0][0] = 1;\n\n        for(int i = 1; i <= n; i++) {\n            for(int j = 0; j <= newTarget; j++) {\n                if(j < nums[i - 1]) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\n                }\n            }\n        }\n\n        // for(int[] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        return dp[n][newTarget];\n    }\n}\n```\n\n\n\n#### 方法二：回溯\n\n##### 回溯1\n\n每个元素可以有 + 或 - 两种选择\n\n```java\nclass Solution {\n    int count = 0;\n\n    public int findTargetSumWays(int[] nums, int target) {\n        backtrack(nums, target, 0, 0);\n        return count;\n    }\n\n    void backtrack(int[] nums, int target, int index, int sum) {\n        if(index == nums.length) {\n            if(sum == target) count++;\n            return;\n        }\n\n        backtrack(nums, target, index + 1, sum + nums[index]);\n        backtrack(nums, target, index + 1, sum - nums[index]);\n    }\n}\n```\n\n\n\n##### 回溯2\n\n转为组合总和问题\n\n```\nleft + right = sum；\nright = sum - left；\n=> left = (target + sum)/2 。\n```\n\n用例没过完\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    LinkedList<Integer> path = new LinkedList<>();\n\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for(int num : nums) sum += num;\n        int newTarget = (sum + target) / 2;\n        // System.out.println();\n        if(target > sum) return 0;\n        if((target + sum) % 2 != 0) return 0;\n\n        backtrack(nums, newTarget, 0, 0);\n        return res.size();\n    }\n\n    public void backtrack(int[] nums, int target, int startIndex, int sum) {\n        // if(sum == target) {\n        //     res.add(new LinkedList(path));\n        // }\n\n        // for(int i = startIndex; i < nums.length && sum + nums[i] <= target; i++) {\n        //     sum += nums[i];\n        //     path.add(nums[i]);\n        //     backtrack(nums, target, i + 1, sum);\n        //     sum -= nums[i];\n        //     path.removeLast();\n        // }\n\n        if(sum == target) {\n            res.add(new LinkedList(path));\n            return;\n        }\n\n        if(sum > target) return;\n\n        for(int i = startIndex; i < nums.length; i++) {\n            path.add(nums[i]);\n            sum += nums[i];\n\n            backtrack(nums, target, i + 1, sum);\n\n            path.removeLast();\n            sum -= nums[i];\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"104-474. 一和零.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/104-474. 一和零.md","content":"### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)\n\n#### 方法一： dp\n\n```java\nclass Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int len = strs.length;\n        int[][][] dp = new int[len + 1][m + 1][n + 1];\n        // 遍历物品\n        for(int i = 1; i <= len; i++) {   \n            // 统计01数量\n            int n0 = 0;\n            int n1 = 0;\n            for(char ch : strs[i - 1].toCharArray()) {\n                if (ch == \'0\') {\n                    n0++;\n                } else {\n                    n1++;\n                }\n            }\n\n            // 遍历二维背包\n            for(int j = 0; j <= m; j++) {       // m 个0， n个1\n                for(int k = 0; k <= n; k++) {\n                    // 方式1\n                    if(j < n0 || k < n1) {    // 容量不足，只能从前i-1个物品选  \n                        dp[i][j][k] = dp[i - 1][j][k];\n                    } else {\n                        dp[i][j][k] = Math.max(dp[i - 1][j][k], 1 + dp[i - 1][j - n0][k - n1]);\n                    }\n\n                    // 方式2\n                    // dp[i][j][k] = dp[i - 1][j][k];\n                    // if (j >= n0 && k >= n1) {\n                    //     dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - n0][k - n1] + 1);\n                    // }\n                }\n            }\n\n        }\n\n        return dp[len][m][n];\n    }\n}\n\n作者：LeetCode-Solution\n链接：https://leetcode.cn/problems/ones-and-zeroes/solution/yi-he-ling-by-leetcode-solution-u2z2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n#### 方法二：滚动数组\n\n两个维度的背包\n\n```java\nclass Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int[][] dp = new int[m + 1][n + 1];\n        for(String str : strs) {\n            // 统计01数量\n            int n0 = 0;\n            int n1 = 0;\n            for(char ch : str.toCharArray()) {\n                if (ch == \'0\') {\n                    n0++;\n                } else {\n                    n1++;\n                }\n            }\n          \n            // 01背包遍历\n            for(int i = m; i >= n0; i--) {\n                for(int j = n; j >= n1; j--) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i - n0][j - n1] + 1);\n                }\n            }\n\n            // System.out.println(\"====\" + str + \"====\");\n            // for(int[] d : dp) {\n            //     System.out.println(Arrays.toString(d));\n            // }\n            \n        }\n\n        return dp[m][n];\n    }\n}\n```\n\n\n\n```\n====10====\n[0, 0, 0, 0]\n[0, 1, 1, 1]\n[0, 1, 1, 1]\n[0, 1, 1, 1]\n\n====0001====\n[0, 0, 0, 0]\n[0, 1, 1, 1]\n[0, 1, 1, 1]\n[0, 1, 1, 1]\n\n====111001====\n[0, 0, 0, 0]\n[0, 1, 1, 1]\n[0, 1, 1, 1]\n[0, 1, 1, 1]\n\n====1====\n[0, 1, 1, 1]\n[0, 1, 2, 2]\n[0, 1, 2, 2]\n[0, 1, 2, 2]\n\n====0====\n[0, 1, 1, 1]\n[1, 2, 2, 2]\n[1, 2, 3, 3]\n[1, 2, 3, 3]\n\n```\n\n","timestamp":1694699764227},{"name":"105-完全背包.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/105-完全背包.md","content":"-   完全背包用一维好写一点\n-   完全背包的内层是正序，区分01背包的倒叙\n-   分析过程： 属于01背包 or 完全背包 => 属于组合问题 or 排列问题 => 确定排列顺序\n\n\n\n### 一维dp\n\n完全背包的物品是可以添加多次的，所以要从小到大去遍历\n\n#### 先遍历物品，后遍历背包\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] weight = {1, 3, 4};\n        int[] value = {15, 20, 30};\n        int bagWight = 4;\n        testWeightBagProblem(weight, value, bagWight);\n    }\n\n    public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight) {\n        int wLen = weight.length;\n        //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值\n        int[] dp = new int[bagWeight + 1];\n        //遍历顺序：先遍历物品，再遍历背包容量\n        for (int i = 0; i < wLen; i++){\n            for (int j = weight[i]; j <= bagWeight; j++){\n                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);\n            }\n          \n            System.out.println(\"===weight: \" + weight[i] + \"; value: \" + value[i] + \"===\");\n            for (int j = 0; j <= bagWeight; j++){\n                System.out.print(dp[j] + \" \");\n            }\n            System.out.println();\n            System.out.println();\n        }\n    }\n}\n```\n\n\n\n```\n===weight: 1; value: 15===\n0 15 30 45 60 \n\n===weight: 3; value: 20===\n0 15 30 45 60 \n\n===weight: 4; value: 30===\n0 15 30 45 60 \n```\n\n##### 问题1: **为什么遍历物品在外层循环，遍历背包容量在内层循环？**\n\n##### 问题2: 代码怎么体现选多次？\n\n正序遍历背包容量时，会重复选取，以物品0遍历背包为例，weight: 1;  value: 15\n\n```\nj=1时，dp[j]=15, 可选物品0，价值为15\nj=2时, dp[j]=30, 只有物品0可选，所以是选了两次物品0\n```\n\n\n\n\n\n#### 先遍历背包，后遍历物品\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] weight = {1, 3, 4};\n        int[] value = {15, 20, 30};\n        int bagWight = 4;\n        testWeightBagProblem(weight, value, bagWight);\n    }\n\n    public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight) {\n\n        int[] dp = new int[bagWeight + 1];\n\n        for(int i = 1; i <= bagWeight; i++) {       // 遍历背包\n            for(int j = 0; j < weight.length; j++) {    // 遍历物品\n                if(i - weight[j] >= 0) {\n                    dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);\n                }\n            }\n\n            System.out.println(\"======\");\n            for (int j = 0; j <= bagWeight; j++){\n                System.out.print(dp[j] + \" \");\n            }\n            System.out.println();\n            System.out.println();\n        }\n    }\n}\n```\n\n```\n======\n0 15 0 0 0 \n\n======\n0 15 30 0 0 \n\n======\n0 15 30 45 0 \n\n======\n0 15 30 45 60 \n```\n\n","timestamp":1694699764227},{"name":"106-518. 零钱兑换 II.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/106-518. 零钱兑换 II.md","content":"### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)\n\n求组合数\n\n```\n给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。\n输入: amount = 5, coins = [1, 2, 5]\n输出: 4\n```\n\n#### 二维dp\n\n```\namount = 5, coins = [1, 2, 5]\n这个例子不太好理解初始化，因为0的时候方案数是1，1的时候方案数也是1，不好看出是如何初始化的\n```\n\n 01背包\n\n```\ndp[i][j] = 不选coins[i] + 选coins[i]\ndp[i][j] = dp[i-1][j] + dp[i-1][j - coins[i]]\n```\n\n|      | 0    | 1    | 2    | 3    | 4    | 5    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 1    | 1    | 1    | 0    | 0    | 0    | 0    |\n| 2    | 1    | 1    | 1    | 1    | 0    | 0    |\n| 5    | 1    | 1    | 1    | 1    | 0    | 1    |\n\n完全背包\n\n```\ndp[i][j] = 选0～n个coins[i]\ndp[i][j] = dp[i-1][j] + dp[i-1][j - coins[i]] + dp[i-1][j - 2*coins[i]] + ...\n\n等价于\ndp[i][j] = dp[i-1][j] + dp[i][j - coins[i]];  // 01背包是dp[i - 1][j - coins[i]]\n```\n\n|        |      | 0    | 1    | 2    | 3    | 4    | 5    |\n| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| nums=1 | 0    | 1    | 1    | 1    | 1    | 1    | 1    |\n| nums=2 | 1    | 1    | 1    | 2    | 2    | 3    | 3    |\n| nums=5 | 2    | 1    | 1    | 2    | 2    | 3    | 4    |\n\n\n\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[][] dp = new int[coins.length][amount + 1];     \n        dp[0][0] = 1;\n\n        for(int j = coins[0]; j <= amount; j++) {\n            dp[0][j] = dp[0][j - coins[0]];\n        }\n\n        for(int i = 1; i < coins.length; i++) {\n            for(int j = 0; j <= amount; j++) {\n                if(j < coins[i]) {\n                    dp[i][j] = dp[i-1][j];\n                    continue;\n                }\n                dp[i][j] = dp[i-1][j] + dp[i][j - coins[i]]; // 注意此处为dp[i]而不是dp[i-1],含义为：选了i，再在0—i选,i还能选。01背包是dp[i - 1]\n            }\n        }\n\n        return dp[coins.length -1 ][amount];\n    }\n}\n```\n\n初始化为`dp[n + 1][amount + 1]`更好处理初始化\n\n|        |      |  0   |  1   |  2   |  3   |  4   |  5   |\n| :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|        |  0   |  1   |  0   |  0   |  0   |  0   |  0   |\n| nums=1 |  1   |  1   |  1   |  1   |  1   |  1   |  1   |\n| nums=2 |  2   |  1   |  1   |  2   |  2   |  3   |  3   |\n| nums=5 |  3   |  1   |  1   |  2   |  2   |  3   |  4   |\n\n```\ndp[i][j]: 从1～i个物品选，容量为j的组合数\n地推公式：\ndp[i][j] = dp[i - 1][j];\ndp[i][j] = dp[i][j - coins[i - 1]] + dp[i - 1][j];\n\ni = 2, amout = 4, coins[i - 1] = 2\ndp24 = dp22 + dp14\ndp22 = 不选2(即从前1个物品选，容量为2) + 选至少一个2（已经选了一个2，容量-2，再从前2个物品选容量2）\n\t\t = dp12 + dp20\n\t\t = 1 + 1 = 2\n\t\t \ndp14: (1 1 1 1)\ndp22: (2 1 1)、(2 2)\n```\n\n\n\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int n = coins.length;\n        int[][] dp = new int[n + 1][amount + 1];\n        dp[0][0] = 1;\n\n        for(int i = 1; i <= n; i++) {\n            for(int j = 0; j <= amount; j++) {\n                if(j < coins[i - 1]) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i][j - coins[i - 1]] + dp[i - 1][j];\n                }\n            }\n        }\n\n        // for(int[] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        return dp[n][amount];\n    }\n}\n```\n\n其他写法，[参考](https://leetcode.cn/problems/coin-change-ii/solution/dfsdong-tai-gui-hua-by-nefuct-4y28/)\n\n```c++\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        //1.状态表示dp[i][j]：所有只考虑前i个物品，且总体积不大于j的选法的最大值\n        vector<vector<int>> dp(coins.size() + 1, vector<int>(amount + 1, 0));\n        //2.初始化，无物品i = 0，体积为j = 0时，有一种选法\n        dp[0][0] = 1;\n        //3.遍历方向，先遍历物品，再遍历体积\n        for(int i = 1; i <= coins.size(); i++) { //遍历物品 \n            int val = coins[i - 1];\n            for(int j = 0; j <= amount; j++) { //遍历体积\n                dp[i][j] = dp[i - 1][j];\n                //4.状态计算：dp[i][j]可以由dp[i - 1][j] 选0个物品i，1个物品i，到k个物品i的选法之和，其中k * val <= j\n                for(int k = 1; k * val <= j; k++) {\n                    dp[i][j] += dp[i - 1][j - k * val];\n                }\n            }\n        }\n        return dp[coins.size()][amount];\n    }\n};\n```\n\n\n\n#### 一维dp (为主)\n\n```\namount = 5, coins = [2, 3, 5]\n```\n\n|      |  0   |  1   |  2   |  3   |  4   |  5   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  2   |  1   |  0   |  1   |  0   |  1   |  0   |\n|  3   |  1   |  0   |  1   |  1   |  1   |  1   |\n|  5   |  1   |  0   |  1   |  1   |  1   |  2   |\n\n\n```\ndp[i][j] = 选0～n个coins[i]\ndp[j] = dp[j] + dp[j - coins[i]]\n\n说明：\ndp[j] 表示一个coins[i]也不选\ndp[j - coins[i]] 先选一个coins[i]，剩余容量再取别的（这里面可能会选conins[i]）\n```\n\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];     //  dp[j]: 凑够j的组合数\n        dp[0] = 1;\n        for(int i = 0; i < coins.length; i++) {\n            for(int j = coins[i]; j <= amount; j++) {\n                dp[j] = dp[j] + dp[j - coins[i]];\n            }\n\n            // System.out.println(\"===\");\n            // System.out.println(Arrays.toString(dp));\n        }\n\n        return dp[amount];\n    }\n}\n```\n\n \n\n#### 为什么只能先物品后背包？\n\n求组合：先物品后背包\n\n```\nfor (int i = 0; i < coins.size(); i++) { // 遍历物品\n    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量\n        dp[j] += dp[j - coins[i]];\n    }\n}\n假设：coins[0] = 1，coins[1] = 5。\n\n那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。\n\n先选取物品1即1，再选物品2即5，选取的顺序已经固定了，5一定在1后选，所以不可能出现{5, 1}的情况\n```\n\n求排列：先背包，后物品\n\n```\nfor (int j = 0; j <= amount; j++) { // 遍历背包容量\n    for (int i = 0; i < coins.size(); i++) { // 遍历物品\n        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];\n    }\n}\n\n背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。\n举例：背包容量为5\n此时遍历物品，\n\ti = 0时， 先选物品1，coins[0] = 1，再从其他物品里选，可能出现{1, 5}\n\ti = 4时， 先取物品5，coins[4] = 5, 再从其他物品里选，可能出现{5, 1}\n\n```\n\n","timestamp":1694699764227},{"name":"107-377. 组合总和 Ⅳ.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/107-377. 组合总和 Ⅳ.md","content":"### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)\n\n求排列数，与零钱兑换2不同之处在于，顺序不同的序列视作不同的组合数\n\n```\n给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n\n题目数据保证答案符合 32 位整数范围。\n```\n\n\n\n```\ndp[i][j] = dp[i-1][j] + dp[i][j - nums[i]]\n```\n\n|      | 0    | 1    | 2    | 3    | 4    |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n| 1    | 1    | 1    | 1    | 1    | 1    |\n| 2    | 1    | 1    | 2    | 3    | 5    |\n| 3    | 1    | 1    | 2    | 4    | 7    |\n\n### 过程问题\n\n#### 1 如何能体现取相同的数但不同的顺序？\n\n```\ndp[2][4] = 5\n\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(2, 1, 1)\n(2, 2)\n```\n\n遍历顺序只能是：先背包，后物品\n\n\n\n#### 方法1：二维dp\n\n错解\n\n```\ndp[i][j] = dp[i-1][j] + dp[i][j - nums[i]]\n举例dp24\t\tj=4, i=2, 即在nums[1, 2]中选容量为4\ndp14 = (1111)\ndp22 = (11)、(2)\n\nj=4\n\ti=2\n    dp24 = 选0个2，再从前i-1中选容量为4  +  先选2，在从前i个选容量为j-nums[i] = 4-2 = 2\n    \t\t = dp14 + dp22\n    \t\t = ()1111 + (2)11、(2)2\t\n         = 3\n    \t\t 括号代表先选的，就会导致dp22楼掉121、112两种情况，即2只能在开头\n\n[1, 0, 0, 0, 0]\n[1, 1, 1, 1, 1]\n[1, 1, 2, 2, 3]\n[1, 1, 2, 3, 4]\n\n牵扯到排列问题，不能直接使用化简后的式子dp[i][j] = dp[i - 1][j] + dp[i][j - nums[i]]，而应该在选取到每个i时，都把从0-i的组合都累加一遍，即递推公式为 sum(dp[i][j - nums[k]])（k属于0到i）\nhttps://leetcode.cn/problems/combination-sum-iv/solution/377-zu-he-zong-he-ivyi-wei-gun-dong-shu-uoaf8/\n```\n\n```java\n    public int combinationSum4(int[] nums, int target) {\n        int n = nums.length;\n        int[][] dp = new int[n + 1][target + 1];\n        dp[0][0] = 1;\n\n        for(int j = 0; j <= target; j++) {\n            // System.out.println(\"===\");\n            for(int i = 1; i <= n; i++) {\n                if(j < nums[i - 1]) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - nums[i - 1]];\n                }\n                // System.out.println(\"dp[\" + i + \", \" + j + \"]: \" + dp[i][j]);\n            }\n\n            // System.out.println(Arrays.toString(dp[j]));\n        }\n        \n        for(int[] d : dp) {\n            System.out.println(Arrays.toString(d));\n        }\n        return dp[n][target];\n    }\n```\n\n正解\n\n|       |      | 0    | 1    | 2    | 3    | 4    |\n| ----- | ---- | ---- | ---- | ---- | ---- | ---- |\n|       | 0    | 1    | 0    | 0    | 0    | 0    |\n| num=1 | 1    | 1    | 1    | 1    | 1    | 1    |\n| num=2 | 2    | 1    | 1    | 2    | 3    | 5    |\n| num=3 | 3    | 1    | 1    | 2    | 4    | 7    |\n\n```\ndp[i][j]表示在前i件物品中选中，填满j\n\ndp22表示在前两件物品（nums=[1， 2]）中选中，填满容量2\ndp22 = 11、2\ndp23 = 111、12、21\n\nj=4:\n\ti=2: \n\t\tdp24 = 先取物品1(num=1)再取其他 + 先取物品2(num=2)再取其他\n\t\t\t\t\t\t\t = dp[2][4 - 1]\t + dp[2][4 - 2]\n\t\t\t\t\t\t\t = dp23 + dp22\n\t\t\t\t\t\t\t = 3 + 2 = 5\n    即dp24 = (1)111、(1)12、(1)21  + (2)11、(2)2\n```\n\n```java\nclass Solution {\n    public int combinationSum4(int[] nums, int target) {\n        int n = nums.length;\n        int[][] dp = new int[n + 1][target + 1];\n        for(int i = 0; i <= n; i++) dp[i][0] = 1;\n\n        for(int j = 0; j <= target; j++) {\n            for(int i = 1; i <= n; i++) {\n                for(int k = 1; k <= i; k++) {\n                    if(j - nums[k - 1] >= 0) dp[i][j] += dp[i][j - nums[k - 1]];\n                }\n                // System.out.println(\"dp[\" + i + \", \" + j + \"]: \" + dp[i][j]);\n            }\n\n            // System.out.println(Arrays.toString(dp[j]));\n        }\n        \n        // for(int[] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n        return dp[n][target];\n    }\n}\n```\n\n\n\n#### 方法2: 一维dp\n\ndp定义\n\n```\ndp[j]: 凑成目标正整数为i的排列个数为dp[j]\n```\n\ndp数组如何初始化\n\n```\n因为递推公式dp[i] += dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。\n\n至于dp[0] = 1 有没有意义呢？\n\n其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！ 所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式。\n\n至于非0下标的dp[i]应该初始为多少呢？\n\n初始化为0，这样才不会影响dp[i]累加所有的dp[i - nums[j]]。\n```\n\n\n\n```java\nclass Solution {\n    public int combinationSum4(int[] nums, int target) {\n        int[] dp = new int[target + 1];\n        dp[0] = 1;\n        for(int j = 0; j <= target; j++) {\n            for(int i = 0; i < nums.length; i++) {\n                if(j - nums[i] >= 0) {\n                    dp[j] = dp[j] + dp[j - nums[i]];\t\t// 解释1\n                }\n            }\n\n            System.out.println(\"===weight: \" + i + \"===\");\n            System.out.println(Arrays.toString(dp));\n        }\n\n        return dp[target];\n    }\n}\n```\n\n```\nnums = [1, 2, 3], weight = 4\n```\n\n解释1\n\n```\nj = 4\n\ti = 3\n\t\t此时的dp[j]=dp[4]是上一轮i=2的处理结果，表示从物品1、2中选容量为4\n\t\tdp[j] = dp[j] + dp[j - nums[i]]; \n\t\t表示新一轮的dp[j] = 不选物品3 + 先选物品3再选其他\n\t\t\t\t\t\t\t\t\t\t= 也就是从前2个物品选容量4的情况（即上一轮的dp[j]） + 先选物品3再选其他\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n```\n\n\n\nWeight = 0 \n\n```\ndp = [1, 0, 0, 0, 0]\n```\n\nweight = 1\n\n```\ndp = [1, 1, 0, 0, 0]\n取物品0，重量 = 1，当前方案：{1}, 剩余重量1 - 1 = 0，剩余重量方案数dp[0] = 1, 最终方案：{1}\ndp[1] = dp[0] = 1\n```\n\nWeight = 2\n\n```\ndp = [1, 1, 2, 0, 0]\n取物品0, 重量 = 1，当前方案：{1}，剩余重量2 - 1 = 1，剩余重量方案数dp[1] = 1, 最终方案：{1, 1}\n取物品1, 重量 = 2，当前方案：{2}，剩余重量2 - 2 = 0，剩余重量方案数dp[0] = 1, 最终方案：{2}\ndp[2] = dp[1] + dp[0] = 1 + 1 = 2\n```\n\nweight = 3\n\n```\ndp = [1, 1, 2, 4, 0]\nfor 物品\n  取物品0, 重量 = 1, 当前方案：{1},  剩余重量3 - 1 = 2，剩余重量方案数dp[2] = 2, 最终方案：{1, 1, 1}, {1, 2}\n  取物品1, 重量 = 2, 当前方案：{2},  剩余重量3 - 2 = 1，剩余重量方案数dp[1] = 1, 最终方案：{2, 1}\n  取物品2, 重量 = 3, 当前方案：{3},  剩余重量3 - 3 = 0，剩余重量方案数dp[0] = 1, 最终方案：{3}\n  \n  dp[3] = 上面三种情况相加 = dp[2] + dp[1] + dp[0] = 4\n```\n\nWeight = 4\n\n```\ndp = [1, 1, 2, 4, 7]\ndp[4] = dp[3] + dp[2] + dp[1] = 7\n```\n\n","timestamp":1694699764227},{"name":"108-爬楼梯进阶版.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/108-爬楼梯进阶版.md","content":"```\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n一次可以一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？\n```\n\n如果我来面试的话，我就会先给候选人出一个 本题原题，看其表现，如果顺利写出来，进而在要求每次可以爬[1 - m]个台阶应该怎么写。\n\n顺便再考察一下两个for循环的嵌套顺序，为什么target放外面，nums放里面。\n\n\n\n分析过程：属于完全背包 => 排列问题 => 完全同377. 组合问题403\n\n```\nn=4, m=3\n\n[1, 0, 0, 0, 0]\n[1, 1, 0, 0, 0]\n[1, 1, 2, 0, 0]\n[1, 1, 2, 4, 0]\n[1, 1, 2, 4, 7]\n```\n\n一维\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        int[] dp = new int[n + 1];\n        int[] weight = {1,2,3};\n        dp[0] = 1;\n\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < weight.length; j++) {\n                if (i >= weight[j]) dp[i] += dp[i - weight[j]];\n            }\n            System.out.println(Arrays.toString(dp));\n        }\n\n        return dp[n];\n    }\n}\n```\n\n二维\n\n```java\nclass Solution {\n    public int climbStairs(int target) {\n        int[] weight = {1, 2, 3};\n        int[][] dp = new int[weight.length + 1][target + 1];\n        for(int i = 0; i <= weight.length; i++) dp[i][0] = 1;\n\n        for(int j = 0; j <= target; j++) {\n            for(int i = 1; i <= weight.length; i++) {\n                for(int k = 1; k <= i; k++) {\n                    if(j - weight[k - 1] >= 0) dp[i][j] += dp[i][j - weight[k - 1]];\n                }\n            }\n        }\n\n        for(int[] d : dp) {\n            System.out.println(Arrays.toString(d));\n        }\n\n\n        return dp[weight.length][target];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"109-322. 零钱兑换.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/109-322. 零钱兑换.md","content":"### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)\n\n求最少硬币数\n\n```\n给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n你可以认为每种硬币的数量是无限的。\n\n输入：coins = [1, 2, 5], amount = 11\n输出：3 \n解释：11 = 5 + 5 + 1\n```\n\n\n\n```\ncoins = [1, 2, 5], amount = 5\n```\n\n```\ndp[j] = min {\n\tdp[j],\n\t1 + dp[j - coins[i]]\n}\n```\n\n\n\n|      | 0    | 1    | 2    | 3    | 4    | 5    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 1    | 1    | 1    | 2    | 3    | 4    | 5    |\n| 2    | 1    | 1    | 1    | 2    | 2    | 3    |\n| 5    | 1    | 1    | 1    | 2    | 2    | 1    |\n\n\n\n### 题解\n\n#### 一维dp\n\n```\ndp[j] = Math.min(dp[j], 1 + dp[j - coins[i]]); \n```\n\n##### 先背包，后物品\n\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 0;\n        for(int j = 1; j <= amount; j++) {\n            dp[j] = Integer.MAX_VALUE;\n        }\n\n        for(int j = 0; j <= amount; j++) {\n            for(int i = 0; i < coins.length; i++) {\n                if(j - coins[i] >= 0 && dp[j - coins[i]] != Integer.MAX_VALUE) {  // dp[j - coins[i]为Integer.MAX_VALUE， 加1后会越界变成负数\n                    dp[j] = Math.min(dp[j], 1 + dp[j - coins[i]]);  \n                }\n            }\n\n            // System.out.println(\"======\");\n            // System.out.println(Arrays.toString(dp));\n        }\n\n        if(dp[amount] == Integer.MAX_VALUE) return -1;\n        return dp[amount];\n    }\n}\n```\n\n##### 先物品，后背包\n\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 0;\n        for(int j = 1; j <= amount; j++) {\n            dp[j] = Integer.MAX_VALUE;\n        }\n        for(int i = 0; i < coins.length; i++) {\n            for(int j = coins[i]; j <= amount; j++) {\n                if(dp[j - coins[i]] != Integer.MAX_VALUE) { \n                    dp[j] = Math.min(dp[j], 1 + dp[j - coins[i]]);  \n                }\n            }\n\n            // System.out.println(\"======\");\n            // System.out.println(Arrays.toString(dp));\n        }\n\n        if(dp[amount] == Integer.MAX_VALUE) return -1;\n        return dp[amount];\n    }\n}\n```\n\n\n\n#### 过程问题\n\n #### 1. 如何初始化较好，dp[0] = 0 or 1，剩余初始化0 还是 -1\n\n首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;\n\n考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。\n\n所以下标非0的元素都是应该是最大值。\n\n#### 2. 处理返回0 和 -1 的问题\n\n ```\n [1]\n 0\n 输出-1， 预期0\n ```\n以下为错解，不会处理0 和 -1 的情况，归根到底，是dp初始化的问题\n\n考虑，题解为什么不需要考虑折麽多if条件\n\n~~~java\n\n\n ```java\n class Solution {\n     public int coinChange(int[] coins, int amount) {\n         int[] dp = new int[amount + 1];\n         dp[0] = 0;\n \n         for(int j = 0; j <= amount; j++) {\n             for(int i = 0; i < coins.length; i++) {\n                 if(j - coins[i] >= 0) {\n                     if(j - coins[i] > 0 && dp[j - coins[0]] == 0) { // 当前硬币不能直接满足j，且j-coins[0]没有方案\n                         continue;\n                     }\n                     if(dp[j] == 0) {\n                         dp[j] = 1 + dp[j - coins[i]];\n                         continue;\n                     }\n                     dp[j] = Math.min(dp[j], 1 + dp[j - coins[i]]);                    \n                 }\n             }\n \n             System.out.println(\"======\");\n             System.out.println(Arrays.toString(dp));\n         }\n \n         return dp[amount] == 0 ? -1 : dp[amount];\n     }\n }\n ```\n~~~\n\n#### 3 考虑遍历顺序\n\n两种方式都可以，区别于零钱兑换2和组合总和4\n","timestamp":1694699764227},{"name":"110-279. 完全平方数.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/110-279. 完全平方数.md","content":"### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)\n\n```\n给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。\n\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n\n输入：n = 12\n输出：3 \n解释：12 = 4 + 4 + 4\n```\n\n\n\n### 分析过程\n\n后一个状态可用前一个状态推出，属于dp问题\n\n数可以任意取，属于完全背包问题\n\n取数时与顺序无关，所以遍历顺序任意\n\n\n\n### 题解\n\n#### 一维dp\n\n定义\n\n```\ndp[j]: 和为j的完全平方数的最少数量 \n```\n\n公式\n\n```\ndp[j] = min {\n\tdp[j],\n\t1 + dp[j - i*i]\n}\n```\n\n初始化\n\n```\ndp[0] = 0;\n其余为Integer.MAX_VALUE，因为取最小值，避免被初始值覆盖\n```\n\n遍历顺序\n\n```\n次题求的是凑成j的平方数的数量，与取得平方数的顺序无关\n不是求组合数、排列数\n所以任意遍历顺序都可以\n```\n\n距离推导dp数组\n\n|      | 0    | 1    | 2    | 3    | 4    | 5    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 1    | 0    | 1    | 2    | 3    | 4    | 5    |\n| 2    | 0    | 1    | 2    | 3    | 1    | 2    |\n| 3    |      |      |      |      |      |      |\n| 4    |      |      |      |      |      |      |\n| 5    |      |      |      |      |      |      |\n\n##### 先遍历物品，后遍历背包\n\n```java\nclass Solution {\n    public int numSquares(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        for(int j = 1; j <= n; j++) dp[j] = Integer.MAX_VALUE;\n\n        for(int i = 1; i * i <= n; i++) {\n            for(int j = i*i; j <= n; j++ ) {\n                if(dp[j - i*i] != Integer.MAX_VALUE) {\n                    dp[j] = Math.min(dp[j], 1 + dp[j - i*i]);\n                }\n            }\n\n            // System.out.println(\"======\");\n            // System.out.println(Arrays.toString(dp));\n        }\n\n        return dp[n];\n    }\n}\n```\n\n##### 先遍历背包，后遍历物品\n\n```java\nclass Solution {\n    public int numSquares(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        for(int j = 1; j <= n; j++) dp[j] = Integer.MAX_VALUE;\n\n        for(int j = 1; j <= n; j++) { // 遍历背包\n            for(int i = 1; i*i <= j; i++) { // 遍历物品\n                dp[j] = Math.min(dp[j], 1 + dp[j - i*i]);\n            }\n        }\n\n        return dp[n];\n    }\n}\n```","timestamp":1694699764227},{"name":"111-139. 单词拆分.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/111-139. 单词拆分.md","content":"### [139. 单词拆分](https://leetcode.cn/problems/word-break/)\n\n```\n给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。\n注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\n```\n\n\n\n#### 问题\n\n##### Q1: 如何归到背包问题，何为背包，何为物品？\n\n\n\n\n\n### 题解\n\n#### 方法一：回溯法\n\n##### 方式1 - 切割字符串，去匹配wordDict是否存在\n\n类似[回溯算法：分割回文串 (opens new window)](https://programmercarl.com/0131.分割回文串.html)：是枚举分割后的所有子串，判断是否回文。\n\n本道是枚举分割所有字符串，判断是否在字典里出现过。\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/17/13400716817100071681710007548GTKJCu-image-20230417134007306.png\" alt=\"image-20230417134007306\" style=\"zoom: 33%;\" />\n\n```java\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        return trackback(s, wordDict, 0);\n    }\n\n    public boolean trackback(String s, List<String> wordDict, int startIndex) {\n        if(startIndex >= s.length()) {\n            return true;\n        }\n\n        for(int i = startIndex; i < s.length(); i++) {\n            String word = s.substring(startIndex, i + 1);\n            if(wordDict.contains(word) && trackback(s, wordDict, i + 1)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n```\n\n以上代码会超时\n\n```\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\n```\n\n**解决办法：**\n\n使用memory数组保存每次计算的以startIndex起始的计算结果，如果memory[startIndex]里已经被赋值了，直接用memory[startIndex]的结果。\n\n<img src=\"/Users/kuan/Library/Application%20Support/typora-user-images/image-20230418131847164.png\" alt=\"image-20230418131847164\" style=\"zoom:33%;\" />\n\n```java\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        int[] memory = new int[s.length()];\n        System.out.println(Arrays.toString(memory));\n        return trackback(s, wordDict, memory, 0);\n    }\n\n    public boolean trackback(String s, List<String> wordDict, int[] memory, int startIndex) {\n        if(startIndex >= s.length()) {\n            return true;\n        }\n\n        // 如果memory[startIndex]不是初始值了，直接使用memory[startIndex]的结果\n        if(memory[startIndex] == -1) return false;\n        for(int i = startIndex; i < s.length(); i++) {\n            String word = s.substring(startIndex, i + 1);\n            if(wordDict.contains(word) && trackback(s, wordDict, memory, i + 1)) {\n                return true;\n            }\n        }\n\n        memory[startIndex] = -1;  // // 记录以startIndex开始的子串是不可以被拆分的\n        return false;\n    }\n}\n```\n\n\n\n##### 方式2 -用wordDict去匹配字符串的前缀\n\nwordDict中的每一个元素就是一条路径\n\n会超时，方式1是方式2的优化，通过穷举 `s[i..]` 的前缀去判断 `wordDict` 中是否有对应的单词\n\nhttps://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-f0a05/\n\n[<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/18/12385216817927321681792732146uaJzqX-2.jpeg\" alt=\"img\" style=\"zoom:33%;\" />](https://labuladong.github.io/algo/images/单词拆分/2.jpeg)\n\n```java\nclass Solution {\n    boolean found = false;\n    LinkedList<String> path = new LinkedList<>();\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        backtrack(s, wordDict, 0);\n        return found;\n    }\n\n    public void backtrack(String s, List<String> wordDict, Integer i) {\n        if(found) return;\n        if (i == s.length()) {\n            // 整个 s 都被匹配完成，找到一个合法答案\n            found = true;\n            return;\n        }\n\n        for(String word : wordDict) {\n          \t// 看看哪个单词能够匹配 s[i..] 的前缀\n            int len = word.length();\n            if(i + len <= s.length() && s.substring(i, i + len).equals(word)) {\n              \t// 找到一个单词匹配 s[i..i+len)\n                // 做选择\n                path.addLast(word);\n               // 进入回溯树的下一层，继续匹配 s[i+len..]\n                backtrack(s, wordDict, i + len);\n              \t// 撤销选择\n                path.removeLast();\n            }\n        }\n\n    }\n}\n```\n\n\n\n#### 方法二：一维dp\n\n##### 例题\n\n```\n如s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n```\n\n##### 定义\n\n```\ndp[i]: dp[i] = true，表示字符串长度为i，则该字符串可以分割为1个或多个字典中出现的字符串\n\n如\ndp4 表示字符串长度为4，即leet，该字符串可以分割为字段中出现的字符串，即字典中的leet\ndp8 表示字符串长度为8，即leetcode，该字符串可以分割为字段中出现的字符串，即字典中的leet、code\n```\n\n##### 递推公式\n\n```\nif(substring[j, i]在字典中 && dp[j] = true) dp[i] = true;\n\n如\ndp8要为true，那么要满足 {\n\t\tsubstring[j, i]在字典中, 即substring[4, 8]=code在字典中，\n\t\t前半部分字串[0, j]也要由字典中的字符串组成，即dp[j] = dp[4] = true\n}\n```\n\n##### 遍历顺序\n\n```\n题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包\n本题最终要求的是拆分的子串是否都在字典中出现过，并不要求组合 or 排列，所以任意遍历顺序都行\n```\n\n##### 代码 - 先背包后物品\n\n遍历物品跟常规的遍历物品有所区别，还不知怎么理解好，（写法二是真正意义上的便利物品）\n\n```java\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        HashSet<String> set = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n\n        for(int i = 1; i <= s.length(); i++) { // 遍历背包\n            for(int j = 0; j < i; j++) {    // 变相遍历物品，遍历深度到达当前背包容量即可\n                String str = s.substring(j, i);\n                if(set.contains(str) && dp[j] == true) {\n                    dp[i] = true;\n                  \tbreak;\n                }\n            }\n        }\n\n        return dp[s.length()];\n    }\n}\n```\n\n遍历过程\n\n```\n===i: 1===\n[true]\n===i: 2===\n[true, false]\n===i: 3===\n[true, false, false]\n===i: 4===\n[true, false, false, false]\n===i: 5===\n[true, false, false, false, true]\n===i: 6===\n[true, false, false, false, true, false]\n===i: 7===\n[true, false, false, false, true, false, false]\n===i: 8===\n[true, false, false, false, true, false, false, false]\n```\n\n```\ni=1\n  j=0, str = \"l\", 字典无\n\ni=2\n  j=0，sub(0, 2) = \"le\", 字典无\n  j=1，sub(1, 2) = \"l\",  字典无\n\n...\n\ni = 4\n  j=0, sub(0, 4) = \"leet\", 字典有 && dp[j] = dp[0] = true, 所以dp[i] = dp[4] = true\n  j=1, sub(1, 4) = \"eet\",  字典无\n  j=2, sub(2, 4) = \"et\",   字典无\n  j=3, sub(3, 4) = \"t\",    字典无\n\n...\n\ni=8\n  j=0, sub(0, 8) = \"leetcode\",  字典无\n  j=1, sub(1, 8) = \"eetcode\",   字典无\n  ...\n  j=4, sub(4, 8) = \"code\", 字典有 && dp[j] = dp[4] = true, 所以dp[i] = dp[8] = true\n  ...\n```\n\n写法二：真正意义上的遍历物品（主要写法）\n\n```java\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n\n        for (int i = 1; i <= s.length(); i++) {\n            for (String word : wordDict) {\n                int len = word.length();\n                if (i >= len && dp[i - len] && word.equals(s.substring(i - len, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        return dp[s.length()];\n    }\n}\n```\n\n\n\n\n\n#####  代码 - 先遍历物品，后遍历背包\n\n并非真正意义上的遍历物品\n\n```java\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        HashSet<String> set = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n\n        for(int i = 0; i <= s.length(); i++) {  // 遍历物品\n            for(int j = 1; j <= s.length(); j++) {  // 遍历背包\n                if(j <= i) {\n                    continue;\n                }\n                String str = s.substring(i, j);\n                if(set.contains(str) && dp[i]) {\n                    dp[j] = true;\n                }\n            }\n        }\n\n        return dp[s.length()];\n    }\n}\n```\n\n\n\n```\n======\n[true, false, false, true, true, false, false, false, false, false]\n======\n[true, false, false, true, true, false, false, false, false, false]\n======\n[true, false, false, true, true, false, false, false, false, false]\n======\n[true, false, false, true, true, false, false, true, false, false]\n======\n[true, false, false, true, true, false, false, true, false, false]\n======\n[true, false, false, true, true, false, false, true, false, false]\n======\n[true, false, false, true, true, false, false, true, false, false]\n======\n[true, false, false, true, true, false, false, true, false, false]\n======\n[true, false, false, true, true, false, false, true, false, false]\n======\n[true, false, false, true, true, false, false, true, false, false]\n\n```\n\n","timestamp":1694699764227},{"name":"112-多重背包.md","path":"002-数据结构与算法/010-动态规划/04-背包问题/112-多重背包.md","content":"## 多重背包\n\n-   不同的物品数量不同\n-   可以转为01背包来求解\n\n### 方法一：\n\n![image-20221213194558790](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/12/13/19455816709319581670931958897GjKXNX-image-20221213194558790.png)\n\n![image-20221213194543915](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/12/13/19454416709319441670931944023AzMTvY-image-20221213194543915.png)\n\n```java\n    public static void multiPackage() {\n        List<Integer> weight = new ArrayList<>(Arrays.asList(1, 3, 4));\n        List<Integer> value = new ArrayList<>(Arrays.asList(15, 20, 30));\n        List<Integer> nums = new ArrayList<>(Arrays.asList(2, 3, 2));\n        int bagWeight = 10;\n\n      \t// 改造为01背包\n        for(int i = 0; i < nums.size(); i++) {\n            while(nums.get(i) > 1) {\n                weight.add(weight.get(i));\n                value.add(value.get(i));\n                nums.set(i, nums.get(i) - 1);\n            }\n        }\n\n        // 01背包\n        int[] dp = new int[bagWeight + 1];\n        for(int i = 0; i < weight.size(); i++) {  // 遍历物品\n            for(int j = bagWeight; j >= weight.get(i); j--) {   // 遍历背包\n                dp[j] = Math.max(dp[j], value.get(i) + dp[j - weight.get(i)]);\n            }\n            System.out.println(Arrays.toString(dp));\n        }\n    }\n```\n\n\n\n### 方法二：\n\n```java\n    public static void multiPackage() {\n        int[] weight = new int[] { 1, 3, 4 };\n        int[] value = new int[] { 15, 20, 30 };\n        int[] nums = new int[] { 2, 3, 2 };\n        int bagWeight = 10;\n\n        int[] dp = new int[bagWeight + 1];\n        for (int i = 0; i < weight.length; i++) { // 遍历物品\n            for (int j = bagWeight; j >= weight[i]; j--) { // 遍历背包\n                // 遍历相同物品个数\n                for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) {\n                    dp[j] = Math.max(dp[j], value[i] * k + dp[j - k * weight[i]]);\n                }\n\n                System.out.println(Arrays.toString(dp));\n            }\n        }\n    }\n```\n\n","timestamp":1694699764227},{"name":"01-198. 打家劫舍.md","path":"002-数据结构与算法/010-动态规划/05-打家劫舍问题/01-198. 打家劫舍.md","content":"### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)\n\ndp含义\n\n```\ndp[i]：前i家最多可以偷窃的金额。\n```\n\n地推公式\n\n```\ndp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n```\n\n\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length < 1) {\n            return 0;\n        }\n        int[] dp = new int[nums.length + 1];    // 偷前i家最大值\n        dp[1] = nums[0];\n        for(int i = 2; i <= nums.length; i++) {\n            dp[i] = Math.max(dp[i - 1], dp[i-2] + nums[i - 1]);\n        }\n        // System.out.println(Arrays.toString(dp));\n\n        return dp[nums.length];\n    }\n}\n```\n\n调整使得for中的i指向的就是第i家，便于理解\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0) return 0;\n        if(nums.length == 1) return nums[0];\n\n        int[] dp = new int[nums.length];    // 偷前i家最大值\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n        for(int i = 2; i < nums.length; i++) {\n            dp[i] = Math.max(dp[i - 1], dp[i-2] + nums[i]);\n        }\n        // System.out.println(Arrays.toString(dp));\n\n        return dp[nums.length - 1];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-213. 打家劫舍 II.md","path":"002-数据结构与算法/010-动态规划/05-打家劫舍问题/02-213. 打家劫舍 II.md","content":"### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)\n\n![image-20221214104316167](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/12/14/104316167098579616709857963457ozNOA-image-20221214104316167.png)\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0) return 0;\n        if(nums.length == 1) return nums[0];\n\n        int res1 = robRange(Arrays.copyOfRange(nums, 0, nums.length - 1));\n        int res2 = robRange(Arrays.copyOfRange(nums, 1, nums.length));\n        return Math.max(res1, res2);\n    }\n\n    public int robRange(int[] nums) {\n        if(nums.length == 1) return nums[0];\n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n        for(int i = 2; i < nums.length; i++) {\n            dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]);\n        }\n        return dp[nums.length - 1];\n    }\n}\n```\n\n数组原地修改\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if(n == 0) return 0;\n        if(n == 1) return nums[0];\n        int rob1 = robRange(nums, 0, n - 2);\n        int rob2 = robRange(nums, 1, n - 1);\n        return Math.max(rob1, rob2);\n    }\n\n    public int robRange(int[] nums, int l, int r) {     // []\n        if(l == r) return nums[l];\n        int[] dp = new int[nums.length];\n        dp[l] = nums[l];\n        dp[l + 1] = Math.max(nums[l], nums[l + 1]);\n        \n        for(int i = l + 2; i < nums.length; i++) {\n            dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]);\n        }\n\n        return dp[r];\n\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"03-337. 打家劫舍 III.md","path":"002-数据结构与算法/010-动态规划/05-打家劫舍问题/03-337. 打家劫舍 III.md","content":"### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)\n\n#### 暴力搜索\n\n会超时\n\n```java\nclass Solution {\n    public int rob(TreeNode root) {\n        if(root == null) return 0;\n        if(root.left == null && root.right == null) return root.val;\n        \n        // 偷父节点\n        int v1 = root.val;\n        if(root.left != null) v1 += rob(root.left.left) + rob(root.left.right);\n        if(root.right != null) v1 += rob(root.right.left) + rob(root.right.right);\n        \n        // 不偷父节点\n        int v2 = rob(root.left) + rob(root.right);\n\n        return Math.max(v1, v2);\n    }\n}\n```\n\n优化：记忆化搜索\n\n```java\nclass Solution {\n    Map<TreeNode, Integer> map = new HashMap<>();\n\n    public int rob(TreeNode root) {\n        if(root == null) return 0;\n        if(root.left == null && root.right == null) return root.val;\n        if(map.containsKey(root)) return map.get(root);\n        // 偷父节点\n        int v1 = root.val;\n        if(root.left != null) v1 += rob(root.left.left) + rob(root.left.right);\n        if(root.right != null) v1 += rob(root.right.left) + rob(root.right.right);\n        \n        // 不偷父节点\n        int v2 = rob(root.left) + rob(root.right);\n        map.put(root, Math.max(v1, v2));\n\n        return Math.max(v1, v2);\n    }\n}\n```\n\n#### 动态规划\n\n```java\nclass Solution {\n\n    public int rob(TreeNode root) {\n        if(root == null) return 0;\n        if(root.left == null && root.right == null) return root.val;\n\n        int[] res = dfs(root);\n        return Math.max(res[0], res[1]);\n    }\n\n    // res[0] 不偷  res[1]偷\n    public int[] dfs(TreeNode root) {\n        if(root == null) return new int[]{0, 0};\n\n        int[] l = dfs(root.left);\n        int[] r = dfs(root.right);\n\n        // 偷父节点\n        int v1 = root.val + l[0] + r[0];\n        \n        // 不偷父节点，可以偷/不偷左右节点\n        int v2 = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);\n\n        return new int[]{v2, v1};\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-62. 不同路径.md","path":"002-数据结构与算法/010-动态规划/06-不同路径/01-62. 不同路径.md","content":"### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)\n\n```\ndp[i][j] = dp[i][j-1] + dp[i-1][j];\n```\n\n![image-20221106154759950](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/11/06/15480016677208801667720880072no4wch-image-20221106154759950.png)\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m + 1][n + 1];\t\t// 到第i行j列第路径数\n        dp[1][1] = 0;\n        for(int i = 1; i <=m; i++) {\n            for(int j = 1; j <= n; j++) {\n                if(i == 1) {\n                    dp[1][j] = 1;\n                    continue;\n                }\n                if(j == 1) {\n                    dp[i][1] = 1;\n                    continue;\n                }\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\n            }\n        }\n\n        return dp[m][n];\n    }\n}\n```\n\n调整：先初始化，后遍历\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m + 1][n + 1];\n        for(int i = 1; i <= m; i++) dp[i][1] = 1;\n        for(int j = 1; j <= n; j++) dp[1][j] = 1;\n\n        for(int i = 2; i <=m; i++) {\n            for(int j = 2; j <= n; j++) {\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\n            }\n        }\n\n        return dp[m][n];\n    }\n}\n```\n\n优化：使用一维数组\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[] dp = new int[n + 1];\n        for(int j = 1; j <= n; j++) dp[j] = 1;\n        for(int i = 2; i <= m; i++) {\n            for(int j = 2; j <= n; j++) {\n                dp[j] = dp[j-1] + dp[j];\n            }\n        }\n\n        return dp[n];\n    }\n}\n```\n\n写法2\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, 1);\n        dp[0] = 0;\t// 易错点\n        for(int i = 1; i < m; i++) {\n            for(int j = 1; j <= n; j++) {\t\t// 正序，下一层要用计算后的dp[j-1]\n                dp[j] += dp[j - 1];\n            }\n            // System.out.println(Arrays.toString(dp));\n        }\n\n        return dp[n];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-63. 不同路径 II.md","path":"002-数据结构与算法/010-动态规划/06-不同路径/02-63. 不同路径 II.md","content":"### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)\n\n问题1: 初始化时需要考虑路径上有障碍物，那么后面的路都达不到\n\n```\n[[1,0]]\n```\n\n\n\n```\ndp[i][j]表示从(0,0)出发，到达(i,j)的路径数\n```\n\n\n\n```java\nclass Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int rows = obstacleGrid.length;\n        int cols = obstacleGrid[0].length;\n        int[][] dp = new int[rows][cols];\n\n        // 初始化\n        for(int i = 0; i < rows; i++) {\n            if(obstacleGrid[i][0] == 1) {\n                dp[i][0] = 0;\n            } else {\n                if(i > 0 && dp[i-1][0] == 0) { // 路径上有障碍物，右边都达不到\n                    dp[i][0] = 0;\n                } else {\n                    dp[i][0] = 1;\n                }\n            }\n        }\n        for(int j = 0; j < cols; j++) {\n            if(obstacleGrid[0][j] == 1) {\n                dp[0][j] = 0;\n            } else {\t// 路径上有障碍物，下边都达不到\n                dp[0][j] = (j > 0 && dp[0][j - 1] == 0) ? 0 : 1;\n            }\n        }\n\n        // 遍历\n        for(int i = 1; i < rows; i++) {\n            for(int j = 1; j < cols; j++) {\n                if(obstacleGrid[i][j] == 1) {\n                    dp[i][j] = 0;\n                } else {\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\n                }\n            }\n        }\n\n        // for(int[] row : dp) {\n        //     for(int item : row) {\n        //         System.out.print(item + \" \");\n        //     }\n        //     System.out.println();\n        // }\n\n        return dp[rows-1][cols-1];\n    }\n}\n```\n\n优化初始化过程\n\n```java\nclass Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int rows = obstacleGrid.length;\n        if(rows == 0 || obstacleGrid[0][0] == 1) return 0;\n        int cols = obstacleGrid[0].length;\n        int[][] dp = new int[rows][cols];\n        dp[0][0] = 1;\n        for(int j = 1; j < cols; j++) dp[0][j] = obstacleGrid[0][j] == 1 ? 0 : dp[0][j - 1];\n        for(int i = 1; i < rows; i++) dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i - 1][0];\n\n        for(int i = 1; i < rows; i++) {\n            for(int j = 1; j < cols; j++) {\n                if(obstacleGrid[i][j] == 1) dp[i][j] = 0;\n                else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n\n            System.out.println(Arrays.toString(dp[i]));\n        }\n\n        return dp[rows - 1][cols - 1];\n    }\n}\n```\n\n优化：初始化时，遇到障碍物，则停止遍历\n\n```java\nclass Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int rows = obstacleGrid.length;\n        int cols = obstacleGrid[0].length;\n        \n        //如果在起点或终点出现了障碍，直接返回0\n        if (obstacleGrid[rows - 1][cols - 1] == 1 || obstacleGrid[0][0] == 1) return 0;\n\n        int[][] dp = new int[rows][cols];\n        // 初始化\n        for(int i = 0; i < rows && obstacleGrid[i][0] == 0; i++) { // 有障碍物停止遍历\n            dp[i][0] = 1;\n        }\n        for(int j = 0; j < cols && obstacleGrid[0][j] == 0; j++) {\n            dp[0][j] = 1;\n        }\n\n        // 遍历\n        for(int i = 1; i < rows; i++) {\n            for(int j = 1; j < cols; j++) {\n                if(obstacleGrid[i][j] == 1) {\n                    dp[i][j] = 0;\n                } else {\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\n                }\n            }\n        }\n\n        // for(int[] row : dp) {\n        //     for(int item : row) {\n        //         System.out.print(item + \" \");\n        //     }\n        //     System.out.println();\n        // }\n\n        return dp[rows-1][cols-1];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"03-64. 最小路径和.md","path":"002-数据结构与算法/010-动态规划/06-不同路径/03-64. 最小路径和.md","content":"### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)\n\n```\n给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明：每次只能向下或者向右移动一步。\n\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n```\n\n\n\n\n\n```java\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        int rows = grid.length;\n        if(rows == 0) return 0;\n        int cols = grid[0].length;\n        int[][] dp = new int[rows + 1][cols + 1];\n        for(int col = 1; col <= cols; col++) dp[1][col] = grid[0][col-1] + dp[1][col-1];\n        for(int row = 1; row <= rows; row++) dp[row][1] = grid[row-1][0] + dp[row-1][1];\n\n        // System.out.println(Arrays.toString(dp[1]));\n\n        for(int i = 2; i <= rows; i++) {\n            for(int j = 2; j <= cols; j++) {\n                dp[i][j] = grid[i-1][j-1] + Math.min(dp[i-1][j], dp[i][j-1]);\n            }\n\n            // System.out.println(Arrays.toString(dp[i]));\n        }\n\n        return dp[rows][cols];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"04-931. 下降路径最小和.md","path":"002-数据结构与算法/010-动态规划/06-不同路径/04-931. 下降路径最小和.md","content":"### [931. 下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)\n\n```\n给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。\n\n下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。\n\n输入：matrix = [[2,1,3],[6,5,4],[7,8,9]]\n输出：13\n解释：如图所示，为和最小的两条下降路径\n```\n\n![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/06/2138161694007496169400749626494OnUZ-failing1-grid.jpg)\n\n#### dp\n\n```java\nclass Solution {\n    public int minFallingPathSum(int[][] matrix) {\n        int len = matrix.length;\n        int[][] dp = new int[len][len];\n        for(int i = 0; i < len; i++) dp[0][i] = matrix[0][i];\n\n        for(int i = 1; i < dp.length; i++) {\n            for(int j = 0; j < dp.length; j++) {\n                if(j == 0) {\n                    dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j + 1]);\n                } else if(j == dp.length - 1) {\n                    dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]);\n                } else {\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1]);\n                }\n                dp[i][j] += matrix[i][j];\n            }\n\n        }\n\n        // for(int[] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        int res = Integer.MAX_VALUE;\n        for(int i = 0; i < len; i++) {\n            res = Math.min(res, dp[len - 1][i]);\n        }\n\n        return res;\n    }\n\n    int min(int a, int b, int c) {\n        return Math.min(a, Math.min(b, c));\n    }\n}\n```\n\n\n\n### 备忘录\n\n```java\nclass Solution {\n    int[][] memo;\n    public int minFallingPathSum(int[][] matrix) {\n        int len = matrix.length;\n        memo = new int[len][len];\n        for(int i = 0; i < len; i++) {\n            Arrays.fill(memo[i], 66666);\n        }\n        \n\n        int res = Integer.MAX_VALUE;\n        for(int i = 0; i < len; i++) {\n            res = Math.min(res, dp(matrix, len - 1, i));\n        }\n\n        return res;\n    }\n\n    int dp(int[][] martix, int row, int col) {\n        if(row < 0 || col < 0 || row >= martix.length || col >= martix[0].length) {\n            return 99999;\n        }\n\n        if(row == 0) return martix[0][col];     // 第一行的代价就是本身\n\n        if(memo[row][col] != 66666) {\n            return memo[row][col];\n        }\n\n        memo[row][col] = martix[row][col] + min(\n            dp(martix, row - 1, col - 1), \n            dp(martix, row - 1, col), \n            dp(martix, row - 1, col + 1)\n        );\n        return  memo[row][col];\n    }\n\n    \n\n    int min(int a, int b, int c) {\n        return Math.min(a, Math.min(b, c));\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-总结.md","path":"002-数据结构与算法/010-动态规划/100-总结.md","content":"然后我们讲了动规的五部曲：\n\n1.  确定dp数组（dp table）以及下标的含义\n2.  确定递推公式\n3.  dp数组如何初始化\n4.  确定遍历顺序\n5.  举例推导dp数组\n\n[参考](https://programmercarl.com/周总结/20210107动规周末总结.html#周一)\n\n\n\n输出数组\n\n```\n\n```\n\n","timestamp":1694699764227},{"name":"101-斐波那契数列 .md","path":"002-数据结构与算法/010-动态规划/101-斐波那契数列 .md","content":"### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)\n\n#### 方法一：迭代\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if(n <= 1) return n;\n        int a = 0;\n        int b = 1;\n        for(int i = 2; i <= n; i++) {\n            int tmp = a + b;\n            a = b;\n            b = tmp;\n        }\n\n        return b;\n    }\n}\n```\n\n#### 方法二：递归\n\n#### 方法三：dp\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if(n <= 1) return n;\n        int[]dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n\n        for(int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 2] + dp[i-1];\n        }\n\n        return dp[n];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"104-343. 整数拆分.md","path":"002-数据结构与算法/010-动态规划/104-343. 整数拆分.md","content":"### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)\n\n1.   dp[i] 表示将数字i拆分的最大乘积 (dp[i]必须是拆分后的，不能不拆分)\n2.   递推公式：dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j);\n\n-   两种渠道得到dp[i]\n\n    -   一个是j * (i - j) ，将i拆分成两个\n\n    -   一个是j * dp[i - j]，拆分成j，再拆分(i - j)，即拆分成三个数以上。（dp[i - j]至少拆分为两个）\n\n3.   初始化 \n\n     dp[0] = 1，dp[1] = 1也能过\n\n     严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值\n\n     拆分0和拆分1的最大乘积是多少？无解\n\n```java\nclass Solution {\n    public int integerBreak(int n) {\n        int[] dp = new int[n + 1];\n        dp[2] = 1;\n        for(int i = 3; i <= n; i++) {  // 计算从3～n的拆分\n            for(int j = 1; j < i; j++) {\t// 将i从1开始拆分，取最大乘积，此处j < i-1也行，解释见下方\n                dp[i] = Math.max(dp[i], j * (i-j));\n                dp[i] = Math.max(dp[i], j * dp[i-j]);\n            }\n        }\n\n        return dp[n];\n    }\n}\n```\n\nj < i-1也行是因为dp[1] = 0,因此省略了最后一步\n\n以3为例，写成j < i - 1的形式就是\n\n```\nj = 1\t   \tmax(dp3, 1*(3-1), 1*dp2)\nj = 2\t\t\tmax(dp3, 2*(3-2), 2*dp1)\n```\n\n\n\n错解\n\n```java\nclass Solution {\n    public int integerBreak(int n) {\n        int[] dp = new int[n + 1];\n        for(int i = 0; i <= n; i++) dp[i] = i;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= i; j++) {\n                dp[i] = Math.max(dp[i], j * dp[i - j]);\n            }\n        }\n        System.out.println(Arrays.toString(dp));\n        return dp[n];\n    }\n}\n\n// input: 2\n// output: 2\n// expect: 1\n```\n\n","timestamp":1694699764227},{"name":"105-96. 不同的二叉搜索树.md","path":"002-数据结构与算法/010-动态规划/105-96. 不同的二叉搜索树.md","content":"### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)\n\n#### 方法一：dp\n\n```java\nclass Solution {\n    public int numTrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= i; j++) {\n                dp[i] += dp[i - j] * dp[j - 1];\n            }\n        }\n\n        // for(int d : dp) {\n        //     System.out.print(d + \" \");\n        // }\n\n        return dp[n];\n    }\n}\n```\n\n\n\n#### 方法二：递归\n\nhttps://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-b16de/\n\nhttps://mp.weixin.qq.com/s/kcwz2lyRxxOsC3n11qdVSw\n\n设给算法输入 `n = 5`，也就是说用 `{1,2,3,4,5}` 这些数字去构造 BST。\n\n如果固定 `3` 作为根节点，左子树节点就是 `{1,2}` 的组合，右子树就是 `{4,5}` 的组合：\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/02/22/111405167703564516770356452492rBk4L-1.jpeg\" alt=\"img\" style=\"zoom:50%;\" />\n\n那么 `{1,2}` 和 `{4,5}` 的组合有多少种呢？只要合理定义递归函数，这些可以交给递归函数去做。\n\n另外，这题存在重叠子问题，可以通过备忘录的方式消除冗余计算。\n\n```java\nclass Solution {\n    // 备忘录\n    int[][] memo;\n\n    int numTrees(int n) {\n        // 备忘录的值初始化为 0\n        memo = new int[n + 1][n + 1];\n        return count(1, n);\n    }\n\n    int count(int lo, int hi) {\n        if (lo > hi) return 1;\t\t// 子树为空也是一种情况， 可以>=， 不同的二叉搜索树2不行\n        // 查备忘录\n        if (memo[lo][hi] != 0) {\n            return memo[lo][hi];\n        }\n\n        int res = 0;\n        for (int mid = lo; mid <= hi; mid++) {\t\t// 每个值分别当根节点\n            int left = count(lo, mid - 1);\n            int right = count(mid + 1, hi);\n            res += left * right;\n        }\n        // 将结果存入备忘录\n        memo[lo][hi] = res;\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"106-53. 最大子数组和.md","path":"002-数据结构与算法/010-动态规划/106-53. 最大子数组和.md","content":"### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)\n\n方法一：dp\n\ndp含义\n\n```\ndp[i]：包括下标i之前的最大连续子序列和为dp[i]。\n\ndp[i] = max(dp[i - 1] + nums[i], nums[i]);\n```\n\n\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n        for(int i = 1; i < nums.length; i++) {\n            dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);\n        }\n\n        // System.out.print(Arrays.toString(dp));\n\n        int res = Integer.MIN_VALUE;\n        for(int i : dp) {\n            res = Math.max(res, i);\n        }\n\n        return res;\n    }\n}\n```\n\n优化：滚动数组\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int pre = nums[0];\n        int res = pre;\n        for(int i = 1; i < nums.length; i++) {\n            pre = Math.max(nums[i], pre + nums[i]);\n            res = Math.max(res, pre);\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法二：贪心\n\n写过","timestamp":1694699764227},{"name":"107-221. 最大正方形.md","path":"002-数据结构与算法/010-动态规划/107-221. 最大正方形.md","content":"### [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)\n\n```\n在一个由 \'0\' 和 \'1\' 组成的二维矩阵内，找到只包含 \'1\' 的最大正方形，并返回其面积。\n\n输入：matrix = \n[\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\n]\n输出：4\n```\n\n![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/06/21410716940076671694007667765FjCNQ3-max1grid.jpg)\n\n\n\n```java\nclass Solution {\n\n    public int maximalSquare(char[][] matrix) {\n        int maxSize = 0;\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return maxSize;\n        }\n\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        for(int row = 0; row < rows; row++) {\n            for(int col = 0; col < cols; col++) {\n                if(matrix[row][col] == \'1\') {           // 遇到1则作为正方形左上角\n                    maxSize = Math.max(maxSize, 1);     // 初始变长为1\n                    int curMaxSide = Math.min(rows - row, cols - col);      // 能拓展的最大边长\n                    for(int k = 1; k < curMaxSide; k++) {       // 每次拓展一行一列\n                        boolean flag = true;                    // 判断新增的一行一列是否全为1\n                        // if (matrix[row + k][col + k] == \'0\') {\n                        //     break;\n                        // }\n\n                        for(int m = 0; m <= k; m++) {\n                            if(matrix[row + m][col + k] == \'0\' || matrix[row + k][col + m] == \'0\') {    // 判断新增的一行一列有0\n                                flag = false;\n                                break;\n                            }\n                        }\n\n                        if(flag) {\n                            maxSize = Math.max(maxSize, k + 1);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return maxSize * maxSize;\n    }\n}\n```\n\n\n\n```java\nclass Solution {\n    public int maximalSquare(char[][] matrix) {\n        int maxSide = 0;\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        int[][] dp = new int[rows][cols];\n\n        for(int row = 0; row < rows; row++) {\n            for(int col = 0; col < cols; col++) {\n                if(matrix[row][col] == \'1\') {\n                    if(row == 0 || col == 0) {\n                        dp[row][col] = 1;\n                    } else {\n                        dp[row][col] = 1 + min(dp[row][col - 1], dp[row - 1][col], dp[row - 1][col - 1]);\n                    }\n\n                    maxSide = Math.max(maxSide, dp[row][col]);\n                }\n            }\n        }\n\n        return maxSide * maxSide;\n    }\n\n    int min(int a, int b, int c) {\n        return Math.min(Math.min(a, b), c);\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"108-1277. 统计全为 1 的正方形子矩阵.md","path":"002-数据结构与算法/010-动态规划/108-1277. 统计全为 1 的正方形子矩阵.md","content":"### [1277. 统计全为 1 的正方形子矩阵](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/)\n\n```\n给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。\n\n示例 1：\n\n输入：matrix =\n[\n  [0,1,1,1],\n  [1,1,1,1],\n  [0,1,1,1]\n]\n输出：15\n解释： \n边长为 1 的正方形有 10 个。\n边长为 2 的正方形有 4 个。\n边长为 3 的正方形有 1 个。\n正方形的总数 = 10 + 4 + 1 = 15.\n```\n\n\n\n\n\n```java\nclass Solution {\n    int res = 0;\n\n    public int countSquares(int[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        int[][] dp = new int[rows][cols];\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                if(matrix[i][j] == 1) {\n                    if(i == 0 || j == 0) {\n                        dp[i][j] = 1;\n                        res++;\n                    } else {\n                        dp[i][j] = 1 + Math.min(dp[i][j - 1], Math.min(dp[i - 1][j], dp[i - 1][j - 1]));\n                        res += dp[i][j];\n                    }\n                }\n            }\n        }\n\n        // for(int[] d : dp) {\n        //     System.out.println(Arrays.toString(d));\n        // }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"109-887. 鸡蛋掉落.md","path":"002-数据结构与算法/010-动态规划/109-887. 鸡蛋掉落.md","content":"### [887. 鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)\n\n```\n给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。\n\n已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。\n\n每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。\n\n请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？\n\n输入：k = 1, n = 2\n输出：2\n解释：\n鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 \n否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 \n如果它没碎，那么肯定能得出 f = 2 。 \n因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 \n```\n\nTODO\n\n```\nclass Solution {\n    Map<Integer, Integer> memo = new HashMap<Integer, Integer>();\n\n    public int superEggDrop(int k, int n) {\n        return dp(k, n);\n    }\n\n    public int dp(int k, int n) {\n        if (!memo.containsKey(n * 100 + k)) {\n            int ans;\n            if (n == 0) {\n                ans = 0;\n            } else if (k == 1) {\n                ans = n;\n            } else {\n                int lo = 1, hi = n;\n                while (lo + 1 < hi) {\n                    int x = (lo + hi) / 2;\n                    int t1 = dp(k - 1, x - 1);\n                    int t2 = dp(k, n - x);\n\n                    if (t1 < t2) {\n                        lo = x;\n                    } else if (t1 > t2) {\n                        hi = x;\n                    } else {\n                        lo = hi = x;\n                    }\n                }\n\n                ans = 1 + Math.min(Math.max(dp(k - 1, lo - 1), dp(k, n - lo)), Math.max(dp(k - 1, hi - 1), dp(k, n - hi)));\n            }\n\n            memo.put(n * 100 + k, ans);\n        }\n\n        return memo.get(n * 100 + k);\n    }\n}\n\n作者：力扣官方题解\n链接：https://leetcode.cn/problems/super-egg-drop/solutions/197163/ji-dan-diao-luo-by-leetcode-solution-2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","timestamp":1694699764227},{"name":"110-312. 戳气球.md","path":"002-数据结构与算法/010-动态规划/110-312. 戳气球.md","content":"### [312. 戳气球](https://leetcode.cn/problems/burst-balloons/)\n\nTODO\n\n```java\nclass Solution {\n    public int[][] rec;\n    public int[] val;\n\n    public int maxCoins(int[] nums) {\n        int n = nums.length;\n        val = new int[n + 2];\n        for (int i = 1; i <= n; i++) {\n            val[i] = nums[i - 1];\n        }\n        val[0] = val[n + 1] = 1;\n        rec = new int[n + 2][n + 2];\n        for (int i = 0; i <= n + 1; i++) {\n            Arrays.fill(rec[i], -1);\n        }\n        return solve(0, n + 1);\n    }\n\n    public int solve(int left, int right) {\n        if (left >= right - 1) {\n            return 0;\n        }\n        if (rec[left][right] != -1) {\n            return rec[left][right];\n        }\n        for (int i = left + 1; i < right; i++) {\n            int sum = val[left] * val[i] * val[right];\n            sum += solve(left, i) + solve(i, right);\n            rec[left][right] = Math.max(rec[left][right], sum);\n        }\n        return rec[left][right];\n    }\n}\n\n作者：力扣官方题解\n链接：https://leetcode.cn/problems/burst-balloons/solutions/336390/chuo-qi-qiu-by-leetcode-solution/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","timestamp":1694699764227},{"name":"01-岛屿问题.md","path":"002-数据结构与算法/011-图论/01-岛屿问题.md","content":"[岛屿类问题](https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)\n\n### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)\n\n```java\nclass Solution {\n    public int numIslands(char[][] grid) {\n        int res = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == \'1\') {\n                    dfs(grid, i, j);\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n\n    public void dfs(char[][] grid, int r, int c) {\n        if(!inArea(grid, r, c)) {\n            return;\n        }\n\n        if(grid[r][c] != \'1\') {\n            return;\n        }\n\n        grid[r][c] = 2;\n\n        dfs(grid, r - 1, c);\n        dfs(grid, \n            r + 1, c);\n        dfs(grid , r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\n    boolean inArea(char[][]grid, int r, int c) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        return r >= 0 && r < rows && c >=0 && c < cols;\n    }\n}\n```\n\n\n\n### [463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)\n\n![image-20221212102508604](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/12/12/10250816708119081670811908804Ql7ILJ-image-20221212102508604.png)\n\n\n\n```java\nclass Solution {\n    public int islandPerimeter(int[][] grid) {\n        int res = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == 1) {\n                    res += dfs(grid, i, j);\n                }\n            }\n        }\n\n        return res;\n    }\n\n    public int dfs(int[][]grid, int row, int col) {\n        // 超出范围返回，对应黄边\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) {\n            return 1;\n        }\n\n        // 遇到海洋返回，对应蓝边\n        if(grid[row][col] == 0) {\n            return 1;\n        }\n\n        // 已经遍历过了\n        if(grid[row][col] == 2) {\n            return 0;\n        }\n\n        // 标记已经遍历\n        grid[row][col] = 2;\n\n        return dfs(grid, row - 1, col) + \n               dfs(grid, row + 1, col) + \n               dfs(grid, row, col - 1) +\n               dfs(grid, row, col + 1);\n    }\n}\n```\n\n\n\n### [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)\n\n```java\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int res = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == 1) {\n                    res = Math.max(res, dfs(grid, i, j)); \n                }\n            }\n        }\n\n        return res;\n    }\n\n    public int dfs(int[][]grid, int row, int col) {\n        // 超出范围返回，对应黄边\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) {\n            return 0;\n        }\n\n        // 已经遍历过了\n        if(grid[row][col] != 1) {\n            return 0;\n        }\n\n        // 标记已经遍历\n        grid[row][col] = 2;\n\n        return 1 +\n               dfs(grid, row - 1, col) + \n               dfs(grid, row + 1, col) + \n               dfs(grid, row, col - 1) +\n               dfs(grid, row, col + 1);\n    }\n}\n```\n\n\n\n### [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/)\n\n思路：\n\n-   dfs遍历，求每块岛屿面积并进行标记\n-   遍历海水，依次变成陆地，求连接到岛屿总面积。即1 + 上下左右连接的不同岛屿的面积\n\n![image-20221212202449305](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/12/12/20244916708478891670847889489DC18W7-image-20221212202449305.png)\n\n```java\nclass Solution {\n    public int largestIsland(int[][] grid) {\n        // 给每一块岛屿编号，计算并存储每块岛屿面积\n        Map<Integer, Integer> map = new HashMap<>();\n        int id = 2;  // 0 和 1已经有含义了，从2开始，避免冲突\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == 1) {\n                    map.put(id, calcArea(grid, i, j, id));\n                    id++;\n                }\n            }\n        }\n\n        // for (Integer i : map.keySet()) {\n        //     System.out.println(\"key: \" + i + \" value: \" + map.get(i));\n        // }\n\n        // 填海造路，找最大\n        int res = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                \n                if(grid[i][j] == 0) {\n                    // System.out.println(\"===\" + i + \" \" + j + \"===\");\n                    Set<Integer> ids = getNearAreaIds(grid, i, j);\n                    int tmpArea = 0;\n                    \n                    for(int item : ids) {\n                        tmpArea += map.get(item);\n                    }\n                    res = Math.max(res, tmpArea + 1);\n                }\n            }\n        }\n\n        return res == 0 ? map.get(2) : res;  // res为0表示全是陆地，没有海\n    }\n\n   // 计算岛屿面积，并用岛屿id标记每块方格\n    public int calcArea(int[][] grid, int row, int col, int id) {\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) {\n            return 0;\n        }\n\n        if(grid[row][col] != 1) {\n            return 0;\n        }\n\n        grid[row][col] = id;\n\n        return 1 \n            + calcArea(grid, row, col + 1, id) \n            + calcArea(grid, row, col - 1, id) \n            + calcArea(grid, row + 1, col, id)\n            + calcArea(grid, row - 1, col, id);\n    }\n\n    // 判断该方格是否在界内\n    boolean inArea(int[][]grid, int r, int c) {\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\n    }\n\n    // 获取四周的陆地id\n    public Set<Integer> getNearAreaIds(int[][] grid, int row, int col) {\n        Set<Integer> islandIds = new HashSet<>();   // 岛屿编号集合\n        if(inArea(grid, row - 1, col) && grid[row - 1][col] != 0) {  // 在边界内，且不是海\n            islandIds.add(grid[row - 1][col]);\n        }\n        if(inArea(grid, row + 1, col) && grid[row + 1][col] != 0) {\n            islandIds.add(grid[row + 1][col]);\n        }\n        if(inArea(grid, row, col - 1) && grid[row][col - 1] != 0) {\n            islandIds.add(grid[row][col - 1]);\n        }\n        if(inArea(grid, row, col + 1) && grid[row][col + 1] != 0) {\n            islandIds.add(grid[row][col + 1]);\n        }\n\n        // for(int id : islandIds) {\n        //     System.out.print(id + \" \");\n        // }\n        return islandIds;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/making-a-large-island/solution/by-muse-77-37hi/)\n","timestamp":1694699764227},{"name":"02-994.腐烂的橘子.md","path":"002-数据结构与算法/011-图论/02-994.腐烂的橘子.md","content":"### [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)\n\n```java\nclass Solution {\n    public int orangesRotting(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int[][] dir = new int[][]{ {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\n        Deque<int[]> q = new LinkedList<>();\n\n        // 统计新鲜橘子熟了，腐烂橘子入队列\n        int cnt = 0;    // 新鲜橘子数量\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                if(grid[i][j] == 1) {\n                    cnt++;\n                } else if(grid[i][j] == 2) {\n                    q.offer(new int[] {i, j});\n                }\n            }\n        }\n\n        // 统计腐烂轮数\n        int round = 0;  // 轮数\n        while(cnt > 0 && !q.isEmpty()) {\n            round++;\n            int n = q.size();\n            while(n-- > 0) {\n                int[] tmp = q.poll();\n                // 往四个方向腐烂\n                for(int i = 0; i < 4; i++) {\n                    int r = tmp[0] + dir[i][0];\n                    int c = tmp[1] + dir[i][1];\n                    if(r >= 0 && c >= 0 && r < rows && c < cols && grid[r][c] == 1) {   // 界内 & 新鲜\n                        grid[r][c] = 2;\n                        q.offer(new int[]{r, c});\n                        cnt--;\n                    }\n                }\n            }\n            \n\n        }\n\n        return cnt == 0 ? round : -1;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/rotting-oranges/solution/li-qing-si-lu-wei-shi-yao-yong-bfsyi-ji-ru-he-xie-/)","timestamp":1694699764227},{"name":"03-207. 课程表.md","path":"002-数据结构与算法/011-图论/03-207. 课程表.md","content":"### [207. 课程表](https://leetcode.cn/problems/course-schedule/)\n\n#### 方法一：入度表（广度优先遍历）\n\n```java\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] indegrees = new int[numCourses];              // 入度\n        List<List<Integer>> adjacency = new ArrayList<>();  // 邻接表\n        Deque<Integer> q = new LinkedList<>();              // 入度为0的节点\n\n        // 初始化空的邻接表\n        for(int i = 0; i < numCourses; i++) {\n            adjacency.add(new ArrayList<>());\n        }\n        // 输出化节点入度 pr[1] -> pr[0]\n        for(int[] pr : prerequisites) {\n            indegrees[pr[0]]++;\n            adjacency.get(pr[1]).add(pr[0]);\n        }\n        // 初始化辅助队列\n        for(int i = 0; i < indegrees.length; i++) {\n            if(indegrees[i] == 0) q.offer(i);\n        }\n        // 判断能否进行拓扑排序\n        while(!q.isEmpty()) {\n            int node = q.poll();\n            numCourses--;\n            for(int next : adjacency.get(node)) {           // 遍历pre的邻接节点, 入度-1\n                if(--indegrees[next] == 0) q.offer(next);   // 入度为0，则入队\n            }\n        }\n\n        return numCourses == 0;\n    }\n}\n```\n\n[什么是拓扑排序](https://www.jianshu.com/p/b59db381561a)\n\n[参考](https://leetcode.cn/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/)\n\n\n\n#### 方法二：深搜","timestamp":1694699764227},{"name":"04-79. 单词搜索.md","path":"002-数据结构与算法/011-图论/04-79. 单词搜索.md","content":"### [79. 单词搜索](https://leetcode.cn/problems/word-search/)","timestamp":1694699764227},{"name":"05-剑指 Offer 13. 机器人的运动范围.md","path":"002-数据结构与算法/011-图论/05-剑指 Offer 13. 机器人的运动范围.md","content":"#### [剑指 Offer 13. 机器人的运动范围](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)\n\n错误思想\n\n```\n遍历二维数组，求每个位置的和，统计小于k的个数\n\n问题：部分位置虽然满足小于k的条件，但并不可达\n```\n\n\n\n#### 方法1： dfs\n\n```\nclass Solution {\n\n    int m, n, k;\n    boolean[][] visited;\n\n    public int movingCount(int m, int n, int k) {\n        visited = new boolean[m][n];    // 记录是否走过\n        this.m = m;\n        this.n = n;\n        this.k = k;\n        return dfs(0, 0);\n    }\n\n    public int dfs(int r, int c) {  \n        if(r >= m || c >= n || visited[r][c] || sum(r, c) > k) return 0;    // 超出边界 & 访问过 & 坐标和超出\n        visited[r][c] = true;   // 标记为访问\n        return 1 + dfs(r + 1, c) + dfs(r, c + 1);   // 想右向下走\n    }\n\n    // 计算坐标和\n    public int sum(int r, int c) {\n        int sum = 0;\n        while(r != 0) {\n            sum += r % 10;\n            r /= 10;\n        }\n        while(c != 0) {\n            sum += c % 10;\n            c /= 10;\n        }\n\n        return sum;\n    }\n\n\n}\n```\n\nhttps://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/dfshe-bfsliang-chong-jie-jue-fang-shi-by-sdwwld/\n\n#### 方法2: bfs\n\n```java\nclass Solution {\n\n\n    public int movingCount(int m, int n, int k) {\n        int res = 0;\n        boolean[][] visited = new boolean[m][n];    // 记录是否走过\n        Deque<int[]> q = new LinkedList<>();\n        q.offer(new int[]{0, 0});\n        while(!q.isEmpty()) {\n            int[] pos = q.poll();\n            int i = pos[0], j = pos[1];\n            if(i >= m || j >= n || visited[i][j] || sum(i, j) > k) continue;\n\n            visited[i][j] = true;\n            res++;\n            q.offer(new int[]{i + 1, j});\n            q.offer(new int[]{i, j + 1});\n        }\n\n        return res;\n    }\n\n    // 计算坐标和\n    public int sum(int r, int c) {\n        int sum = 0;\n        while(r != 0) {\n            sum += r % 10;\n            r /= 10;\n        }\n        while(c != 0) {\n            sum += c % 10;\n            c /= 10;\n        }\n\n        return sum;\n    }\n\n\n}\n```\n\nhttps://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/dfshe-bfsliang-chong-jie-jue-fang-shi-by-sdwwld/","timestamp":1694699764227},{"name":"06-其他.md","path":"002-数据结构与算法/011-图论/06-其他.md","content":"https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/by-da-fei-de-tian-kong-dhms/","timestamp":1694699764227},{"name":"07-841. 钥匙和房间.md","path":"002-数据结构与算法/011-图论/07-841. 钥匙和房间.md","content":"### [841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)\n\n```\nclass Solution {\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\n        boolean[] visited = new boolean[rooms.size()];\n        dfs(rooms, 0, visited);\n        // System.out.println(Arrays.toString(visited));\n        for(boolean v : visited) {\n            if(!v) return false;\n        }\n\n        return true;\n    }\n\n    public void dfs(List<List<Integer>> rooms, Integer key, boolean[] visited) {\n        if(visited[key]) return;\n\n        visited[key] = true;\n        for(int k : rooms.get(key)) {\n            dfs(rooms, k, visited);\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"08-127. 单词接龙.md","path":"002-数据结构与算法/011-图论/08-127. 单词接龙.md","content":"### [127. 单词接龙](https://leetcode.cn/problems/word-ladder/)\n\n```\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> wordSet = new HashSet<>(wordList);  //转换为hashset 加快速度\n        if(wordSet.size() == 0 || !wordSet.contains(endWord)) return 0; //特殊情况判断\n\n        Queue<String> queue = new LinkedList<>();   // bfs队列\n        queue.offer(beginWord);\n\n        Map<String, Integer> map = new HashMap<>(); // 记录单词对应路径长度\n        map.put(beginWord, 1);\n\n        while(!queue.isEmpty()) {\n            String word = queue.poll();  // 取出队首单词\n            int path = map.get(word);   // 队首单词路径长度\n\n            for(int i = 0; i < word.length(); i++) {    // 遍历单词的每个字符，逐一替换a-z, 寻找下一层路径\n                char[] chars = word.toCharArray();\n                for(char k = \'a\'; k <= \'z\'; k++) {  // 从\'a\' 到 \'z\' 遍历替换\n                    chars[i] = k;\n                    String newWord = String.valueOf(chars);\n                    if(newWord.equals(endWord)) {   // 如果新的字符串值与endWord一致，提前结束，返回当前长度+1\n                        return path + 1;\n                    }\n\n                    if(wordSet.contains(newWord) && !map.containsKey(newWord)) { // 新单词在set中 && 没访问过\n                        map.put(newWord, path + 1);\n                        queue.offer(newWord);\n                    }\n                }\n            }\n        }\n\n        return 0;   // 未找到\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"09-841. 钥匙和房间.md","path":"002-数据结构与算法/011-图论/09-841. 钥匙和房间.md","content":"### [841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)\n\n```\n有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。\n\n当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。\n\n给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回 false。\n\n示例 1：\n\n输入：rooms = [[1],[2],[3],[]]\n输出：true\n解释：\n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n```\n\n\n\n```\nclass Solution {\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\n        boolean[] visited = new boolean[rooms.size()];\n        dfs(rooms, 0, visited);\n        // System.out.println(Arrays.toString(visited));\n        for(boolean v : visited) {\n            if(!v) return false;\n        }\n\n        return true;\n    }\n\n    public void dfs(List<List<Integer>> rooms, Integer key, boolean[] visited) {\n        if(visited[key]) return;\n\n        visited[key] = true;\n        for(int k : rooms.get(key)) {\n            dfs(rooms, k, visited);\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-1365. 有多少小于当前数字的数字.md","path":"002-数据结构与算法/012-额外题目/01-数组/100-1365. 有多少小于当前数字的数字.md","content":"### [1365. 有多少小于当前数字的数字](https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/)\n\n\n\n```java\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int[] res = Arrays.copyOf(nums, nums.length);\n        Arrays.sort(res);\n      \n      \t// 排序后，下标值就是小于当前数的个数\n        for(int i = 0; i < res.length; i++) {\n            if(!map.containsKey(res[i])) {\n                map.put(res[i], i);\n            }\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            res[i] = map.get(nums[i]);\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"101-941. 有效的山脉数组.md","path":"002-数据结构与算法/012-额外题目/01-数组/101-941. 有效的山脉数组.md","content":"### [941. 有效的山脉数组](https://leetcode.cn/problems/valid-mountain-array/)\n\n```\nclass Solution {\n    public boolean validMountainArray(int[] arr) {\n        if(arr.length < 3) return false;\n        int l = 0;\n        int r = arr.length - 1;\n        while(l + 1 < arr.length && arr[l] < arr[l + 1]) l++;\n        while(r > 0 && arr[r] < arr[r - 1]) r--;\n\n        // l 、r在起始位置则不是山峰\n        return l == r && l != 0 && r != arr.length - 1;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"102-1207. 独一无二的出现次数.md","path":"002-数据结构与算法/012-额外题目/01-数组/102-1207. 独一无二的出现次数.md","content":"### [1207. 独一无二的出现次数](https://leetcode.cn/problems/unique-number-of-occurrences/)\n\n#### 方法一：两个map\n\n```java\nclass Solution {\n    public boolean uniqueOccurrences(int[] arr) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < arr.length; i++) {\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\n        }\n\n        Map<Integer, Integer> map2 = new HashMap<>();\n        for(Integer key : map.keySet()) {\n            int value = map.get(key);\n            if(map2.containsKey(value)) {\n                return false;\n            } else {\n                map2.put(value, 1);\n            }\n        }\n\n        return true;\n    }\n}\n```\n\n#### 方法二：双数组\n\n```java\nclass Solution {\n    public boolean uniqueOccurrences(int[] arr) {\n        int[] count = new int[2002];\n        for(int i = 0; i < arr.length; i++) {\n            count[arr[i] + 1000]++;    // 防止负数作为下标\n        }\n\n        boolean[] flag = new boolean[1002];\n        for(int i = 0; i < count.length; i++) {\n            if(count[i] <= 0) continue;\n            if(flag[count[i]] == true) return false;\n            flag[count[i]] = true;\n        }\n\n        return true;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"103-283. 移动零.md","path":"002-数据结构与算法/012-额外题目/01-数组/103-283. 移动零.md","content":"### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)\n\n#### 双指针\n\n```\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int fast = 0; \n        int low = 0;\n        while(fast < nums.length) {\n            if(nums[fast] != 0) {\n                nums[low++] = nums[fast];\n            }\n            fast++;\n        }\n\n        while(low < nums.length) nums[low++] = 0;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"104-189. 轮转数组.md","path":"002-数据结构与算法/012-额外题目/01-数组/104-189. 轮转数组.md","content":"### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)\n\n注意：是右轮转，与左轮转区分\n\n#### 方法一：\n\n思路：\n\n-   翻转后k个\n-   翻转剩余的\n-   翻转全部\n\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        int n = nums.length;\n        k = k % n;\n        reverse(nums, n - k , n - 1);\n        // System.out.println(Arrays.toString(nums));\n\n        reverse(nums, 0, n - k - 1);\n        // System.out.println(Arrays.toString(nums));\n        reverse(nums, 0, nums.length - 1);\n    }\n\n    public void reverse(int[] nums, int l, int r) {\n        while(l < r) {\n            int tmp = nums[l];\n            nums[l++] = nums[r];\n            nums[r--] = tmp;\n        }\n    }\n}\n```\n\n#### 方法二：\n\n本题是右旋转，其实就是反转的顺序改动一下，优先反转整个字符串，步骤如下：\n\n1.  反转整个字符串\n2.  反转区间为前k的子串\n3.  反转区间为k到末尾的子串","timestamp":1694699764227},{"name":"105-724. 寻找数组的中心下标.md","path":"002-数据结构与算法/012-额外题目/01-数组/105-724. 寻找数组的中心下标.md","content":"### [724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)\n\n```\n负数： [-1,-1,-1,-1,-1,0]\n边界值： [2, 1, -1]\n```\n\n错解 - 双指针：无法解决负数情况\n\n```java\nclass Solution {\n    public int pivotIndex(int[] nums) {\n        int l = 0; \n        int r = nums.length - 1;\n        int lSum = nums[l];\n        int rSum = nums[r];\n        while(l < r) {\n            if(lSum <= rSum) {\n                l++;\n                lSum += nums[l];\n            } else if(lSum > rSum) {\n                r--;\n                rSum += nums[r];\n            }\n        }\n\n        if(lSum == rSum) {\n            return l;\n        }\n        return -1;\n    }\n}\n```\n\n正解\n\n```java\nclass Solution {\n    public int pivotIndex(int[] nums) {\n        // 统计求和\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n        }\n\n        // 找中心下标: 修改题意 lSum 和 rSum都包含中心下标元素\n        int lSum = 0;\n        int rSum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            lSum += nums[i];\n            rSum = sum - lSum + nums[i];\n            if(lSum == rSum) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"106-34. 在排序数组中查找元素的第一个和最后一个位置.md","path":"002-数据结构与算法/012-额外题目/01-数组/106-34. 在排序数组中查找元素的第一个和最后一个位置.md","content":"### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n#### 方法一：双指针\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        if(nums.length == 0) return new int[]{-1, -1};\n\n        int l = 0; \n        int r = nums.length - 1;\n        while(l < r && nums[l] != target) l++;\n        while(l < r && nums[r] != target) r--;\n        if(l == r && nums[l] != target) return new int[]{-1, -1};\n\n        return new int[]{l, r};\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"107-922. 按奇偶排序数组 II.md","path":"002-数据结构与算法/012-额外题目/01-数组/107-922. 按奇偶排序数组 II.md","content":"### [922. 按奇偶排序数组 II](https://leetcode.cn/problems/sort-array-by-parity-ii/)\n\n#### 方法一： 三个数组\n\n分别是 结果集、奇数集、偶数集\n\n\n\n#### 方法二：一个数组\n\n只保留结果集\n\n分别记录偶数下标evenIndex、和奇数下标oddIndex，\n\n遍历数组，是偶数就往偶数下标放，evenIndex += 2；是奇数就往奇数下标放， oddIndex += 2；\n\n\n\n#### 方法三： 远数组上修改\n\n```java\nclass Solution {\n    public int[] sortArrayByParityII(int[] nums) {\n        for(int i = 0; i < nums.length; i++) {\n            if(i % 2 == 0 && nums[i] % 2 != 0) { // 偶数位遇到奇数\n                int t = i + 1;\n                while(t < nums.length && nums[t] % 2 != 0) t++;\t\t// 往后找一个偶数交换\n                swap(nums, i, t);\n                continue;\n            }\n            if(i % 2 != 0 && nums[i] % 2 == 0) {\t// 奇数位遇到偶数\t\n                int t = i + 1;\n                while(t < nums.length && nums[t] % 2 == 0) t++;\t // 往后找一个奇数交换\n                swap(nums, i, t);\t\n                continue;\n            }\n        }\n\n        return nums;\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n\n优化: 只处理 偶数位遇到奇数位的情况\n\n```java\nclass Solution {\n    public int[] sortArrayByParityII(int[] nums) {\n        int oddIndex = 1;\n        for(int i = 0; i < nums.length; i += 2) {\n            if(nums[i] % 2 != 0) {\t// 在偶数位遇到了奇数\n                while(nums[oddIndex] % 2 != 0) oddIndex += 2;\t// 在奇数位找一个偶数\n                swap(nums, i, oddIndex);\n            }\n        }\n\n        return nums;\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-24. 两两交换链表中的节点.md","path":"002-数据结构与算法/012-额外题目/02-链表/100-24. 两两交换链表中的节点.md","content":"### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n\n#### 方法一：虚拟头节点 + 双指针\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyHead = new ListNode();\n        dummyHead.next = head;\n\n        ListNode pre = dummyHead;\n        ListNode cur = head;\n        while(cur != null && cur.next != null) {\n            pre.next = cur.next;\n            cur.next = pre.next.next;\n            pre.next.next = cur;\n\n            pre = cur;\n            cur = cur.next;\n        }\n\n        return dummyHead.next;\n    }\n}\n```\n\n#### 方法二：递归\n\n```\n输入：head = [1,2,3,4...]\n输出：[2,1,4,3]\n\nhead 指向 1\nnext 指向 2\n将3, 4...看成一个整体，swapPairs(next.next)之后，这个整体就会两两交换，产生一个新的头节点newNode\n此时，只要交换head和next就完成交换\n```\n\n\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode next = head.next;\n        ListNode newNode = swapPairs(next.next);\n\n        next.next = head;\n        head.next = newNode;\n\n        return next;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"101-234. 回文链表.md","path":"002-数据结构与算法/012-额外题目/02-链表/101-234. 回文链表.md","content":"### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)\n\n#### 方法一：数组 + 双指针\n\n```java\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        List<Integer> list = new ArrayList<>();\n        while(head != null) {\n            list.add(head.val);\n            head = head.next;\n        }\n\n        // for(Integer l : list) {\n        //     System.out.print(l + \" \");\n        // }\n\n        int i = 0;\n        int j = list.size() - 1;\n        while(i < j) {\n            if(list.get(i) != list.get(j)) return false;\n            i++;\n            j--;\n        }\n\n        return true;\n    }\n}\n```\n\n#### 方法二：半翻转链表 + 双指针\n\n```java\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if(head == null) return true;\n        if(head != null && head.next == null) return true;\n        \n        // 快慢指针找中点\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode pre = null;    \n        while(fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        pre.next = null;\n        \n        ListNode l2 = reverse(slow);\n        while(head != null) {\n            if(head.val != l2.val) return false;\n            head = head.next;\n            l2 = l2.next;\n        }\n\n        return true;\n    }\n\n    public ListNode reverse(ListNode head) {\n        ListNode next = null;\n        ListNode pre = null;\n        while(head != null) {\n            next = head.next;\n            head.next = pre;\n            pre = head;\n            head = next;\n        }\n\n        return pre;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"102-143. 重排链表.md","path":"002-数据结构与算法/012-额外题目/02-链表/102-143. 重排链表.md","content":"### [143. 重排链表](https://leetcode.cn/problems/reorder-list/)\n\n#### 方法一：方法二：半翻转链表 + 双指针\n\n借鉴[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        if(head == null) return;\n        if(head != null && head.next == null) return;\n\n        // 在中点切割链表，奇数时长度l2 > l1\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode pre = head;\n        while(fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        pre.next = null;\n        ListNode l1 = head;\n\n        // 翻转l2 & 重组链表\n        ListNode l2 = reverse(slow);\n        ListNode dummyHead = new ListNode(0);\n        ListNode cur = dummyHead;\n        while(l1 != null) {\n            ListNode l1Next = l1.next;\n            cur.next = l1;\n            System.out.print(cur.next.val + \" \");\n            l1 = l1Next;\n\n            ListNode l2Next = l2.next;\n            cur.next.next = l2;\n            System.out.print(cur.next.next.val + \" \");\n            l2 = l2Next;\n\n            cur = cur.next.next;\n        }\n        head = dummyHead.next;  // 最后一次循环时，cur.next.next = l2, 即l2之后的所有元素都挂在后面，所以不需要单独处理l2数量 > l1的情况\n    }\n\n    public ListNode reverse(ListNode head) {\n        ListNode pre = null;\n        ListNode next = null;\n        while(head != null) {\n            next = head.next;\n            head.next = pre;\n            pre = head;\n            head = next;\n        }\n\n        return pre;\n    }\n}\n```\n\n优化\n\n```java\nclass Solution {\n    public void reorderList(ListNode head) {\n        if(head == null) return;\n        if(head != null && head.next == null) return;\n\n        // 在中点切割链表，奇数时长度l1 > l2\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode l1 = head;\n        ListNode l2 = slow.next;\n        slow.next = null;\n        \n\n        // 翻转l2 & 重组链表\n        l2 = reverse(l2);\n \n        while(l2 != null) {\n            ListNode l1Next = l1.next;\n            l1.next = l2;\n            l1 = l1Next;\n\n            ListNode l2Next = l2.next;\n            l2.next = l1;\n            l2 = l2Next;\n        }\n    }\n\n    public ListNode reverse(ListNode head) {\n        ListNode pre = null;\n        ListNode next = null;\n        while(head != null) {\n            next = head.next;\n            head.next = pre;\n            pre = head;\n            head = next;\n        }\n\n        return pre;\n    }\n}\n```\n\n#### 方法二：数组\n\n#### 方法三：双端队列\n\n方法二的进阶版\n\nhttps://programmercarl.com/0143.重排链表.html#思路","timestamp":1694699764227},{"name":"103-141. 环形链表.md","path":"002-数据结构与算法/012-额外题目/02-链表/103-141. 环形链表.md","content":"### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if(head == null) return false;\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while(fast != null && fast.next != null) {\n            if(slow == fast) return true;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        return false;\n    }\n}\n```\n\n优化\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast) return true;\n        }\n\n        return false;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"104-面试题 02.07. 链表相交.md","path":"002-数据结构与算法/012-额外题目/02-链表/104-面试题 02.07. 链表相交.md","content":"### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)\n\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n\n        ListNode l1 = headA;\n        ListNode l2 = headB;\n        while(l1 != l2) {\n            l1 = l1 == null ? headB : l1.next;\n            l2 = l2 == null ? headA : l2.next;\n        }\n\n        return l1;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-205. 同构字符串.md","path":"002-数据结构与算法/012-额外题目/03-哈希表/100-205. 同构字符串.md","content":"### [205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)\n\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        Map<Character, Character> map1 = new HashMap<>();\n        Map<Character, Character> map2 = new HashMap<>();\n\n        for(int i = 0, j = 0; i < s.length(); i++, j++) {\n            Character chS = s.charAt(i);\n            Character chT = t.charAt(j);\n            // 构建s对t的映射关系\n            if(!map1.containsKey(chS)) {\n                map1.put(chS, chT);\n            }\n\t\t\t\t\t\t\n            // 构建t对s的映射关系\n            if(!map2.containsKey(chT)) {\n                map2.put(chT, chS);\n            }\n\n          \t// 每个字母只能构建一种映射关系，如果出现映射结果不一样，则false\n            if(map1.get(chS) != chT || map2.get(chT) != chS) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"101-1002. 查找共用字符.md","path":"002-数据结构与算法/012-额外题目/03-哈希表/101-1002. 查找共用字符.md","content":"### [1002. 查找共用字符](https://leetcode.cn/problems/find-common-characters/)\n\n统计每个字符串中每个字符出现个次数，取最小值。\n\n![image-20230118165002314](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/01/18/165002167403180216740318024853uuWNu-image-20230118165002314.png)\n\n```java\nclass Solution {\n    public List<String> commonChars(String[] words) {\n        List<String> res = new ArrayList<>();\n        if(words.length == 0) return res;\n        \n        int[] hash = new int[26];\n        Arrays.fill(hash, Integer.MAX_VALUE);\n        for(int i = 0; i < words.length; i++) {\n            String word = words[i];\n\n            int[] hashTmp = new int[26];\n            for(int k = 0; k < word.length(); k++) {\n                char ch = word.charAt(k);\n                hashTmp[ch - \'a\']++;\n            }\n\n            for(int j = 0; j < 26; j++) {\n                hash[j] = Math.min(hash[j], hashTmp[j]);\n            }\n        }\n\n        for(int i = 0; i < 26; i++) {\n            while(hash[i] != 0) {\n                char ch = (char)(i + \'a\');\n                res.add(String.valueOf(ch));\n                hash[i]--;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-925. 长按键入.md","path":"002-数据结构与算法/012-额外题目/04-字符串/100-925. 长按键入.md","content":"### [925. 长按键入](https://leetcode.cn/problems/long-pressed-name/)\n\n```java\nclass Solution {\n    public boolean isLongPressedName(String name, String typed) {\n        int i = 0;\n        int j = 0;\n        while(i < name.length() && j < typed.length()) {\n            if(name.charAt(i) == typed.charAt(j)) {\n                i++;\n            } else {  // 不匹配： 1 长按导致  2 字符不同，即错误\n                if(j == 0) {    // 首位不匹配\n                    return false;\n                } else if(j > 0 && typed.charAt(j) != typed.charAt(j - 1)) {  // 不匹配的原因不是因为长按\n                    return false;\n                }\n            }\n            j++;\n        }\n\n        // 判断typed最后一位是否是长按\n        while(j < typed.length()) {\n            if(typed.charAt(j - 1) == typed.charAt(j)) {\n                j++;\n            } else {\n                return false;\n            }  \n        }\n\n        return i == name.length() && j == typed.length();\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"101-844. 比较含退格的字符串.md","path":"002-数据结构与算法/012-额外题目/04-字符串/101-844. 比较含退格的字符串.md","content":"### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)\n\n#### 方法一：模拟栈\n\n```java\nclass Solution {\n    public boolean backspaceCompare(String s, String t) {\n        StringBuilder sb1 = new StringBuilder();\n        for(char ch : s.toCharArray()) {\n            if(ch != \'#\') {\n                sb1.append(ch);\n            } else if(sb1.length() > 0){\n                sb1.deleteCharAt(sb1.length() - 1);\n            }\n        }\n\n        StringBuilder sb2 = new StringBuilder();\n        for(char ch : t.toCharArray()) {\n            if(ch != \'#\') {\n                sb2.append(ch);\n            } else if(sb2.length() > 0){\n                sb2.deleteCharAt(sb2.length() - 1);\n            }\n        }\n\n        // System.out.println(sb1.toString());\n        // System.out.println(sb2.toString());\n        return sb1.toString().equals(sb2.toString());\n    }\n}\n```\n\n#### 方法二：双指针\n\n思路：使用快慢双指针分别消除字符串中的#再比较\n\n\n\n#### 方法三：倒叙双指针\n\ni, j 分别指向两个字符串的末尾，从后至前遍历，遇到#就计数count++，遇到不同则count--, 为0时return false\n\n","timestamp":1694699764227},{"name":"00-排序算法.md","path":"002-数据结构与算法/013-排序算法/00-排序算法.md","content":"![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/08/17091616941641561694164156706ROtvY3-sort.png)\n\n![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/08/17102616941642261694164226447LsBsQv-0B319B38-B70E-4118-B897-74EFA7E368F9.png)\n\n\n\n练习题：https://leetcode.cn/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/\n\n参考：https://www.runoob.com/w3cnote/ten-sorting-algorithm.html","timestamp":1694699764227},{"name":"01-概述.md","path":"002-数据结构与算法/013-排序算法/01-归并排序及应用/01-概述.md","content":"https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/gui-bing-p-1387f/","timestamp":1694699764227},{"name":"02-归并排序.md","path":"002-数据结构与算法/013-排序算法/01-归并排序及应用/02-归并排序.md","content":"### [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)\n\n归并排序：先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并。\n\n```java\nclass Solution {\n    int[] tmp;\n    public int[] sortArray(int[] nums) {\n        tmp = new int[nums.length];\n        sort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void sort(int[] nums, int l, int r) {\n        if(l == r) return;\n        int mid = l + (r - l) / 2;\n        sort(nums, l, mid);\n        sort(nums, mid + 1, r);\n        merge(nums, l, mid, r);\n    }\n\n    public void merge(int[] nums, int l, int mid, int r) {\n        for(int i = l; i <= r; i++) {\n            tmp[i] = nums[i];\n        }\n\n        int p1 = l;\n        int p2 = mid + 1;\n        int index = l;\n        while(p1 <= mid && p2 <= r) {\n            if(tmp[p1] < tmp[p2]) nums[index++] = tmp[p1++];\n            else nums[index++] = tmp[p2++];\n        }\n        while(p1 <= mid) nums[index++] = tmp[p1++];\n        while(p2 <= r) nums[index++] = tmp[p2++];\n\n    }\n}\n```\n\n\n\n","timestamp":1694699764227},{"name":"03-剑指 Offer 51. 数组中的逆序对.md","path":"002-数据结构与算法/013-排序算法/01-归并排序及应用/03-剑指 Offer 51. 数组中的逆序对.md","content":"### [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)\n\n```\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\n\n输入: [7,5,6,4]\n输出: 5\n```\n\n解法同：[315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)\n\n#### 解法1\n\n```\n归并过程中，左边的临时数组元素赋值到nums时更新计数\n```\n\n写法1\n\n```java\nclass Solution {\n    int res = 0;\n\n    public int reversePairs(int[] nums) {\n        sort(nums, 0, nums.length - 1);\n        // System.out.println(Arrays.toString(nums));\n        return res;\n    }\n\n    public void sort(int[] nums, int l, int r) {\n        if(l >= r) return;\n        int mid = l + ((r - l) >> 1);\n        sort(nums, l, mid);\n        sort(nums, mid + 1, r);\n        merge(nums, l, mid, r);\n    }\n\n    public void merge(int[] nums, int l, int mid, int r) {\n        int[] tmp = new int[nums.length];\n        for(int i = l; i <= r; i++) tmp[i] = nums[i];\n\n        int p1 = l, p2 = mid + 1;\n        int index = l;\n        while(p1 <= mid && p2 <= r) {\n            if(tmp[p1] <= tmp[p2]) {\n                nums[index++] = tmp[p1++];\n                res += p2 - (mid + 1);\t\t// // 57和468合并，5小于6，说明6的左边都小于5\n            } else {\n                nums[index++] = tmp[p2++];\n            }\n        }\n\n        while(p1 <= mid) {\n            nums[index++] = tmp[p1++];\n            res += p2 - (mid + 1);\n        }\n        while(p2 <= r) nums[index++] = tmp[p2++];\n    }\n}\n```\n\n写法2 (为主，解法2更优)\n\n```java\nclass Solution {\n    int res;\n    int[] tmp;\n\n    public int reversePairs(int[] nums) {\n        res = 0;\n        tmp = new int[nums.length];\n        sort(nums, 0, nums.length - 1);\n        return res;\n    }\n\n    public void sort(int[] nums, int l, int r) {\n        if(l >= r) return;\n        int mid = l + ((r - l) >> 1);\n        sort(nums, l, mid);\n        sort(nums, mid + 1, r);\n        merge(nums, l, mid, r);\n    }\n\n    public void merge(int[] nums, int l, int mid, int r) {\n        for(int i = l; i <= r; i++) tmp[i] = nums[i];\n        \n        int i = l, j = mid + 1;\n        for(int p = l; p <= r; p++) {\n            if(i == mid + 1) {\n                nums[p] = tmp[j++];\n            } else if(j == r + 1) {\n                nums[p] = tmp[i++];\n                res += j - mid  - 1;        // 计数1    // 57和468合并，5小于6，说明6的左边都小于5\n            } else if(tmp[i] <= tmp[j]) {\n                nums[p] = tmp[i++];\n                res += j - mid  - 1;        // 计数2\n            } else {\n                nums[p] = tmp[j++];\n            }\n        }\n    }\n}\n```\n\n#### 解法2 (为主，可优化)\n\n```\n归并过程中，右边的临时数组元素赋值到nums时更新计数\n```\n\n```java\nclass Solution {\n    int res;\n    int[] tmp;\n\n    public int reversePairs(int[] nums) {\n        res = 0;\n        tmp = new int[nums.length];\n        sort(nums, 0, nums.length - 1);\n        return res;\n    }\n\n    public void sort(int[] nums, int l, int r) {\n        if(l >= r) return;\n        int mid = l + ((r - l) >> 1);\n        sort(nums, l, mid);\n        sort(nums, mid + 1, r);\n        merge(nums, l, mid, r);\n    }\n\n    public void merge(int[] nums, int l, int mid, int r) {\n        for(int i = l; i <= r; i++) tmp[i] = nums[i];\n        \n        int i = l, j = mid + 1;\n        for(int p = l; p <= r; p++) {\n            if(i == mid + 1) {\n                nums[p] = tmp[j++];\n            } else if(j == r + 1) {\n                nums[p] = tmp[i++];\n            } else if(tmp[i] <= tmp[j]) {\n                nums[p] = tmp[i++];\n            } else {\n                nums[p] = tmp[j++];\n\n                res += (mid - i + 1);   // 579与468合并，5大于4 => 579都大于4\n            }\n        }\n    }\n}\n```\n\n#### 优化\n\n写法1\n\n```java\nclass Solution {\n    int res;\n    int[] tmp;\n\n    public int reversePairs(int[] nums) {\n        res = 0;\n        tmp = new int[nums.length];\n        sort(nums, 0, nums.length - 1);\n        return res;\n    }\n\n    public void sort(int[] nums, int l, int r) {\n        if(l >= r) return;\n        int mid = l + ((r - l) >> 1);\n        sort(nums, l, mid);\n        sort(nums, mid + 1, r);\n        merge(nums, l, mid, r);\n    }\n\n    public void merge(int[] nums, int l, int mid, int r) {\n        for(int i = l; i <= r; i++) tmp[i] = nums[i];\n\n        // 计数。记录上一次比较的结果，即为下一次的开始\n        // 579和468合并，5比较完end就在6，6之前的数都是比7小的，不用每次都从4开始找\n        int end = mid + 1;\n        for(int i = l; i <= mid; i++) {\n            while(end <= r && nums[i] > nums[end]) end++;\n\n            res += (end - mid - 1);\n        }\n        \n        int i = l, j = mid + 1;\n        for(int p = l; p <= r; p++) {\n            if(i == mid + 1) {\n                nums[p] = tmp[j++];\n            } else if(j == r + 1) {\n                nums[p] = tmp[i++];\n            } else if(tmp[i] <= tmp[j]) {\n                nums[p] = tmp[i++];\n            } else {\n                nums[p] = tmp[j++];\n            }\n        }\n    }\n\n}\n```\n写法2\n```java\nclass Solution {\n    int res = 0;\n    int[] tmp;\n    public int reversePairs(int[] nums) {\n        tmp = new int[nums.length];\n        sort(nums, 0, nums.length - 1);\n        // System.out.println(Arrays.toString(nums));\n        return res;\n    }\n\n    public void sort(int[] nums, int l, int r) {\n        if(l >= r) return;\n        int mid = l + ((r - l) >> 1);\n        sort(nums, l, mid);\n        sort(nums, mid + 1, r);\n        merge(nums, l, mid, r);\n    }\n\n    public void merge(int[] nums, int l, int mid, int r) {\n        for(int i = l; i <= r; i++) tmp[i] = nums[i];\n\n        int p1 = l, p2 = mid + 1;\n        for(; p1 <= mid; p1++) {\n            while(p2 <= r && nums[p1] > nums[p2]) p2++;\n            res += p2 - (mid + 1);\n        }\n\n        p1 = l;\n        p2 = mid + 1;\n        for(int index = l; index <= r; index++) {\n            if(p1 == mid + 1) {  // 左边遍历完\n                nums[index] = tmp[p2++];\n            } else if(p2 == r + 1) {     // 右边遍历完\n                nums[index] = tmp[p1++];\n            } else if(tmp[p1] <= tmp[p2]) {\n                nums[index] = tmp[p1++];\n            } else {\n                nums[index] = tmp[p2++];\n            }\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-快速排序.md","path":"002-数据结构与算法/013-排序算法/02-快排及应用/02-快速排序.md","content":"#### [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)\n\n取随机数作为partition中的pivot\n\n```java\nimport java.util.Random;\n\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        quickSort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void quickSort(int[] nums, int l, int r) {\n        if (l >= r) return;\n        int pivot = partition(nums, l, r);\n        quickSort(nums, l, pivot - 1);\n        quickSort(nums, pivot + 1, r);\n    }\n\n    public int partition(int[] nums, int l, int r) {\n        int randomIndex = new Random().nextInt(r - l + 1) + l;\n        swap(nums, l, randomIndex); // 将随机选取的数交换到首位，作为pivot\n        int pivot = nums[l];\n      \n        int i = l, j = r;\n        while (i < j) {\n            while (j > i && nums[j] >= pivot) j--;\n            nums[i] = nums[j];\n\n            while (i < j && nums[i] <= pivot) i++;\n            nums[j] = nums[i];\n        }\n        nums[i] = pivot;\n\n        return i;\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n\n```\n\n","timestamp":1694699764227},{"name":"03-剑指 Offer 45. 把数组排成最小的数.md","path":"002-数据结构与算法/013-排序算法/02-快排及应用/03-剑指 Offer 45. 把数组排成最小的数.md","content":"### [剑指 Offer 45. 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)\n\n```\n输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n输入: [3,30,34,5,9]\n输出: \"3033459\"\n```\n\n使用Arrays.sort算法\n\n```java\nclass Solution {\n    public String minNumber(int[] nums) {\n        String[] strs = new String[nums.length];\n        for(int i = 0; i < nums.length; i++) {\n            strs[i] = Integer.toString(nums[i]);\n        }\n\n        Arrays.sort(strs, (a, b)->{\n            return (a + b).compareTo(b + a);\n        });\n\n        return String.join(\"\", strs);\n    }\n}\n```\n\n快排\n\n```java\nclass Solution {\n    public String minNumber(int[] nums) {\n        String[] strs = new String[nums.length];\n        for(int i = 0; i < nums.length; i++) {\n            strs[i] = Integer.toString(nums[i]);\n        }\n\n        quickSort(strs, 0, strs.length - 1);\n\n        return String.join(\"\", strs);\n    }\n\n    public void quickSort(String[] strs, int l, int r) {\n        if(l >= r) return;\n        int pivot = paritition(strs, l, r);\n        quickSort(strs, l, pivot - 1);\n        quickSort(strs, pivot + 1, r);\n    }\n\n    public int paritition(String[] strs, int l, int r) {\n        int index = new Random().nextInt(r - l + 1) + l;\n        swap(strs, l, index);\n\n        String pivot = strs[l];\n        while(l < r) {\n            while(l < r && (strs[r] + pivot).compareTo(pivot + strs[r]) >= 0) r--;\n            strs[l] = strs[r];\n\n            while(l < r && (strs[l] + pivot).compareTo(pivot + strs[l]) <= 0) l++;\n            strs[r] = strs[l];\n        }\n        strs[l] = pivot;\n\n        return l;\n    }\n\n    public void swap(String[] strs, int i, int j) {\n        String tmp = strs[i];\n        strs[i] = strs[j];\n        strs[j] = tmp;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/)","timestamp":1694699764227},{"name":"04-剑指 Offer 40. 最小的k个数.md","path":"002-数据结构与算法/013-排序算法/02-快排及应用/04-剑指 Offer 40. 最小的k个数.md","content":"### [剑指 Offer 40. 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)\n\n```\n输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n```\n#### 方法1: 排序\n\n```java\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n        int[] res = new int[k];\n        Arrays.sort(arr);\n        for(int i = 0; i < k; i++) {\n            res[i] = arr[i];\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n#### 方法2: 大根堆\n\n```java\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->{\n            return b - a;\n        });\n\n        for(int i = 0; i < arr.length; i++) {\n            pq.add(arr[i]);\n            if(pq.size() > k) {\n                pq.poll();\n            }\n        }\n\n\n        int[] res = new int[k];\n        for(int i = 0; i < k; i++) {\n            res[i] = pq.poll();\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n#### 方法3: 快排\n\n```java\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n        if(k >= arr.length) return arr;\n        return quickSort(arr, 0, arr.length - 1, k);\n    }\n\n    public int[] quickSort(int[] nums, int l, int r, int k) {\n        int pivot = partition(nums, l, r);\n        if(pivot > k) return quickSort(nums, l, r - 1, k);\n        if(pivot < k) return quickSort(nums, l + 1, r, k);\n        return Arrays.copyOf(nums, k);\n    }\n\n    public int partition(int[] nums, int l, int r) {\n        int index = new Random().nextInt(r - l + 1) + l;\n        int pivot = nums[index];\n        swap(nums, index, l);\n\n        int i = l, j = r;\n        while(i < j) {\n            while(i < j && nums[j] >= pivot) j--;\n            nums[i] = nums[j];\n\n            while(i < j && nums[i] <= pivot) i++;\n            nums[j] = nums[i];\n        }\n        nums[i] = pivot;\n\n        return i;\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"03-插入排序.md","path":"002-数据结构与算法/013-排序算法/03-插入排序.md","content":"## 插入排序\n\n不带哨兵\n\n```java\nimport java.util.Arrays;\n\npublic class InsertSort {\n    public static void main(String[] args) {\n        int[] nums = new int[]{1, 3, 2, 5, 4};\n        insertSort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n\n    public static void insertSort(int[] nums) {\n        for(int i = 1; i < nums.length; i++) {\n            int tmp = nums[i];\n            int j;\n            for(j = i - 1; j >= 0 && tmp < nums[j]; j--) {\n                nums[j + 1] = nums[j];\n            }\n\n            nums[j + 1] = tmp;\n        }\n    }\n}\n```\n\n带哨兵\n","timestamp":1694699764227},{"name":"04-堆排序.md","path":"002-数据结构与算法/013-排序算法/04-堆排序.md","content":"## 大排序\n\n升序\n\n```java\npublic class HeapSort {\n\n    public static void heapSort(int[] arr) {\n        int n = arr.length;\n\n        // 构建大根堆\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            heapify(arr, n, i);\n        }\n\n        // 堆排序\n        for (int i = n - 1; i >= 0; i--) {\n            int temp = arr[0];\n            arr[0] = arr[i];\n            arr[i] = temp;\n\n            // 每次将堆头 放到数组的最后一位\n            heapify(arr, i, 0);\n        }\n    }\n\n    public static void heapify(int[] arr, int n, int i) {\n        int largest = i; // 假设根节点是最大的。\n        int left = 2 * i + 1;   // 左子树索引\n        int right = 2 * i + 2;  // 右子树索引\n\n        // 如果左子节点大，则更新最大节点索引为左子节点的索引。\n        if (left < n && arr[left] > arr[largest]) {\n            largest = left;\n        }\n\n        // 如果右子节点更大，则更新最大节点索引。\n        if (right < n && arr[right] > arr[largest]) {\n            largest = right;\n        }\n\n        // 交换，使得根节点是最大的\n        if (largest != i) {\n            int swap = arr[i];\n            arr[i] = arr[largest];\n            arr[largest] = swap;\n\n            // 递归调用heapify方法来重新堆化被影响的子树。\n            heapify(arr, n, largest);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {12, 11, 13, 5, 6, 7};\n        heapSort(arr);\n        for (int i : arr) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n\n```\n\n## 小根堆\n\n降序\n\n```java\npublic class HeapSort {\n    public static void main(String[] args) {\n        int[] arr = {12, 11, 13, 5, 6, 7};\n        int n = arr.length;\n\n        HeapSort ob = new HeapSort();\n        ob.sort(arr);\n\n        System.out.println(\"Sorted array is\");\n        for (int i : arr) {\n            System.out.print(i + \" \");\n        }\n    }\n\n    public void sort(int arr[]) {\n        int n = arr.length;\n\n        // Build heap (rearrange array)\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            minHeapify(arr, n, i);\n        }\n\n        // One by one extract an element from heap\n        for (int i = n - 1; i >= 0; i--) {\n            // Move current root to end\n            int temp = arr[0];\n            arr[0] = arr[i];\n            arr[i] = temp;\n\n            // call max heapify on the reduced heap\n            minHeapify(arr, i, 0);\n        }\n    }\n\n    // To heapify a subtree rooted with node i which is\n    // an index in arr[]. n is size of heap\n    void minHeapify(int arr[], int n, int i) {\n        int smallest = i;  // Initialize smallest as root\n        int left = 2 * i + 1;  // left = 2*i + 1\n        int right = 2 * i + 2;  // right = 2*i + 2\n\n        // If left child is smaller than root\n        if (left < n && arr[left] < arr[smallest]) {\n            smallest = left;\n        }\n\n        // If right child is smaller than smallest so far\n        if (right < n && arr[right] < arr[smallest]) {\n            smallest = right;\n        }\n\n        // If smallest is not root\n        if (smallest != i) {\n            int swap = arr[i];\n            arr[i] = arr[smallest];\n            arr[smallest] = swap;\n\n            // Recursively heapify the affected sub-tree\n            minHeapify(arr, n, smallest);\n        }\n    }\n}\n\n```\n\n","timestamp":1694699764227},{"name":"05-选择排序.md","path":"002-数据结构与算法/013-排序算法/05-选择排序.md","content":"算法步骤\n\n```\n首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。\n再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n重复第二步，直到所有元素均排序完毕。\n```\n\n```java\npublic class SelectionSort {\n\n    public static void main(String[] args) {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n\n        SelectionSort ob = new SelectionSort();\n        ob.selectionSort(arr);\n\n        System.out.println(\"Sorted array\");\n    }\n\n    void selectionSort(int arr[]) {\n        int n = arr.length;\n\n        // One by one move boundary of unsorted subarray\n        for (int i = 0; i < n - 1; i++) {\n            // Find the minimum element in unsorted array\n            int minIdx = i;\n            for (int j = i + 1; j < n; j++)\n                if (arr[j] < arr[minIdx])\n                    minIdx = j;\n\n            // Swap the found minimum element with the first element\n            int temp = arr[minIdx];\n            arr[minIdx] = arr[i];\n            arr[i] = temp;\n        }\n    }\n\n}\n\n```\n\n","timestamp":1694699764227},{"name":"06-冒泡排序.md","path":"002-数据结构与算法/013-排序算法/06-冒泡排序.md","content":"冒泡排序\n\n```java\nimport java.util.Arrays;\n\npublic class BubbleSort {\n    public static void main(String[] args) {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        BubbleSort ob = new BubbleSort();\n        ob.bubbleSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    void bubbleSort(int arr[]) {\n        int n = arr.length;\n        boolean swapped;\n\n        for (int i = 0; i < n - 1; i++) {\n            swapped = false;\n\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    // swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n\n            // If no two elements were swapped in the inner loop, then the list is already sorted\n            if (!swapped) break;\n        }\n    }\n}\n\n```\n\n","timestamp":1694699764227},{"name":"07-希尔排序.md","path":"002-数据结构与算法/013-排序算法/07-希尔排序.md","content":"希尔排序（Shell Sort）是插入排序的一种变体，它首先比较相距较远的元素，然后逐步减少间距。\n\n```java\npublic class ShellSort {\n\n    public static void main(String[] args) {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        shellSort(arr);\n        printArray(arr);\n    }\n\n    public static void shellSort(int[] array) {\n        int n = array.length;\n\n        // Start with a big gap, then reduce the gap\n        for (int gap = n / 2; gap > 0; gap /= 2) {\n            // Do a gapped insertion sort for this gap size.\n            for (int i = gap; i < n; i += 1) {\n                // add a[i] to the elements that have been gap sorted\n                int temp = array[i];\n\n                // shift earlier gap-sorted elements up until the correct location for a[i] is found\n                int j;\n                for (j = i; j >= gap && array[j - gap] > temp; j -= gap) {\n                    array[j] = array[j - gap];\n                }\n\n                // put temp (the original a[i]) in its correct location\n                array[j] = temp;\n            }\n        }\n    }\n\n    public static void printArray(int[] array) {\n        for (int j : array) {\n            System.out.print(j + \" \");\n        }\n        System.out.println();\n    }\n}\n\n```\n\n","timestamp":1694699764227},{"name":"01-22. 括号生成.md","path":"002-数据结构与算法/014-hot100/02-回溯/01-22. 括号生成.md","content":"### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)\n\n#### 方法一： dfs\n\n```java\nclass Solution {\n\n    List<String> res = new ArrayList<>();\n\n    public List<String> generateParenthesis(int n) {\n        dfs(\"\", n, n);\n        return res;\n    }\n\n    // l: 可使用的(数  r: 可使用的)数\n    public void dfs(String str, int l, int r) {\n        if(l == 0 && r == 0) {\n            res.add(str);\n            return;\n        }\n\n        if(l < 0 || r < l) return;\t\t// r < l 说明出现了 ())类似情况\n\n        dfs(str + \"(\", l - 1, r);\n        dfs(str + \")\", l, r - 1);\n\n    }\n}\n```\n\n#### 方法二： 回溯法\n\n```java\nclass Solution {\n\n    List<String> res = new ArrayList<>();\n\n    public List<String> generateParenthesis(int n) {\n        backtrack(new StringBuilder(), 0, 0, n);\n        return res;\n    }\n\n    // l: 已用的(数  r: 已用的)数\n    public void backtrack(StringBuilder sb, int l, int r, int n) {\n        if(sb.length() == n * 2) {\n            res.add(sb.toString());\n            return;\n        }\n\n        if(l < n) {\n            sb.append(\"(\");\n            backtrack(sb, l + 1, r, n);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n\n        if(r < l) {\n            sb.append(\")\");\n            backtrack(sb, l, r + 1, n);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-79. 单词搜索.md","path":"002-数据结构与算法/014-hot100/02-回溯/02-79. 单词搜索.md","content":"### [79. 单词搜索](https://leetcode.cn/problems/word-search/)\n\n![image-20230602131905020](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/13190516856831451685683145196AAhj0z-image-20230602131905020.png)\n\n#### 方法1: 回溯\n\n```java\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        int h = board.length, w = board[0].length;\n        boolean[][] visited = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                boolean flag = check(board, visited, i, j, word, 0);\n                if (flag) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) {\n        if (board[i][j] != s.charAt(k)) {\n            return false;\n        } else if (k == s.length() - 1) {\n            return true;\n        }\n        visited[i][j] = true;\n        int[][] directions = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };\n        boolean result = false;\n        for (int[] dir : directions) {\n            int newi = i + dir[0], newj = j + dir[1];\n            if (newi >= 0 && newi < board.length && newj >= 0 && newj < board[0].length) {\n                if (!visited[newi][newj]) {\n                    boolean flag = check(board, visited, newi, newj, s, k + 1);\n                    if (flag) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n        visited[i][j] = false;\n        return result;\n    }\n}\n\n作者：LeetCode-Solution\n链接：https://leetcode.cn/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n优化：\n\n-   直接在原数组上修改，无须visited数组\n\n-   先污染，后治理\n\n```java\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[0].length; j++) {\n                if(board[i][j] == word.charAt(0)) {\n                    boolean flag = dfs(board, word, 0, i, j);\n                    if(flag) return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public boolean dfs(char[][] board, String word, int index, int r, int c) {\n        if(index == word.length()) return true;\n        if(r < 0 || r >= board.length || c < 0 || c >= board[0].length) return false;\n        if(board[r][c] != word.charAt(index)) return false;\n\n        char ch = board[r][c];  \n        board[r][c] = 0;    // 防止重复遍历走回头路\n\n        // 先污染，后治理，在下一层判断是否越界\n        boolean res = dfs(board, word, index + 1, r - 1, c)\n                   || dfs(board, word, index + 1, r + 1, c)\n                   || dfs(board, word, index + 1, r, c - 1)\n                   || dfs(board, word, index + 1, r, c + 1);\n\n        // 回溯\n        board[r][c] = ch;\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-32. 最长有效括号.md","path":"002-数据结构与算法/014-hot100/03-动态规划/01-32. 最长有效括号.md","content":"### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)\n\n```\n给你一个只包含 \'(\' 和 \')\' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n\n输入：s = \"(()\"\n输出：2\n解释：最长有效括号子串是 \"()\"\n```\n\n#### 方法1: dp\n\ndp含义\n\n```\ndp[i]: 以i为结尾的，最长有效括号数\n```\n\n递推公式\n\n```\n情况1\n...()\n省略号的长度为dp[i - 2], 即dp[i] = dp[i - 2] + 2\ni - 2  < 0时 dp[i] = 2\n\n情况2\n...((...))\n难点：如何找到中间部分的左括号\n中间有效括号长度：dp[i - 1]\n中间有效括号左边界: leftIndex = i - dp[i - 1] - 1\ns[i]需要和 s[leftIndex - 1] 匹配\n\ndp[i] = 中间长度 + 2 + 左边省略号长度\n\t\t  = 匹配的()长度 + 左边省略号长度\n\t\t  = (i - leftIndex + 1) + dp[leftIndex - 2]\n```\n\n```java\n    public int longestValidParentheses(String s) {\n        int n = s.length();\n        if(n == 0) return 0;\n\n        int[] dp = new int[n];\n        dp[0] = 0;\n\n        int res = 0;\n        for(int i = 1; i < n; i++) {\n            if(s.charAt(i) == \')\') {\n                if(s.charAt(i - 1) == \'(\') {\n                    if(i - 2 <= 0) {\n                        dp[i] = 2;\n                    } else {\n                        dp[i] = dp[i - 2] + 2;\n                    }\n                     \n                } else if(dp[i - 1] > 0) {\n                    if(i - dp[i - 1] - 1 >= 0 && s.charAt(i - dp[i - 1] - 1) == \'(\') {\n                        dp[i] = i - (i - dp[i - 1] - 1) + 1;\n                        if(i - dp[i - 1] - 2 >= 0) {\n                            dp[i] += dp[i - dp[i - 1] - 2];\n                        }\n                    }\n                }\n     \n                res = Math.max(res, dp[i]);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n>   参考：https://leetcode.cn/problems/longest-valid-parentheses/solution/dong-tai-gui-hua-si-lu-xiang-jie-c-by-zhanganan042/\n\n\n\n#### 方法2: dp + 栈 （主要）\n\n用栈简化了找左括号的过程\n\n```java\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Deque<Integer> stack = new LinkedList<>();\n        int n = s.length();\n        int[] dp = new int[n + 1]; // dp[i] 表示以i-1为结尾的最长有效数\n        int res = 0;\n        for(int i = 0; i < n; i++) {\n            char ch = s.charAt(i);\n            if(ch == \'(\') {\n                stack.push(i);  // 记录(的下标\n                dp[i + 1] = 0;  // 以(为结尾，一定不是有效的\n            } else {\n                if(!stack.isEmpty()) {\n                    int left = stack.pop();\n                    int len = (i - left + 1) + dp[left];    // dp[left]表示left-1为结尾的最长有效数\n                    res = Math.max(len, res);\n                    dp[i + 1] = len;\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n>   参考： https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-jie--306f6\n\n","timestamp":1694699764227},{"name":"04-31. 下一个排列.md","path":"002-数据结构与算法/014-hot100/04-31. 下一个排列.md","content":"### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)\n\n```java\n123456\n123465\n123546\n...\n654321\n\nclass Solution {\n    // 12345 12354 12435 12453\n    public void nextPermutation(int[] nums) {\n        // 从后向前，找第一个[i, j]，其中nums[i] < nums[j]\n        int n = nums.length;\n        int i = n - 2;\n        int j = n - 1;\n        while(i >= 0 && nums[i] >= nums[j]) {\n            i--;\n            j--;\n        }\n\n        // 从后向前，找第一个比nums[i]大的，交换\n        if(i >= 0) {    // 不是最后一个排列, 即321已经没有比它大的了\n            int k = n - 1;\n            while(k >= j && nums[k] <= nums[i]) {\n                k--;\n            }\n            swap(nums, i, k);\n        }\n        \n        // 将[j, n - 1]逆序\n        while(j < n - 1) {\n            swap(nums, j, n - 1);\n            j++; \n            n--;\n        }\n\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n\n参考：https://leetcode.cn/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/","timestamp":1694699764227},{"name":"05-49. 字母异位词分组.md","path":"002-数据结构与算法/014-hot100/05-49. 字母异位词分组.md","content":"","timestamp":1694699764227},{"name":"33-二叉搜索树的后序遍历序列.md","path":"002-数据结构与算法/015-剑指offer/33-二叉搜索树的后序遍历序列.md","content":"### [33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)\n\n```\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n\n输入: [1,3,2,6,5]\n输出: true\n```\n\n解题关键：\n\n后序遍历结果的特点是：左边一部分是左子树，右边一部分是右子树，最后一个元素是根节点。\n\n\n\n```java\nclass Solution {\n    public boolean verifyPostorder(int[] postorder) {\n        return check(postorder, 0, postorder.length - 1);\n    }\n\n    // []\n    public boolean check(int[] postorder, int l, int r) {\n        if(l >= r) return true;\n        int rootVal = postorder[r];\n        int left = l;\n        while(left < r && postorder[left] < rootVal) left++;\n\n        int right = left;\n        while(right < r && postorder[right] > rootVal) right++;\n\n        if(right != r) return false;\n\n        return check(postorder, l, left - 1) && check(postorder, left, right - 1);\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"37-序列化二叉树.md","path":"002-数据结构与算法/015-剑指offer/37-序列化二叉树.md","content":"### [剑指 Offer 37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/)\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/08/13424316941517631694151763935xdbLCb-serdeser.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n```\n输入：root = [1,2,3,null,null,4,5]\n输出：[1,2,3,null,null,4,5]\n```\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/08/13432916941518091694151809350Q0nitL-1.jpeg\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n```java\npublic class Codec {\n\n    String SEP = \",\";\n    String NULL = \"#\";\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        preOrder(root, sb);\n        return sb.toString();\n    }\n\n    public void preOrder(TreeNode root, StringBuilder sb) {\n        if(root == null) {\n            sb.append(NULL).append(SEP);\n            return;\n        }\n\n        sb.append(root.val).append(SEP);\n        preOrder(root.left, sb);\n        preOrder(root.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        LinkedList<String> list = new LinkedList<>();\n        for(String str : data.split(SEP)) {\n            list.addLast(str);\n        }\n        return build(list);\n    }\n\n    public TreeNode build(LinkedList<String> list) {\n        if(list.isEmpty()) return null;\n\n        String first = list.removeFirst();\n        if(first.equals(NULL)) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(first));\n\n        root.left = build(list);\n        root.right = build(list);\n\n        return root;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"51-数组中的逆序对.md","path":"002-数据结构与算法/015-剑指offer/51-数组中的逆序对.md","content":"### [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)\n\n![Picture2.png](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/01/17424616935613661693561366381IYtPFM-1614274007-rtFHbG-Picture2.png)","timestamp":1694699764227},{"name":"62-圆圈中最后剩下的数字.md","path":"002-数据结构与算法/015-剑指offer/62-圆圈中最后剩下的数字.md","content":"### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)\n\n约瑟夫环问题的公式为：**f(n,k) = (f(n-1,k) + k) mod n** \n\n```java\nclass Solution {\n    // 本题的约瑟夫环问题的公式为：f(n,k) = (f(n-1,k) + k) mod n \n    public int lastRemaining(int n, int m) {\n        return f(n, m);\n    }\n\n    public int f(int n, int k) {\n        if(n == 1) return 0;\n        return (f(n - 1, k) + k) % n;\n    }\n}\n```\n\n\n\n打印依次出列的序号\n\n```java\npublic class Main {\n  public static List<Integer> josephus(int n, int m) {\n    List<Integer> result = new ArrayList<>();\n    List<Integer> people = new ArrayList<>();\n\n    // 初始化人的编号\n    for (int i = 1; i <= n; i++) {\n      people.add(i);\n    }\n\n    int idx = 0;\n    while (!people.isEmpty()) {\n      idx = (idx + m - 1) % people.size();\n      result.add(people.remove(idx));\n    }\n\n    return result;\n  }\n\n  public static void main(String[] args) {\n    int n = 10; // 总人数\n    int m = 3; // 数到m的人出列\n    List<Integer> outOrder = josephus(n, m);\n    System.out.println(\"出列的顺序为：\" + outOrder);\n  }\n}\n\n```\n\n","timestamp":1694699764227},{"name":"01-20. 有效的括号.md","path":"002-数据结构与算法/016-其他题型/01-括号问题/01-20. 有效的括号.md","content":"### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)\n\n```\n给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。\n\n\n输入：s = \"()[]{}\"\n输出：true\n```\n\n写法1\n\n```java\nclass Solution {\n    Map<Character, Character> map = new HashMap<>() { {\n        put(\')\', \'(\');\n        put(\']\', \'[\');\n        put(\'}\', \'{\');\n    } };\n\n    public boolean isValid(String s) {\n        Deque<Character> stack = new LinkedList<>();\n        for(char ch : s.toCharArray()) {\n            if(ch == \'(\' || ch == \'[\' || ch == \'{\') {\n                stack.push(ch);\n            } else {\n                if(stack.isEmpty()) return false;\n                if(map.get(ch) != stack.peek()) return false;\n                stack.pop();\n            }\n        }\n\n        return stack.isEmpty();\n    }\n}\n```\n\n\n\n写法2\n\n```java\nclass Solution {\n    public boolean isValid(String str) {\n        Stack<Character> left = new Stack<>();\n        for (char c : str.toCharArray()) {\n            if (c == \'(\' || c == \'{\' || c == \'[\')\n                left.push(c);\n            else // 字符 c 是右括号\n                if (!left.isEmpty() && leftOf(c) == left.peek())\n                    left.pop();\n                else\n                    // 和最近的左括号不匹配\n                    return false;\n        }\n        // 是否所有的左括号都被匹配了\n        return left.isEmpty();\n    }\n\n    char leftOf(char c) {\n        if (c == \'}\') return \'{\';\n        if (c == \')\') return \'(\';\n        return \'[\';\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"02-921. 使括号有效的最少添加.md","path":"002-数据结构与算法/016-其他题型/01-括号问题/02-921. 使括号有效的最少添加.md","content":"### [921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)\n\n求填补最少的括号数量，使其有效\n\n```\n输入：s = \"())\"\n输出：1\n```\n\n```java\nclass Solution {\n    public int minAddToMakeValid(String s) {\n        int res = 0;\n        int need = 0;   // 需要的右括号数\n        for(int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if(ch == \'(\') {\n                need ++;\n            } else {\n                need--;\n\n                if(need < 0) {  // 需要补左括号 ()))\n                    res++;\n                    need = 0;\n                }\n            }\n        }\n\n        return res + need;\n    }\n}\n```\n\n**当 `need == -1` 的时候意味着什么**？\n\n```\n因为只有遇到右括号 ) 的时候才会 need--，need == -1 意味着右括号太多了，所以需要插入左括号。\n比如说 s = \"))\" 这种情况，需要插入 2 个左括号，使得 s 变成 \"()()\"，才是一个有效括号串。\n```\n\n**算法为什么返回 `res + need`**？\n\n```\n因为 res 记录的左括号的插入次数，need 记录了右括号的需求，当 for 循环结束后，若 need 不为 0，那么就意味着右括号还不够，需要插入。\n比如说 s = \"))(\" 这种情况，插入 2 个左括号之后，还要再插入 1 个右括号，使得 s 变成 \"()()()\"，才是一个有效括号串。\n```\n\n[参考](https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-jie--306f6/)","timestamp":1694699764227},{"name":"03-1541. 平衡括号字符串的最少插入次数.md","path":"002-数据结构与算法/016-其他题型/01-括号问题/03-1541. 平衡括号字符串的最少插入次数.md","content":"### [1541. 平衡括号字符串的最少插入次数](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/)\n\n```\n一个\'(\'对应\'))\', 求最少数量使括号有效\n```\n\n```java\nclass Solution {\n    public int minInsertions(String s) {\n        int res = 0;\n        int need = 0;\n        for(int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if(ch == \'(\') {\n                need += 2;\n\n                if(need % 2 == 1) { // 需要补右括号：()( => ())(\n                    res++;\n                    need--;\n                }\n            } else {  \n                need--;\n\n                if(need == -1) {    // ())) ，需要补左括号，同时还需要一个右括号\n                    res++;\n                    need = 1;\n                }\n            }\n        }\n        \n        return res + need;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"04-32. 最长有效括号.md","path":"002-数据结构与算法/016-其他题型/01-括号问题/04-32. 最长有效括号.md","content":"### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)\n\n```\n给你一个只包含 \'(\' 和 \')\' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n\n输入：s = \"(()\"\n输出：2\n解释：最长有效括号子串是 \"()\"\n```\n\n参考hot100 dp\n\n```java\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Deque<Integer> stack = new LinkedList<>();\n        int n = s.length();\n        int[] dp = new int[n + 1]; // dp[i] 表示以i-1为结尾的最长有效数\n        int res = 0;\n        for(int i = 0; i < n; i++) {\n            char ch = s.charAt(i);\n            if(ch == \'(\') {\n                stack.push(i);  // 记录(的下标\n                dp[i + 1] = 0;  // 以(为结尾，一定不是有效的\n            } else {\n                if(!stack.isEmpty()) {\n                    int left = stack.pop();\n                    int len = (i - left + 1) + dp[left];    // dp[left]表示left-1为结尾的最长有效数\n                    res = Math.max(len, res);\n                    dp[i + 1] = len;\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"01-理论.md","path":"002-数据结构与算法/016-其他题型/02-丑数问题/01-理论.md","content":"参考：https://mp.weixin.qq.com/s/XXsWwDml_zHiTEFPZtbe3g","timestamp":1694699764227},{"name":"02-263. 丑数.md","path":"002-数据结构与算法/016-其他题型/02-丑数问题/02-263. 丑数.md","content":"### [263. 丑数](https://leetcode.cn/problems/ugly-number/)\n\n```java\nclass Solution {\n    public boolean isUgly(int n) {\n        if(n <= 0) return false;\n        while(n % 2 == 0) n /= 2;\n        while(n % 3 == 0) n /= 3;\n        while(n % 5 == 0) n /= 5;\n\n        return n == 1;\n    }\n}\n```\n\n参考：https://mp.weixin.qq.com/s/XXsWwDml_zHiTEFPZtbe3g","timestamp":1694699764227},{"name":"03-264. 丑数 II.md","path":"002-数据结构与算法/016-其他题型/02-丑数问题/03-264. 丑数 II.md","content":"### [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)\n\n### [剑指 Offer 49. 丑数](https://leetcode.cn/problems/chou-shu-lcof/)\n\n我们可以把丑数分为三类：2 的倍数、3 的倍数、5 的倍数。这三类丑数就好像三条有序链表，如下：\n\n(注意是没有7x2、7x3、7x5的，7不是丑数，所以每条链上并不是简单的每次都乘2、3、5，丑数 III才是)\n\n```\n能被 2 整除的丑数：\n1*2 -> 2*2 -> 3*2 -> 4*2 -> 5*2 -> 6*2 -> 8*2 ->...\n能被 3 整除的丑数：\n1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 8*3 ->...\n能被 5 整除的丑数：\n1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 8*5 ->...\n```\n\n我们如果把这三条「有序链表」合并在一起并去重，得到的就是丑数的序列，其中第`n`个元素就是题目想要的答案：\n\n```\n1 -> 1*2 -> 1*3 -> 2*2 -> 1*5 -> 3*2 -> 4*2 ->...\n```\n\n\n\n```java\nclass Solution {\n    // 理解为三个有序链表合并\n    public int nthUglyNumber(int n) {\n        int p2 = 1, p3 = 1, p5 = 1;     // 理解为三个链表头指针\n        int v2 = 1, v3 = 1, v5 = 1;     // 三个链表对应值\n\n        int[] ugly = new int[n + 1];    // 理解为合并的链表\n        int p = 1;                      // 合并链表指针\n\n        // 合并链表\n        while(p <= n) {\n            int min = Math.min(v2, Math.min(v3, v5));\n            ugly[p] = min;\n            p++;\n\n            // 前进对应有序链表上的指针\n            if(min == v2) {             // 链表2的节点为1 2 4 8 ...\n                v2 = 2 * ugly[p2];\n                p2++;\n            }\n\n            if(min == v3) {             // 链表3的节点为1 3 6 9 ...\n                v3 = 3 * ugly[p3];\n                p3++;\n            }\n\n            if(min == v5) {             // 链表5的节点为1 5 10 15 ...\n                v5 = 5 * ugly[p5];\n                p5++;\n            }\n        }\n\n        return ugly[n];\n    }\n}\n```","timestamp":1694699764227},{"name":"04-313. 超级丑数.md","path":"002-数据结构与算法/016-其他题型/02-丑数问题/04-313. 超级丑数.md","content":"### [313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/)\n\n理解为合并n个链表\n\n```java\nclass Solution {\n    // 当primes为[2,3,5]时同T264.丑数\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        // 优先队列中装三元组 int[] {value, prime, pi}\n        // 其中 value 代表链表节点的值，prime 是计算下一个节点所需的质数因子，pi 代表链表上的指针\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->{\n            // 优先级队列按照节点的值排序\n            return a[0] - b[0];\n        });\n\n        // 把多条链表的头结点加入优先级队列\n        for(int i = 0; i < primes.length; i++) {\n            pq.offer(new int[]{1, primes[i], 1});\n        }\n\n         // 可以理解为最终合并的有序链表（结果链表）\n        int[] ugly = new int[n + 1];\n        int p = 1;  //  可以理解为结果链表上的指针\n\n        while(p <= n) {\n            // 取三个链表的最小结点\n            int[] pair = pq.poll();\n            int value = pair[0];\n            int prime = pair[1];\n            int index = pair[2];\n\n            // 避免结果链表出现重复元素\n            if(value != ugly[p - 1]) {\n                // 接到结果链表上\n                ugly[p] = value;\n                p++;\n            }\n\n            // 生成下一个节点加入优先级队列\n            int[] nextPair = new int[]{ ugly[index] * prime, prime, index+1 };\n            pq.offer(nextPair);\n        }\n\n        return ugly[n];\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"05-1201. 丑数 III.md","path":"002-数据结构与算法/016-其他题型/02-丑数问题/05-1201. 丑数 III.md","content":"### [1201. 丑数 III](https://leetcode.cn/problems/ugly-number-iii/)\n\n```\n给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。\n\n丑数是可以被 a 或 b 或 c 整除的 正整数 。\n```\n\n```\n1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 7*3 ->...\n1*4 -> 2*4 -> 3*4 -> 4*4 -> 5*4 -> 6*4 -> 7*4 ->...\n1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 7*5 ->...\n\n合并为\n1*3 -> 1*4 -> 1*5 -> 2*3 -> 2*4 -> 3*3 -> 2*5 ->...\n```\n\n问题：n很大时无法通过用例\n\n```java\nclass Solution {\n    public int nthUglyNumber(int n, int a, int b, int c) {\n        long v1 = a, v2 = b, v3 = c;\n        int p = 1;\n\n        long min = Long.MIN_VALUE;\n        while(p <= n) {\n            min = Math.min(v1, Math.min(v2, v3));\n            p++;\n\n            if(min == v1) {\n                v1 += a;\n            }\n\n            if(min == v2) {\n                v2 += b;\n            }\n\n            if(min == v3) {\n                v3+= c;\n            }\n        }\n\n        return (int)min;\n    }\n}\n```\n\n[参考](https://mp.weixin.qq.com/s/XXsWwDml_zHiTEFPZtbe3g)","timestamp":1694699764227},{"name":"10-大数减法.md","path":"002-数据结构与算法/016-其他题型/10-大数减法.md","content":"```\n大数相减\n以字符串的形式读入两个数字a, b (a >= b)，编写一个函数计算它们的差(a - b)，以字符串形式返回。\n\n数据范围：每个数字的长度均为 1 <= len <= 10000\n要求：时间复杂度 O(n)\n\n示例输入：\n100 1\n\n输出：\n99\n```\n\n\n\n```\npublic class BigIntegerSubtraction {\n    public static String subtract(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        int carry = 0;\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n\n        while (i >= 0 || j >= 0) {\n            int digitA = (i >= 0) ? (a.charAt(i--) - \'0\') : 0;\n            int digitB = (j >= 0) ? (b.charAt(j--) - \'0\') : 0;\n\n            int diff = digitA - digitB - carry;\n            if (diff < 0) {\n                diff += 10;\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n\n            result.insert(0, diff);\n        }\n\n        // Remove leading zeros\n        while (result.length() > 1 && result.charAt(0) == \'0\') {\n            result.deleteCharAt(0);\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        String a = \"100\";\n        String b = \"1\";\n        String result = subtract(a, b);\n        System.out.println(result);  // Output: 99\n    }\n}\n\n```\n\n","timestamp":1694699764227},{"name":"01-684. 冗余连接.md","path":"002-数据结构与算法/017-并查集/01-684. 冗余连接.md","content":"### [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)\n\n```\n树可以看成是一个连通且 无环 的 无向 图。\n\n给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。\n\n请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的那个。\n```\n\n![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/06/21482516940081051694008105758oilz5F-1626676174-hOEVUL-image.png)\n\n```\n输入: edges = [[1,2], [1,3], [2,3]]\n输出: [2,3]\n```\n\n\n\n\n\n```java\nclass Solution {\n    private int n = 1005;\n    private int[] father = new int[1005];\n\n    // 并查集初始化\n    public Solution() {\n        for(int i = 0; i < n; i++) father[i] = i;   // 父亲节点指向自己 \n    }\n\n    public int find(int u) {\n        if(u == father[u]) return u;\n        return find(father[u]);\n    }\n\n    public void join(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if(u == v) return;\n        father[v] = u;\n    }\n\n    public boolean same(int u, int v) {\n        return find(u) == find(v);\n    }\n\n    public int[] findRedundantConnection(int[][] edges) {\n        for(int i = 0; i < edges.length; i++) {\n            if(same(edges[i][0], edges[i][1])) {\n                return edges[i];\n            } else {\n                join(edges[i][0], edges[i][1]);\n            }\n        }\n        return null;\n    }\n}\n```\n\n","timestamp":1694699764227},{"name":"100-总结.md","path":"002-数据结构与算法/100-总结.md","content":"**什么时候使用哈希法**\n\n当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法\n\n\n\n算法模版\n\nhttps://github.com/youngyangyang04/leetcode-master/blob/master/problems/算法模板.md","timestamp":1694699764227},{"name":"201-读取输入.md","path":"002-数据结构与算法/201-读取输入.md","content":"\n\n### 一直输入模板\n\n```java\nimport java.util.*;\npublic class Main{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n        \t\t//操作\n        }\n    }\n}\n```\n\n### 有组数或者输入个数\n\n```java\nimport java.util.Scanner;\npublic class Main{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n        while(n>0) {\n            n--;\n        }\n    }\n}\n```\n\n### 一行有多个信息 split切分\n\n```java\n// a c bb 一直输入\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()) {\n            String[] strs = sc.nextLine().split(\" \");\n         //操作\n        }\n    }\n}\n\n```\n\n### 给n然后读n行\n\n```java\n5\nhello\nhi\ntop\ntop\nhi\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // 读取第一行数据表示接下来的行数\n        int n = Integer.parseInt(scanner.nextLine());\n        \n        // 读取接下来的n行数据\n        for (int i = 0; i < n; i++) {\n            String line = scanner.nextLine();\n            System.out.println(line);\n        }\n        \n        scanner.close();\n    }\n}\n```\n\n[参考](https://blog.csdn.net/dadongwudi/article/details/107877871)","timestamp":1694699764227}]