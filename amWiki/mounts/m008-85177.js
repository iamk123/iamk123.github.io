if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m008']=[{"name":"000-JUC.md","path":"008-JUC/000-JUC.md","content":"# JUC高并发编程\n\n## 1 JUC概述\n\n## 2 LOCK接口\n\n### 什么是Lock接口\n\n```java\npublic interface Lock {\n    void lock(); \n    void lockInterruptibly() throws InterruptedException; \n    boolean tryLock(); \n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException; \n    void unlock(); Condition newCondition();\n}\n```\n\n```\nLock是Java中提供的一个接口，用于实现【线程同步机制】，它可以替代Synchronized关键字。\nLock接口提供了比Synchronized更灵活、更强大的线程同步功能，可以用于解决多线程中的资源竞争和死锁等问题。\nLock接口的实现类有很多种，其中最常用的是ReentrantLock。\n\nLock接口提供了以下主要方法：\n- lock()：获取锁，如果锁已经被其他线程获取，则当前线程进入等待状态。\n- unlock()：释放锁，如果当前线程持有锁，则释放锁并唤醒等待的线程。\n- tryLock()：尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true，否则立即返回false。\n- tryLock(long time, TimeUnit unit)：尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true，否则等待指定时间后返回false。\n- newCondition()：创建一个Condition对象，用于实现等待/通知机制。\n\n需要注意的是，在使用Lock接口时，需要在finally代码块中释放锁，以确保锁一定会被释放，避免死锁的发生。\n```\n\n#### 什么是线程同步机制？\n\n```\n- 是什么？\n线程同步机制是多线程编程中常用的一种机制，用于控制多个线程对共享资源的访问。\n\n- 为什么？\n在多线程环境中，多个线程同时访问共享资源可能会导致竞争条件和数据不一致等问题，因此需要使用线程同步机制来避免这些问题的发生\n\n- 怎么样？\n1.synchronized\n2.Lock接口\n\n- 基本原理\n线程同步机制的基本原理是在共享资源的访问前获取锁，只有获取锁的线程才能访问共享资源，其他线程需要等待锁的释放。\n在共享资源访问完成后，释放锁，让其他线程可以继续访问共享资源。这样就保证了共享资源在任何时刻只能被一个线程访问，避免了竞争条件和数据不一致等问题的发生。\n\n- 使用时注意的问题\n1.使用线程同步机制时，应该避免死锁、饥饿等问题的发生，以确保程序的正常运行\n2.同时，在使用synchronized关键字时，应该尽量减小同步块的范围，以提高程序的性能。\n3.在使用Lock接口时，需要在finally代码块中释放锁，以确保锁一定会被释放，避免死锁的发生。\n```\n\n##### 在使用synchronized关键字时，为什么要减小同步块的范围？\n\n```\n1.提高性能\n范围越大，需要等待获取锁的线程越多，导致在获取锁的过程中需要等待其他线程释放锁，而其他线程释放锁的时间也会比较长，这就会造成线程的等待时间过长，降低程序的运行效率。\n2.避免死锁\n不同的线程可能会竞争多个锁，释放锁的时间也会比较长，导致相互等待，形成死锁。\n\n因此，为了避免以上问题的发生，应该尽量减小同步块的范围，只在必要的地方进行同步，这样可以提高程序的性能，同时也可以降低出现死锁等问题的概率。\n```\n\n##### 为什么使用lock接口需要在finally代码块中释放锁\n\n```\n- 为什么？\n在使用Lock接口进行线程同步时，需要手动获取和释放锁，这是两个独立的操作，如果在获取锁之后发生异常，就有可能导致锁没有被释放，从而导致死锁等问题的发生。\n- 怎么样？\n因此，将释放锁的操作放在finally代码块中，这样可以确保在任何情况下都会释放锁，避免死锁等问题的发生。\n```\n\n### Lock和Synchronized的区别？\n\n```\n- 是什么 & 作用\nLock和Synchronized都是Java中用于实现线程同步的机制，它们的目的是为了避免线程间的竞争条件和数据不一致等问题。它们的区别如下：\n\n- 区别\n1.锁的获取方式：\n\tSynchronized是在进入同步代码块或同步方法时，自动获取锁，退出同步代码块或方法时自动释放锁；而Lock需要手动获取锁，并且必须手动释放锁。\n2.锁的粒度：\n\tSynchronized只能对整个方法或代码块进行加锁，而Lock可以对代码块进行更细粒度的控制。\n3.可中断性：\n\t在获取锁时，Synchronized是不可中断的，即使该线程在等待锁的过程中被中断，也不会释放锁；而Lock可以根据需要设置锁的可中断性。\n4.公平锁：\n\tSynchronized是非公平锁，不保证等待时间最长的线程最先获取锁；而Lock可以通过参数指定为公平锁或非公平锁。\n5.性能：\n\t相比较而言，Lock的性能比Synchronized好，在高并发的情况下，Lock的吞吐量比Synchronized更高。\n\n需要注意的是，Lock是在JDK 5中引入的，而Synchronized是Java早期就提供的同步机制。由于Lock相比Synchronized更灵活和高效，因此在实际开发中，使用Lock的场景会更多。\n```\n\n### Synchronized实现卖票例子\n\n```java\npackage com.atguigu.sync;\n\n//第一步  创建资源类，定义属性和和操作方法\nclass Ticket {\n    //票数\n    private int number = 10;\n    //操作方法：卖票\n    public synchronized void sale() {\n        //判断：是否有票\n        if(number > 0) {\n            System.out.println(Thread.currentThread().getName()+\" : 卖出：\"+(number--)+\" 剩下：\"+number);\n        }\n    }\n}\n\npublic class SaleTicket {\n    //第二步 创建多个线程，调用资源类的操作方法\n    public static void main(String[] args) {\n        //创建Ticket对象\n        Ticket ticket = new Ticket();\n        //创建三个线程\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                //调用卖票方法\n                for (int i = 0; i < 40; i++) {\n                    ticket.sale();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                //调用卖票方法\n                for (int i = 0; i < 40; i++) {\n                    ticket.sale();\n                }\n            }\n        },\"BB\").start();\n\n        // lambda表达式写法\n        new Thread(() -> {\n            //调用卖票方法\n            for (int i = 0; i < 40; i++) {\n                ticket.sale();\n            }\n        },\"CC\").start();\n    }\n}\n\n// 输出\nAA : 卖出：30 剩下：29\n...\nAA : 卖出：7 剩下：6\nBB : 卖出：6 剩下：5\n...\nBB : 卖出：1 剩下：0\n```\n\n### Lock实现卖票例子\n\n```java\n\n//第一步  创建资源类，定义属性和和操作方法\nclass LTicket {\n    //票数量\n    private int number = 30;\n\n    //创建可重入锁\n    private final ReentrantLock lock = new ReentrantLock(true);\n    //卖票方法\n    public void sale() {\n        //上锁\n        lock.lock();\n        try {\n            //判断是否有票\n            if(number > 0) {\n                System.out.println(Thread.currentThread().getName()+\" ：卖出\"+(number--)+\" 剩余：\"+number);\n            }\n        } finally {\n            //解锁\n            lock.unlock();\n        }\n    }\n}\n\npublic class LSaleTicket {\n    //第二步 创建多个线程，调用资源类的操作方法\n    //创建三个线程\n    public static void main(String[] args) {\n\n        LTicket ticket = new LTicket();\n\n        new Thread(()-> {\n            for (int i = 0; i < 40; i++) {\n                ticket.sale();\n            }\n        },\"AA\").start();\n\n        new Thread(()-> {\n            for (int i = 0; i < 40; i++) {\n                ticket.sale();\n            }\n        },\"BB\").start();\n\n        new Thread(()-> {\n            for (int i = 0; i < 40; i++) {\n                ticket.sale();\n            }\n        },\"CC\").start();\n    }\n}\n\n```\n\n\n\n### 什么是可重入锁\n\n```\n- 是什么？\n可重入锁是指同一个线程在持有某个锁的情况下，可以继续获取该锁而不会出现死锁的情况\n\n- synchronized关键字实现原理\n每个对象都有一个监视器锁（monitor），线程进入同步块时获取该对象的监视器锁，并在同步块结束时释放该锁，当一个线程在持有该锁的情况下再次进入同步块时，会自动获取该锁，而不会被阻塞。\n\n- ReentrantLock重入锁实现原理\n它使用一个计数器来记录线程获取锁的次数。当一个线程第一次获取锁时，计数器的值为1，当同一个线程再次获取锁时，计数器的值会递增，当线程退出同步块时，计数器的值递减，直到计数器的值为0时，锁被释放。这种机制保证了线程可以多次获取同一个锁而不会出现死锁的情况。\n```\n\n### 什么是ReentrantLock & 特点\n\n```\n- 是什么？\nReentrantLock是Java中实现Lock接口的一个类，它提供了与synchronized关键字类似的线程同步机制\n\n- 特点\n1.可重入性：\n\t与synchronized关键字一样，ReentrantLock支持可重入锁，即同一个线程可以多次获取同一个锁而不会死锁\n2.公平锁与非公平锁：\n\tReentrantLock提供了两种锁的实现方式，即公平锁和非公平锁。公平锁会按照线程的请求顺序来分配锁，而非公平锁则允许线程在竞争时插队，可能会导致某些线程长时间等待。\n3.条件变量：\n\tReentrantLock提供了Condition接口的实现类Condition，它可以将一个锁分为多个条件，使得线程可以在指定条件下等待和唤醒。这使得线程间的通信变得更加灵活。\n3.可中断性：\n\t与synchronized关键字不同，ReentrantLock提供了可中断锁的机制。即当一个线程等待获取锁时，可以通过中断等待的线程来结束等待。\n\nReentrantLock相对于synchronized关键字来说，具有更强的灵活性和可定制性，但需要手动获取和释放锁，使用时也需要注意避免死锁、饥饿等问题的发生。\n```\n\n### ReentrantLock和synchronized例子\n\n```java\n// 可重入锁\npublic class SyncLockDemo {\n\n    public synchronized void add() {\n        add();\n    }\n\n    public static void main(String[] args) {\n        //Lock演示可重入锁\n        Lock lock = new ReentrantLock();\n        //创建线程\n        new Thread(()->{\n            try {\n                //上锁\n                lock.lock();\n                System.out.println(Thread.currentThread().getName()+\" 外层\");\n\n                try {\n                    //上锁\n                    lock.lock();\n                    System.out.println(Thread.currentThread().getName()+\" 内层\");\n                }finally {\n                    //释放锁\n                    lock.unlock();\n                }\n            }finally {\n                //释放做\n                lock.unlock();\n            }\n        },\"t1\").start();\n\n        //创建新线程\n        new Thread(()->{\n            lock.lock();\n            System.out.println(\"aaaa\");\n            lock.unlock();\n        },\"aa\").start();\n\n       // new SyncLockDemo().add();\n       // synchronized\n       Object o = new Object();\n       new Thread(()->{\n           synchronized(o) {\n               System.out.println(Thread.currentThread().getName()+\" 外层\");\n\n               synchronized (o) {\n                   System.out.println(Thread.currentThread().getName()+\" 中层\");\n\n                   synchronized (o) {\n                       System.out.println(Thread.currentThread().getName()+\" 内层\");\n                   }\n               }\n           }\n\n       },\"t1\").start();\n    }\n}\n\n// 输出\nt1 外层\nt1 内层\naaaa\nt1 外层\nt1 中层\nt1 内层\n```\n\n### 创建线程的多种方式\n\n```\n1.继承Tread类\n2.实现Runnable接口\n3.实现Callable接口\n4.使用线程池\n```\n\n#### 继承Tread类\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread();\n        t.start(); // 启动新线程\n    }\n}\n```\n\n执行指定代码\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new MyThread();\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n\n[参考](https://www.liaoxuefeng.com/wiki/1252599548343744/1306580710588449)\n\n#### 实现Runnable接口\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n简写\n```java\nnew Thread(new Runnable() {\n  \t@Override\n  \tpublic void run() {\n    \t//调用卖票方法\n    \tfor (int i = 0; i < 40; i++) {\n      \tticket.sale();\n    \t}\n  \t}\n},\"Thread Name\").start();\n```\n\n使用Java8的lambda语法简写\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> {\n            System.out.println(\"start new thread!\");\n        });\n        t.start(); // 启动新线程\n    }\n}\n```\n\n[参考](https://www.liaoxuefeng.com/wiki/1252599548343744/1306580710588449)\n\n## \n\n\n\n## 3 线程间通信\n\n线程间通信的模型有两种：共享内存和消息传递\n\n**线程间的通信具体步骤：**\n\n1.  创建资源类，在资源类中创建属性和操作方法\n\n2.  在资源类操作方法：判断、操作、通知\n\n3.  创建多个线程，调用资源类的操作方法\n\n4.  防止虚拟唤醒问题\n\n    \n\n**案例**\n\n假设有两个线程，该线程在执行过程中，判断值（不是该值等待，让其他线程抢），操作值，通知另外一个线程的调度\n\n通过使用两个线程对0这个值操作，一个线程加1，一个线程减1，交替实现多次\n\n#### synchronized实现\n\n```java\n//第一步 创建资源类，定义属性和操作方法\nclass Share {\n    //初始值\n    private int number = 0;\n    //+1的方法\n    public synchronized void incr() throws InterruptedException {\n        //第二步 判断 干活 通知\n       // 错误写法：\n       // if(number != 0) { //判断number值是否是0，如果不是0，等待\t\t注意：此处写法会导致虚假换新问题，用while\n            // this.wait(); //在哪里睡，就在哪里醒\n        // }\n      \n        // 正确写法\n      \twhile(number != 0) { //判断number值是否是0，如果不是0，等待\n            this.wait(); //在哪里睡，就在哪里醒\n        }\n        //如果number值是0，就+1操作\n        number++;\n        System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n        //通知其他线程\n        this.notifyAll();\n    }\n\n    //-1的方法\n    public synchronized void decr() throws InterruptedException {\n        //判断\n        if(number != 1) {\n            this.wait();\n        }\n        //干活\n        number--;\n        System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n        //通知其他线程\n        this.notifyAll();\n    }\n}\n\npublic class ThreadDemo1 {\n    //第三步 创建多个线程，调用资源类的操作方法\n    public static void main(String[] args) {\n        Share share = new Share();\n        //创建线程\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr(); //+1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr(); //-1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n    }\n}\n\n// 结果\nAA :: 1\nBB :: 0\nAA :: 1\nBB :: 0\n...\n```\n\n问题：线程数多了之后，使用if来判断标志位会出现虚假唤醒问题\n\n```java\n// 在上述代码的基础上再添加线程\nnew Thread(()->{\n    for (int i = 1; i <=10; i++) {\n        try {\n            share.incr(); //+1\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n},\"CC\").start();\n\nnew Thread(()->{\n    for (int i = 1; i <=10; i++) {\n        try {\n            share.decr(); //-1\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n},\"DD\").start();\n\n// 结果\nAA :: 1\nBB :: 0\nAA :: 1\nBB :: 0\n...\nCC :: 1\nBB :: 0\nCC :: 1\nBB :: 0\nDD :: -1\n```\n\n主要是虚拟唤醒导致：如果一个线程执行完毕后，通知其他线程，该线程又进入等待睡眠，可能会因为某些原因被唤醒后，if结构的语句就不会判断了，一直往下执行，所以需要将if换成while结构，每次都判断。因为wait在哪里睡眠就在哪里被唤醒，结果被某个异常唤醒了后回不去了，if结构不会在判断了，需要更改为while\n\n```java\nwhile(number != 0) { //判断number值是否是0，如果不是0，等待\n    this.wait(); //在哪里睡，就在哪里醒\n}\n```\n\n#### lock实现\n\n```java\npackage com.atguigu.lock;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n//第一步 创建资源类，定义属性和操作方法\nclass Share {\n    private int number = 0;\n\n    //创建Lock\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    //+1\n    public void incr() throws InterruptedException {\n        //上锁\n        lock.lock();\n        try {\n            //判断\n            while (number != 0) {\n                condition.await();\n            }\n            //干活\n            number++;\n            System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n            //通知\n            condition.signalAll();\n        }finally {\n            //解锁\n            lock.unlock();\n        }\n    }\n\n    //-1\n    public void decr() throws InterruptedException {\n        lock.lock();\n        try {\n            while(number != 1) {\n                condition.await();\n            }\n            number--;\n            System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n            condition.signalAll();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ThreadDemo2 {\n\n    public static void main(String[] args) {\n        Share share = new Share();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"CC\").start();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"DD\").start();\n    }\n\n}\n\n```\n\n\n\n## 4 线程间定制化通信\n\n**所谓定制化通信，需要让线程进行一定的顺序操作**\n\n**案列**：启动三个线程，按照如下要求：\nAA打印5此，BB打印10次，CC打印15次，一共进行10轮\n\n**具体思路**：\n每个线程添加一个标志位，是该标志位则执行操作，并且修改为下一个标志位，通知下一个标志位的线程\n\n```java\n//第一步 创建资源类\nclass ShareResource {\n    //定义标志位\n    private int flag = 1;  // 1 AA     2 BB     3 CC\n\n    //创建Lock锁\n    private Lock lock = new ReentrantLock();\n\n    //创建三个condition\n    private Condition c1 = lock.newCondition();\n    private Condition c2 = lock.newCondition();\n    private Condition c3 = lock.newCondition();\n\n    //打印5次，参数第几轮\n    public void print5(int loop) throws InterruptedException {\n        //上锁\n        lock.lock();\n        try {\n            //判断\n            while(flag != 1) {\n                //等待\n                c1.await();\n            }\n            //干活\n            for (int i = 1; i <=5; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //通知\n            flag = 2; //修改标志位 2\n            c2.signal(); //通知BB线程\n        }finally {\n            //释放锁\n            lock.unlock();\n        }\n    }\n\n    //打印10次，参数第几轮\n    public void print10(int loop) throws InterruptedException {\n        lock.lock();\n        try {\n            while(flag != 2) {\n                c2.await();\n            }\n            for (int i = 1; i <=10; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //修改标志位\n            flag = 3;\n            //通知CC线程\n            c3.signal();\n        }finally {\n            lock.unlock();\n        }\n    }\n\n    //打印15次，参数第几轮\n    public void print15(int loop) throws InterruptedException {\n        lock.lock();\n        try {\n            while(flag != 3) {\n                c3.await();\n            }\n            for (int i = 1; i <=15; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //修改标志位\n            flag = 1;\n            //通知AA线程\n            c1.signal();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ThreadDemo3 {\n    public static void main(String[] args) {\n        ShareResource shareResource = new ShareResource();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print5(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print10(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print15(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"CC\").start();\n    }\n}\n\n```\n\n\n\n## 5 集合的线程安全\n\n向集合中边读边写，导致java.util.ConcurrentModificationException异常\n\n```java\nList<String> list = new ArrayList<>();\n\nfor (int i = 0; i <30; i++) {\n    new Thread(()->{\n        //向集合添加内容\n       list.add(UUID.randomUUID().toString().substring(0,8));\n        //从集合获取内容\n        System.out.println(list);\n    },String.valueOf(i)).start();\n}\n\n```\n\n原因\n\n```\nboolean add(E e); \t没有synchronized声明，是线程非安全的\n```\n\n### 如何解决 ArrayList 类型的线程安全问题?\n\n#### 方法一：Vector\n\n#### 方法二：Collections\n\nCollections类中的很多方法都是static静态\n其中有一个方法是返回指定列表支持的同步（线程安全的）列表为`synchronizedList(List <T> list)`\n\n```java\nList<String> list = Collections.synchronizedList(new ArrayList<>());\n```\n\n\n\n#### 方法三：CopyOnWriteArrayList\n\n##### 实现\n\n```java\npublic class NotSafeDemo {\n\n/** 多个线程同时对集合进行修改 **/ \n  public static void main(String[] args) { \n    List list = new CopyOnWriteArrayList();\n    for (int i = 0; i < 100; i++) { \n      new Thread(() ->{ \n        list.add(UUID.randomUUID().toString()); \n        System.out.println(list); \n      }, \"线程\" + i).start(); \n    }\n\t}\n}\n```\n\n##### CopyOnWriteArrayList为什么能解决线程安全问题\n\n```\n实现原理：写时复制技术\n- 写过程：\n当需要对CopyOnWriteArrayList进行修改时，它会先将原始数组进行复制，然后再进行修改操作，最后将修改后的数组替换原始数组，这样就保证了修改操作的线程安全性。\n\n- 读过程\n在读取CopyOnWriteArrayList中的元素时，不需要加锁，因为读取时不会对原始数组进行修改，而是返回一个快照副本，多个线程同时进行读操作时不会出现线程安全问题。\n```\n\n##### CopyOnWriteArrayList缺点 & 适用场景\n\n```\n底层实现采用了复制数组的方式来保证线程安全，因此每次修改操作都需要对原始数组进行复制，这会带来一定的性能开销。\n【适用】于【读多写少】的场景，在需要高并发读取的场景中表现较好。\n【不适用】于【实时性】的场景，不能保证数据的实时一致性\n```\n\n\n\n### 如何解决 HashSet 类型的线程安全问题?\n\n#### 方法：CopyOnWriteArraySet\n\n```java\njava Set<String> set = new HashSet<>();\t\t\t\t\t  // 非安全\nSet<String> set = new CopyOnWriteArraySet<>();\t\t// 安全\n```\n\n\n\n### 如何解决 HashMap 类型的线程安全问题?\n\n```java\nMap<String,String> map = new HashMap<>();\t\t\t\t\t\t\t// 非安全\nMap<String,String> map = new ConcurrentHashMap<>();\t\t// 安全\n```\n\n#### TODO： ConcurrentHashMap实现原理\n\n\n\n\n\n## 6 多线程锁\n\n### 公平锁和非公平锁\n\n-   **公平锁**：效率相对低\n-   **非公平锁**：效率高，但是线程容易饿死\n\n实现\n\n```java\n// 公平锁\nReentrantLock lock = new ReentrantLock(true);\n// 非公平锁\nReentrantLock lock = new ReentrantLock(false);\n```\n\n\n\n### 可重入锁\n\nsynchronized和lock都是可重入锁\n\n-   sychronized是隐式锁，不用手工上锁与解锁，而lock为显示锁，需要手工上锁与解锁\n-   可重入锁也叫递归锁\n\n而且有了可重入锁之后，破解第一把之后就可以一直进入到内层结构\n\n\n\n### 死锁\n\n**产生死锁的原因：**\n\n1.  系统资源不足\n2.  系统资源分配不当\n3.  进程运行顺序不当\n\n\n\n## Callable接口\n\n### 有Runnable为什么还要callable？\n\n```\nRunnable 缺少的一项功能是，当线程终止时（即 run（）完成时），我们无法使线程返回结果。为了支持此功能，Java 中提供了 Callable 接口\n```\n\n\n\n### **比较Runnable接口和Callable接口**\n\n```java\n//实现Runnable接口\nclass MyThread1 implements Runnable {\n    @Override\n    public void run() {\n\n    }\n}\n\n//实现Callable接口\nclass MyThread2 implements Callable {\n\n    @Override\n    public Integer call() throws Exception {\n        return 200;\n    }\n}\n\n```\n\n","timestamp":1694102216563},{"name":"00-并发编程相关.md","path":"008-JUC/001-Java并发编程/00-并发编程相关.md","content":"[采用线程池进行异步任务处理](https://cloud.tencent.com/developer/article/1161221)\n\n[生产实践——线程池与异步任务编排](https://juejin.cn/post/7086351322944913438#heading-12)\n\n-   多文件上传\n\n[Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)\n\n[Javaguide 线程池详解](https://javaguide.cn/java/concurrent/java-thread-pool-summary.html)","timestamp":1694102216563},{"name":"01-Java并发编程基础.md","path":"008-JUC/001-Java并发编程/01-Java并发编程基础.md","content":"# Java并发编程基础\n\n## 1 线程基础\n\n### 什么是线程\n\n### 为什么要使用多线程\n\n### 线程的优先级\n\n### 线程的状态\n\n* 创建 New：新创建的线程，尚未执行；\n* 运行 Runnable：运行中的线程，正在执行 `run()`方法的Java代码；\n* 阻塞 Blocked：运行中的线程，因为某些操作被阻塞而挂起；\n* 等待 Waiting：运行中的线程，因为某些操作在等待中；\n* 超时等待 Timed Waiting：运行中的线程，因为执行 `sleep()`方法正在计时等待；\n* 终止 Terminated：线程已终止，因为 `run()`方法执行完毕。\n\n![image-20230503132121863](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/04/13042416831766641683176664243erV4pC-13212216830912821683091282100jSyioP-image-20230503132121863-20230504130424144.png)\n\n### 线程终止的原因\n\n- 线程正常终止：`run()`方法执行到 `return`语句返回；\n- 线程意外终止：`run()`方法因为未捕获的异常导致线程终止；\n- 对某个线程的 `Thread`实例调用 `stop()`方法强制终止（强烈不推荐使用）。\n\n## 2 创建线程的方式\n\n```\n1.继承Tread类\n2.实现Runnable接口\n3.实现Callable接口\n4.使用线程池\n```\n\n### 继承Tread类\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread();\n        t.start(); // 启动新线程\n    }\n}\n```\n\n执行指定代码\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new MyThread();\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n\n[参考](https://www.liaoxuefeng.com/wiki/1252599548343744/1306580710588449)\n\n### 实现Runnable接口\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n\n简写\n\n```java\nnew Thread(new Runnable() {\n  \t@Override\n  \tpublic void run() {\n    \t//调用卖票方法\n    \tfor (int i = 0; i < 40; i++) {\n      \tticket.sale();\n    \t}\n  \t}\n},\"Thread Name\").start();\n```\n\n使用Java8的lambda语法简写\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> {\n            System.out.println(\"start new thread!\");\n        });\n        t.start(); // 启动新线程\n    }\n}\n```\n\n[参考](https://www.liaoxuefeng.com/wiki/1252599548343744/1306580710588449)\n\n### 实现Callable接口\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    FutureTask<Integer> ft = new FutureTask<>(new MyCallable(););\n    Thread thread = new Thread(ft);\n    thread.start();\n    System.out.println(ft.get());\n}\n\npublic class MyCallable implements Callable<Integer> {\n    public Integer call() {\n        return 123;\n    }\n}\n```\n\n### 三者对比\n\n```\n（1）继承Thread类：java不支持多继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；\n（2）实现runnable接口\n\t\t- 使用run()方法\n（3）实现callable接口：\n\t\t- 可以获取返回结果\n\t\t- 使用call()方法\n```\n\n\n\n## 3 中断线程\n\n\n\n## 4 线程间通信\n\n### volatile和synchronized关键字\n\n\n\n### 通知/等待机制\n\n#### 通知和等待的相关方法\n\n等待\n\n```\nwait(): 等待无限长的时间，直到其他线程唤醒它。\nwait(long timeout): 等待一定的时间后，自动唤醒当前线程。\nwait(long timeout, int nanos): 等待指定的时间和纳秒数后自动唤醒当前线程。\n```\n\n通知\n\n```\nnotify()方法用于唤醒一个正在等待的线程，如果有多个线程等待，则唤醒其中一个线程。\nnotifyAll()方法则唤醒所有等待的线程。\n```\n\n#### 等待/通知的经典范式\n\n等待方\n\n```java\n1.获取对象的锁\n2.如果条件不满足，则调用对象的wait()方法，被通知后仍要检查条件（即使用wile而不能使用if）\n3.条件满足时则执行对应的逻辑\n\nsynchronized(对象) {\n\twhile(条件不满足时) {\n    对象.wait();\n  }\n  // 处理逻辑\n}\n```\n\n通知方\n\n```java\n1.获取对象的锁\n2.改变条件\n3.通知所有等待在对象上的线程\n  \nsynchronized(对象) {\n\t改变条件\n  对象.notifyAll();\n}\n```\n\n#### 例子\n\n**例子1**\n\n```java\npublic class WaitNotify {\n    static boolean flag = true;\n    static Object  lock = new Object();\n\n    public static void main(String[] args) throws Exception {\n        Thread waitThread = new Thread(new Wait(), \"WaitThread\");\n        waitThread.start();\n        TimeUnit.SECONDS.sleep(1);\n\n        Thread notifyThread = new Thread(new Notify(), \"NotifyThread\");\n        notifyThread.start();\n    }\n\n    static class Wait implements Runnable {\n        public void run() {\n            // 加锁，拥有lock的Monitor\n            synchronized (lock) {\n                // 当条件不满足时，继续wait，同时释放了lock的锁\n                while (flag) {\n                    try {\n                        System.out.println(Thread.currentThread() + \" flag is true. wait @ \"\n                                           + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                    }\n                }\n                // 条件满足时，完成工作\n                System.out.println(Thread.currentThread() + \" flag is false. running @ \"\n                                   + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n            }\n        }\n    }\n\n    static class Notify implements Runnable {\n        public void run() {\n            // 加锁，拥有lock的Monitor\n            synchronized (lock) {\n                // 获取lock的锁，然后进行通知，通知时不会释放lock的锁，\n                // 直到当前线程释放了lock后，WaitThread才能从wait方法中返回\n                System.out.println(Thread.currentThread() + \" hold lock. notify @ \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                lock.notifyAll();\n                flag = false;\n                SleepUtils.second(5);\n            }\n            // 再次加锁\n            synchronized (lock) {\n                System.out.println(Thread.currentThread() + \" hold lock again. sleep @ \"\n                                   + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()));\n                SleepUtils.second(5);\n            }\n        }\n    }\n```\n\n**例子2**\n\n通过使用多个线程对0这个值操作，一个线程加1，一个线程减1，交替实现多次\n\n```java\n//第一步 创建资源类，定义属性和操作方法\nclass Share {\n    //初始值\n    private int number = 0;\n    //+1的方法\n    public synchronized void incr() throws InterruptedException {\n        //第二步 判断 干活 通知\n       // 错误写法：\n       // if(number != 0) { //判断number值是否是0，如果不是0，等待\t\t注意：此处写法会导致虚假换新问题，用while\n            // this.wait(); //在哪里睡，就在哪里醒\n        // }\n      \n        // 正确写法\n      \twhile(number != 0) { //判断number值是否是0，如果不是0，等待\n            this.wait(); //在哪里睡，就在哪里醒\n        }\n        //如果number值是0，就+1操作\n        number++;\n        System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n        //通知其他线程\n        this.notifyAll();\n    }\n\n    //-1的方法\n    public synchronized void decr() throws InterruptedException {\n        //判断\n        if(number != 1) {\n            this.wait();\n        }\n        //干活\n        number--;\n        System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n        //通知其他线程\n        this.notifyAll();\n    }\n}\n\npublic class ThreadDemo1 {\n    //第三步 创建多个线程，调用资源类的操作方法\n    public static void main(String[] args) {\n        Share share = new Share();\n        //创建线程\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr(); //+1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr(); //-1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n    }\n}\n\n// 结果\nAA :: 1\nBB :: 0\nAA :: 1\nBB :: 0\n...\n```\n\n不能用if的原因\n\n```\n主要是虚拟唤醒导致：如果一个线程执行完毕后，通知其他线程，该线程又进入等待睡眠，可能会因为某些原因被唤醒后，if结构的语句就不会判断了，一直往下执行，所以需要将if换成while结构，每次都判断。因为wait在哪里睡眠就在哪里被唤醒，结果被某个异常唤醒了后回不去了，if结构不会在判断了，需要更改为while\n```\n\n\n\n### Condition\n\n```java\npackage com.atguigu.lock;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n//第一步 创建资源类，定义属性和操作方法\nclass Share {\n    private int number = 0;\n\n    //创建Lock\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    //+1\n    public void incr() throws InterruptedException {\n        //上锁\n        lock.lock();\n        try {\n            //判断\n            while (number != 0) {\n                condition.await();\n            }\n            //干活\n            number++;\n            System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n            //通知\n            condition.signalAll();\n        }finally {\n            //解锁\n            lock.unlock();\n        }\n    }\n\n    //-1\n    public void decr() throws InterruptedException {\n        lock.lock();\n        try {\n            while(number != 1) {\n                condition.await();\n            }\n            number--;\n            System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n            condition.signalAll();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ThreadDemo2 {\n\n    public static void main(String[] args) {\n        Share share = new Share();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"CC\").start();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"DD\").start();\n    }\n\n}\n```\n\n\n\n### 线程间定制化通信\n\n**所谓定制化通信，需要让线程进行一定的顺序操作**\n\n**案列**：启动三个线程，按照如下要求：\nAA打印5此，BB打印10次，CC打印15次，一共进行10轮\n\n**具体思路**：\n每个线程添加一个标志位，是该标志位则执行操作，并且修改为下一个标志位，通知下一个标志位的线程\n\n```java\n//第一步 创建资源类\nclass ShareResource {\n    //定义标志位\n    private int flag = 1;  // 1 AA     2 BB     3 CC\n\n    //创建Lock锁\n    private Lock lock = new ReentrantLock();\n\n    //创建三个condition\n    private Condition c1 = lock.newCondition();\n    private Condition c2 = lock.newCondition();\n    private Condition c3 = lock.newCondition();\n\n    //打印5次，参数第几轮\n    public void print5(int loop) throws InterruptedException {\n        //上锁\n        lock.lock();\n        try {\n            //判断\n            while(flag != 1) {\n                //等待\n                c1.await();\n            }\n            //干活\n            for (int i = 1; i <=5; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //通知\n            flag = 2; //修改标志位 2\n            c2.signal(); //通知BB线程\n        }finally {\n            //释放锁\n            lock.unlock();\n        }\n    }\n\n    //打印10次，参数第几轮\n    public void print10(int loop) throws InterruptedException {\n        lock.lock();\n        try {\n            while(flag != 2) {\n                c2.await();\n            }\n            for (int i = 1; i <=10; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //修改标志位\n            flag = 3;\n            //通知CC线程\n            c3.signal();\n        }finally {\n            lock.unlock();\n        }\n    }\n\n    //打印15次，参数第几轮\n    public void print15(int loop) throws InterruptedException {\n        lock.lock();\n        try {\n            while(flag != 3) {\n                c3.await();\n            }\n            for (int i = 1; i <=15; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //修改标志位\n            flag = 1;\n            //通知AA线程\n            c1.signal();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ThreadDemo3 {\n    public static void main(String[] args) {\n        ShareResource shareResource = new ShareResource();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print5(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print10(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print15(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"CC\").start();\n    }\n}\n\n```\n\n\n\n### Thread.join()\n\n#### 是什么？\n\n```\nThread.join()是一个线程等待的方法，调用该方法的线程会等待目标线程执行完毕后再继续执行\n\njoin()方法通常用于等待其他线程执行完毕后再继续执行，例如在主线程中启动多个子线程，然后使用join()方法等待所有子线程执行完毕后再统一进行处理。\n```\n\n#### 怎么用？\n\n例子: B等待A执行完后再执行\n\n还可以使用CountDownLatch来实现\n\n```java\n// 创建线程A\nThread threadA = new Thread(() -> {\n    // 线程A要执行的代码\n});\n\n// 创建线程B\nThread threadB = new Thread(() -> {\n    // 等待线程A执行完毕\n    try {\n        threadA.join();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    \n    // 线程B要执行的代码\n});\n\n// 启动线程A和线程B\nthreadA.start();\nthreadB.start();\n\n```\n\n### ThreadLocal\n\n#### 是什么？\n\n```\nThreadLocal，即线程变量，表示线程的“局部变量”, 是一个以ThreadLocal对象为键、任意对象为值的存储结构。\n它确保每个线程的ThreadLocal变量都是各自独立的；\nThreadLocal适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；\n```\n\n#### 怎么用？\n\n```java\nstatic ThreadLocal<User> threadLocalUser = new ThreadLocal<>(); // 通常总是以静态字段初始化\n\nvoid processUser(user) {\n    try {\n        threadLocalUser.set(user);\n        step1();\n        step2();\n    } finally {\n      \t// 一定要在finally中清除\n      \t// 因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果ThreadLocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。\n        threadLocalUser.remove();\n    }\n}\n\nvoid step1() {\n    User u = threadLocalUser.get();\n    log();\n    printUser();\n}\n\nvoid log() {\n    User u = threadLocalUser.get();\n    println(u.name);\n}\n\nvoid step2() {\n    User u = threadLocalUser.get();\n    checkUser(u.id);\n}\n```\n\n**优化：自动释放**\n\n例子：一个保存了当前用户名的`ThreadLocal`可以封装为一个`UserContext`对象：\n\n```java\npublic class UserContext implements AutoCloseable {\n\n    static final ThreadLocal<String> ctx = new ThreadLocal<>();\n\n    public UserContext(String user) {\n        ctx.set(user);\n    }\n\n    public static String currentUser() {\n        return ctx.get();\n    }\n\n    @Override\n    public void close() {\n        ctx.remove();\n    }\n}\n```\n\n使用\n\n```java\ntry (var ctx = new UserContext(\"Bob\")) {\n    // 可任意调用UserContext.currentUser():\n    String currentUser = UserContext.currentUser();\n} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象\n```\n\n\n\n## 5 线程应用实例\n\n### 等待超时模式\n\n调用一个方法时等待一段时间，如果该方法能够在给定的时间之内得到结果，直接返回；反之，超时返回默认结果。\n\n```java\n    public synchronized Object get(long mills) {\n        long future = System.currentTimeMillis() + mills;\n        long remaining = mills;\n        while(result == null && remaining > 0) {\n            wait(remaining);\n            remaining = future - System.currentTimeMillis();\n        }\n\n        return result;\n    }\n```\n\n\n\n### 数据库连接池示例\n\n描述\n\n```\n使用等待超时模式构建一个简单的数据库连接池，模拟从连接池中获取、使用和释放连接的过程。\n客户端获取连接的过程被设定为等待超时的模式，1000ms内无法获取可用连接返回null。\n连接池大小为10，通过调用客户端的连线数来模拟无法获取连接的场景。\n```\n\n连接池 `ConnectionPool.java`\n\n```java\npackage ConnectionPool;\n\nimport java.sql.Connection;\nimport java.util.LinkedList;\n\npublic class ConnectionPool {\n\n    private LinkedList<Connection> pool = new LinkedList<>();\n\n    public ConnectionPool(int initialSize) {\n        if(initialSize <= 0) return;\n        for(int i = 0; i < initialSize; i++) {\n            pool.addLast(ConnectionDriver.createConnection());\n        }\n    }\n\n    public void releaseConnection(Connection connection) {\n        if(connection == null) return;\n        synchronized(pool) {\n            // 添加后需要进行通知，这样其他消费者能够感知到链接池中已经归还了一个链接\n            pool.addLast(connection);\n            pool.notifyAll();\n        }\n    }\n\n    // 在mills内无法获取到连接，将会返回null\n    public Connection fetchConnection(long mills) throws InterruptedException {\n        synchronized(pool) {\n            // 完全超时\n            if(mills <= 0) {\n                while(pool.isEmpty()) {\n                    pool.wait();\n                }\n\n                return pool.removeFirst();\n            } else {\n                long future = System.currentTimeMillis() + mills;\n                long remaining = mills;\n                while(pool.isEmpty() && remaining > 0) {\n                    pool.wait(remaining);\n                    remaining = future - System.currentTimeMillis();\n                }\n\n                Connection result = null;\n                if(!pool.isEmpty()) {\n                    result = pool.removeFirst();\n                }\n                return result;\n            }\n        }\n    }\n}\n```\n\n数据库连接驱动器\n\n```java\npackage ConnectionPool;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.sql.Connection;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 这段代码主要实现了一个Connection的代理类。在Connection的代理类中，如果调用的方法是commit方法，就会休眠100毫秒。最后，代理类返回的结果是null。\n *\n * 这段代码的作用是模拟一个数据库连接的commit操作，以及在commit操作时的休眠效果。\n * 通常情况下，数据库的commit操作需要一定的时间才能完成，因此在实际应用中需要通过代理类来模拟commit操作的耗时。\n * 这样就能更好地测试代码在多线程环境下的可靠性。\n *\n * 这段代码的关键在于使用了代理类来实现Connection的commit操作。\n * 在代理类中，如果调用的方法是commit方法，就会休眠100毫秒。\n * 这种方式可以模拟commit操作需要一定的时间才能完成的情况。\n * 同时，由于代理类返回的结果是null，因此在测试时需要根据实际情况进行判断。\n */\npublic class ConnectionDriver {\n\n    static class ConnectionHandler implements InvocationHandler {\n        // @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if (method.getName().equals(\"commit\")) {\n                TimeUnit.MILLISECONDS.sleep(100);\n            }\n            return null;\n        }\n    }\n\n\n    // 创建一个Connection的代理，在commit时休眠1秒\n    public static final Connection createConnection() {\n        return (Connection) Proxy.newProxyInstance(\n                ConnectionDriver.class.getClassLoader(),\n                new Class<?>[]{Connection.class},\n                new ConnectionHandler()\n        );\n    }\n}\n\n```\n\n测试\n\n```java\npackage ConnectionPool;\n\nimport java.sql.Connection;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n\npublic class ConnectionPoolTest {\n    static ConnectionPool pool = new ConnectionPool(10);\n    static CountDownLatch start = new CountDownLatch(1);    // 相当于一个总开关，线程开启后阻塞在同一个地方，开启后所有线程统一执行\n    static CountDownLatch end;      // 打印日志的总开关，待所有线程执行解释后，再输出日志\n\n    static class ConnetionRunner implements Runnable {\n        int count;                  // 要起的线程数\n        AtomicInteger got;          // 记录获取到连接的数量\n        AtomicInteger notGot;       // 记录获取不到连接的数量\n\n        public ConnetionRunner(int count, AtomicInteger got, AtomicInteger notGot) {\n            this.count = count;\n            this.got = got;\n            this.notGot = notGot;\n        }\n\n        public void run() {\n            try {\n                start.await();  // 线程启动时先统一阻塞到该处，start.countDown();后统一执行\n            } catch (Exception ex) {\n\n            }\n            while (count > 0) {\n                try {\n                    // 从线程池中获取连接，如果1000ms内无法获取到，将会返回null\n                    // 分别统计连接获取的数量got和未获取到的数量notGot\n                    Connection connection = pool.fetchConnection(1000);\n                    if (connection != null) {\n                        try {\n                            connection.createStatement();\n                            connection.commit();\n                        } finally {\n                            pool.releaseConnection(connection);\n                            got.incrementAndGet();\n                        }\n                    } else {\n                        notGot.incrementAndGet();\n                    }\n                } catch (Exception ex) {\n                } finally {\n                    count--;\n                }\n            }\n            end.countDown();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        // 线程数量，可以线程数量进行观察\n        int threadCount = 50;\n        end = new CountDownLatch(threadCount);\n        int count = 20;\n        AtomicInteger got = new AtomicInteger();\n        AtomicInteger notGot = new AtomicInteger();\n        for (int i = 0; i < threadCount; i++) {\n            Thread thread = new Thread(new ConnetionRunner(count, got, notGot), \"ConnectionRunnerThread\");\n            thread.start();\n        }\n        start.countDown();\n        end.await();        // 50个线程执行完之后，才开始输出日志\n        System.out.println(\"total invoke: \" + (threadCount * count));\n        System.out.println(\"got connection:  \" + got);\n        System.out.println(\"not got connection \" + notGot);\n    }\n\n}\n\n```\n\n运行结果\n\n```\ntotal invoke: 1000\ngot connection:  826\nnot got connection 174\n```\n\n### 线程池\n\n`ThreadPool.java`\n\n```java\n/**\n * 线程池接口定义\n * @param <Job>\n */\npublic interface ThreadPool<Job extends Runnable> {\n    // 执行一个Job，这个Job需要实现Runnable\n    void execute(Job job);\n\n    // 关闭线程池\n    void shutdown();\n\n    // 增加工作者线程\n    void addWorkers(int num);\n\n    // 减少工作者线程\n    void removeWorker(int num);\n\n    // 得到正在等待执行的任务数量\n    int getJobSize();\n}\n```\n\n`DefaultThreadPool.java`\n\n```java\npackage ThreadPool;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class DefaultThreadPool <Job extends Runnable> implements ThreadPool<Job> {\n    // 线程池最大限制数\n    private static final int      MAX_WORKER_NUMBERS     = 10;\n    // 线程池默认的数量\n    private static final int      DEFAULT_WORKER_NUMBERS = 5;\n    // 线程池最小的数量\n    private static final int      MIN_WORKER_NUMBERS     = 1;\n    // 这是一个工作列表，将会向里面插入工作\n    private final LinkedList<Job> jobs                   = new LinkedList<Job>();\n    // 工作者列表\n    private final List<Worker> workers                   = Collections.synchronizedList(new ArrayList<Worker>());\n    // 工作者线程的数量\n    private int                   workerNum              = DEFAULT_WORKER_NUMBERS;\n    // 线程编号生成\n    private AtomicLong threadNum                         = new AtomicLong();\n\n    public DefaultThreadPool() {\n        initializeWokers(DEFAULT_WORKER_NUMBERS);\n    }\n\n    public DefaultThreadPool(int num) {\n        workerNum = num > MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num < MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;\n        initializeWokers(workerNum);\n    }\n\n    @Override\n    public void execute(Job job) {\n        if(job != null) {\n            // 添加一个工作，然后进行通知\n            synchronized (jobs) {\n                jobs.addLast(job);\n                jobs.notifyAll();\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        for(Worker worker : workers) {\n            worker.shutdown();\n        }\n    }\n\n    @Override\n    public void addWorkers(int num) {\n        synchronized (jobs) {\n            // 限制新增的Worker数量不能超过最大值\n            if(num + this.workerNum > MAX_WORKER_NUMBERS) {\n                num = MAX_WORKER_NUMBERS - this.workerNum;\n            }\n            initializeWokers(num);\n            this.workerNum += num;\n        }\n    }\n\n    @Override\n    public void removeWorker(int num) {\n        synchronized (jobs) {\n            if(num >= this.workerNum) {\n                throw new IllegalArgumentException(\"beyond workNum\");\n            }\n            // 按照给定的数量停止Worker\n            int count = 0;\n            while (count < num) {\n                workers.get(count).shutdown();\n                count++;\n            }\n            this.workerNum -= count;\n        }\n    }\n\n    @Override\n    public int getJobSize() {\n        return jobs.size();\n    }\n\n    // 初始化线程工作者\n    private void initializeWokers(int num) {\n        for (int i = 0; i < num; i++) {\n            Worker worker = new Worker();\n            workers.add(worker);\n            Thread thread = new Thread(worker, \"ThreadPool-Worker-\" + threadNum.incrementAndGet());\n            thread.start();\n        }\n    }\n\n    // 工作者，负责消费任务\n    class Worker implements Runnable {\n        // 是否工作\n        private volatile boolean running = true;\n\n        public void run() {\n            while(running) {\n                Job job = null;\n                synchronized (jobs) {\n                    while(jobs.isEmpty()) {\n                        try {\n                            jobs.wait();\n                        } catch (InterruptedException e) {\n                            // 感知到外部对WorkerThread的中断操作，返回\n                            Thread.currentThread().interrupt();\n                            return;\n                        }\n                        // 去除一个job\n                        job = jobs.removeFirst();\n                    }\n                }\n\n                if(job != null) {\n                    try {\n                        job.run();\n                    } catch (Exception e) {\n                        // 忽略Job执行中的Exception\n                    }\n                }\n            }\n        }\n\n        public void shutdown() {\n            running = false;\n        }\n    }\n}\n\n```\n\n","timestamp":1694102216563},{"name":"02-Java中的锁.md","path":"008-JUC/001-Java并发编程/02-Java中的锁.md","content":"## 什么是线程同步机制？\n\n```\n- 是什么？\n线程同步机制是多线程编程中常用的一种机制，用于控制多个线程对共享资源的访问。\n\n- 为什么？\n在多线程环境中，多个线程同时访问共享资源可能会导致竞争条件和数据不一致等问题，因此需要使用线程同步机制来避免这些问题的发生\n\n- 怎么样？\n1.synchronized\n2.Lock接口\n\n- 基本原理\n线程同步机制的基本原理是在共享资源的访问前获取锁，只有获取锁的线程才能访问共享资源，其他线程需要等待锁的释放。\n在共享资源访问完成后，释放锁，让其他线程可以继续访问共享资源。这样就保证了共享资源在任何时刻只能被一个线程访问，避免了竞争条件和数据不一致等问题的发生。\n\n- 使用时注意的问题\n1.使用线程同步机制时，应该避免死锁、饥饿等问题的发生，以确保程序的正常运行\n2.同时，在使用synchronized关键字时，应该尽量减小同步块的范围，以提高程序的性能。\n3.在使用Lock接口时，需要在finally代码块中释放锁，以确保锁一定会被释放，避免死锁的发生。\n```\n\n###\n\n## Synchronized\n\n参考\n\n-   [详解Synchronized和Lock的实现原理及使用场景](https://zhuanlan.zhihu.com/p/622760822)\n\n\n\n### 使用方法\n\n```java\npublic class Counter {\n        private int count;\n\n        public synchronized void increment() {\n            count++;\n        }\n    }\n```\n\n### 实现原理\n\n```\nSynchronized是基于Java对象头的监视器（Monitor）实现的。\n每个Java对象都有一个监视器，同步块的进入和退出需要获取和释放对象的监视器。\n当线程尝试进入一个被锁住的同步块时，它会先尝试获取对象的监视器锁，如果锁已经被占用，线程就会进入阻塞状态，直到锁被释放\n```\n\n### 在使用时为什么要减小同步块的范围？\n\n```\n1.提高性能\n范围越大，需要等待获取锁的线程越多，导致在获取锁的过程中需要等待其他线程释放锁，而其他线程释放锁的时间也会比较长，这就会造成线程的等待时间过长，降低程序的运行效率。\n2.避免死锁\n不同的线程可能会竞争多个锁，释放锁的时间也会比较长，导致相互等待，形成死锁。\n\n因此，为了避免以上问题的发生，应该尽量减小同步块的范围，只在必要的地方进行同步，这样可以提高程序的性能，同时也可以降低出现死锁等问题的概率。\n```\n\n\n\n## Lock接口\n\n参考\n\n-   [详解Synchronized和Lock的实现原理及使用场景](https://zhuanlan.zhihu.com/p/622760822)\n\n\n\n### 什么是Lock接口\n\n```java\npublic interface Lock {\n    void lock(); \n    void lockInterruptibly() throws InterruptedException; \n    boolean tryLock(); \n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException; \n    void unlock(); Condition newCondition();\n}\n```\n\n```\nLock是Java中提供的一个接口，用于实现【线程同步机制】，它可以替代Synchronized关键字。\nLock接口提供了比Synchronized更灵活、更强大的线程同步功能，可以用于解决多线程中的资源竞争和死锁等问题。\nLock接口的实现类有很多种，其中最常用的是ReentrantLock。\n\nLock接口提供了以下主要方法：\n- lock()：获取锁，如果锁已经被其他线程获取，则当前线程进入等待状态。\n- unlock()：释放锁，如果当前线程持有锁，则释放锁并唤醒等待的线程。\n- tryLock()：尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true，否则立即返回false。\n- tryLock(long time, TimeUnit unit)：尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true，否则等待指定时间后返回false。\n- newCondition()：创建一个Condition对象，用于实现等待/通知机制。\n\n需要注意的是，在使用Lock接口时，需要在finally代码块中释放锁，以确保锁一定会被释放，避免死锁的发生。\n```\n\n### Lock的实现原理是什么？\n\n```\nLock的实现是基于Java的AbstractQueuedSynchronizer（AQS）框架的。\nLock接口定义了多个获取和释放锁的方法，其中比较重要的是lock()和unlock()方法。\n当一个线程调用lock()方法获取锁时，如果锁未被占用，则该线程会占用锁并继续执行；否则，该线程会进入阻塞状态，直到锁被释放。当一个线程调用unlock()方法释放锁时，会通知等待队列中的其他线程继续尝试获取锁。\n```\n\n### Lock的使用方式\n\n```java\npublic class Counter {\n    private int count;\n    private Lock lock = new ReentrantLock();\n\n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n### 为什么需要在finally代码块中释放锁\n\n```\n- 为什么？\n在使用Lock接口进行线程同步时，需要手动获取和释放锁，这是两个独立的操作，如果在获取锁之后发生异常，就有可能导致锁没有被释放，从而导致死锁等问题的发生。\n\n- 怎么样？\n因此，将释放锁的操作放在finally代码块中，这样可以确保在任何情况下都会释放锁，避免死锁等问题的发生。\n```\n\n\n\n## Lock和Synchronized的区别？\n\n```\n是什么 & 作用\nLock和Synchronized都是Java中用于实现线程同步的机制，它们的目的是为了避免线程间的竞争条件和数据不一致等问题。它们的区别如下：\n\n区别\n（1）实现方式：Synchronized是Java语言内置的关键字，而Lock是一个Java接口。\n（2）锁的获取和释放：Synchronized是隐式获取和释放锁，由Java虚拟机自动完成；而Lock需要显式地调用lock()方法获取锁，并且必须在finally块中调用unlock()方法来释放锁。\n（3）锁的粒度：Synchronized锁的粒度较粗，只能锁住整个方法或代码块，而Lock可以细粒度地控制锁的范围，比如锁某个对象的部分属性。\n（4）公平性：Synchronized不保证线程获取锁的公平性，而Lock可以通过构造函数指定公平或非公平锁。\n（5）场景：如果在简单的并发场景下，推荐使用Synchronized；而在需要更高级的锁控制时，可以考虑使用Lock。\n```\n\n\n\n\n\n\n\n## 队列同步器AQS  TODO\n\n\n\n## 重入锁ReentrantLock\n\n### 什么是重入锁？\n\n```\n- 是什么？\n可重入锁是指同一个线程在持有某个锁的情况下，可以继续获取该锁而不会出现死锁的情况\nSynchronized和ReentrantLock都是可重入锁。可重入锁通过记录持有锁的线程和重入次数，来避免死锁的发生。\n\n- synchronized关键字实现原理\n每个对象都有一个监视器锁（monitor），线程进入同步块时获取该对象的监视器锁，并在同步块结束时释放该锁，当一个线程在持有该锁的情况下再次进入同步块时，会自动获取该锁，而不会被阻塞。\n\n- ReentrantLock重入锁实现原理\n它使用一个计数器来记录线程获取锁的次数。当一个线程第一次获取锁时，计数器的值为1，当同一个线程再次获取锁时，计数器的值会递增，当线程退出同步块时，计数器的值递减，直到计数器的值为0时，锁被释放。这种机制保证了线程可以多次获取同一个锁而不会出现死锁的情况。\n```\n\n### 什么是ReentrantLock & 特点\n\n```\n- 是什么？\nReentrantLock是Java中实现Lock接口的一个类，它提供了与synchronized关键字类似的线程同步机制\n\n- 特点\n1.可重入性：\n\t与synchronized关键字一样，ReentrantLock支持可重入锁，即同一个线程可以多次获取同一个锁而不会死锁\n2.公平锁与非公平锁：\n\tReentrantLock提供了两种锁的实现方式，即公平锁和非公平锁。公平锁会按照线程的请求顺序来分配锁，而非公平锁则允许线程在竞争时插队，可能会导致某些线程长时间等待。\n3.条件变量：\n\tReentrantLock提供了Condition接口的实现类Condition，它可以将一个锁分为多个条件，使得线程可以在指定条件下等待和唤醒。这使得线程间的通信变得更加灵活。\n3.可中断性：\n\t与synchronized关键字不同，ReentrantLock提供了可中断锁的机制。即当一个线程等待获取锁时，可以通过中断等待的线程来结束等待。\n\nReentrantLock相对于synchronized关键字来说，具有更强的灵活性和可定制性，但需要手动获取和释放锁，使用时也需要注意避免死锁、饥饿等问题的发生。\n```\n\n### ReentrantLock为什么比Synchronized更灵活？\n\n```\nReentrantLock比Synchronized更灵活主要因为它提供了以下功能：\n（1）可以指定公平锁或非公平锁。\n（2）支持获取锁的超时时间。\n（3）支持可中断的获取锁操作。\n（4）可以通过tryLock()方法尝试获取锁，如果锁已经被占用，则返回false。\n（5）支持多个Condition对象，可以让线程在不同的条件下等待和唤醒。\n```\n\n\n\n### 什么是锁自旋？\n\n```\n锁自旋是一种优化锁竞争的技术，它用于减少线程在获取锁时的等待时间。\n当一个线程请求获取某个对象的锁时，如果此时锁已经被其他线程占用，那么该线程会进入阻塞状态等待锁的释放。而使用锁自旋技术，线程在发现锁被其他线程占用时，并不会立即进入阻塞状态，而是执行一段循环代码（称为自旋），等待锁的持有者释放锁。\n```\n\n\n\n### 公平锁与非公平锁\n\n\n\n## 读写锁\n\n### 什么是读写锁？\n\n```\n读写锁（ReadWriteLock）是Java中的一种同步机制，允许多个线程同时读共享资源，但只允许一个线程写共享资源。它是一种悲观锁，因为它默认情况下假设写操作比读操作更加耗时，因此优先考虑写操作的互斥。\n\n读写锁的主要特点是：\n1.在同一时刻可以允许多个线程进行读操作。\n2.写操作时独占锁，只有一个线程可以进行写操作。\n3.写操作和读操作之间互斥，即在一个线程进行写操作的时候，其他线程无法进行读和写操作，直到写操作完成。\n\n读写锁通常分为两种类型：读锁和写锁，写锁是独占锁，读锁是共享锁。在读锁被获取的情况下，其他线程仍然可以获取读锁，但不能获取写锁，因为写锁需要排除所有的读锁和其他的写锁。\n```\n\n\n\n### 读写锁的使用方式\n\n例子：非线程安全的HashMap作为缓存的实现\n\n```java\npublic class Cache {\n    private static final Map<String, Object>    map = new HashMap<String, Object>();\n    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    private static final Lock                   r   = rwl.readLock();\n    private static final Lock                   w   = rwl.writeLock();\n\n    public static final Object get(String key) {\n        r.lock();\t// 获取读锁，并发访问该方法时不会被阻塞\n        try {\n            return map.get(key);\n        } finally {\n            r.unlock();\n        }\n    }\n\n    public static final Object put(String key, Object value) {\n        w.lock();\t// 获取写锁，其他线程获取读、写锁会被阻塞，只有该写锁释放后才能继续操作\n        try {\n            return map.put(key, value);\n        } finally {\n            w.unlock();\n        }\n    }\n\n    public static final void clear() {\n        w.lock();\n        try {\n            map.clear();\n        } finally {\n            w.unlock();\n        }\n    }\n}\n```\n\n\n\n### 读写锁的实现\n\n#### 读写状态的设计\n\n#### 写锁的获取与释放\n\n#### 读锁的获取与释放\n\n#### 锁降级\n\n\n\n### Condition接口\n\n#### 使用方式\n\n##### 例子1\n\n```java\npublic class ConditionUseCase {\n    Lock      lock      = new ReentrantLock();\n    Condition condition = lock.newCondition();\n\n    public void conditionWait() throws InterruptedException {\n        lock.lock();\n        try {\n            condition.await();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void conditionSignal() throws InterruptedException {\n        lock.lock();\n        try {\n            condition.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n##### 例子2： 有界队列\n\n有界队列：是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素；\n\n当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”\n\n```java\npackage Lock;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class BoundedQueue <T> {\n    private Object[] items;\n    // 添加的下标，删除的下标和数组当前数量\n    private int       addIndex, removeIndex, count;\n    private Lock      lock      = new ReentrantLock();\n    private Condition notEmpty  = lock.newCondition();\n    private Condition notFull   = lock.newCondition();\n\n    public BoundedQueue(int size) {\n        items = new Object[size];\n    }\n\n    // 添加一个元素，如果数组满，则添加线程进入等待状态，直到有“空位”\n    public void add(T t) throws InterruptedException{\n        lock.lock();\n        try {\n            while(count  == items.length) {\n                notFull.await();\n            }\n            items[addIndex] = t;\n            if(++addIndex == items.length) {\n                addIndex = 0;\n            }\n            ++count;\n            notEmpty.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素\n    // @SuppressWarnings(\"unchecked\")注解告诉编译器忽略类型转换时的警告信息。Object类型的对象x强制转换为了泛型类型T\n    @SuppressWarnings(\"unchecked\")\n    public T remove() throws InterruptedException {\n        lock.lock();\n        try {\n            while(count == 0) {\n                notEmpty.await();\n            }\n            Object x = items[removeIndex];\n            if(++removeIndex == items.length) {\n                removeIndex = 0;\n            }\n            --count;\n            notFull.signal();\n            return (T) x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n\n\n### Condition的实现原理\n\nTODO\n","timestamp":1694102216563},{"name":"03-Java并发容器和框架.md","path":"008-JUC/001-Java并发编程/03-Java并发容器和框架.md","content":"# Java并发容器和框架\n\n## ConcurrentHashMap\n\n### HashMap为什么不是线程安全的？\n\n```java\nHashMap 不是线程安全的主要原因是它在进行 put 和 resize 操作时，没有进行同步处理。\n具体来说，在进行 resize 操作时，需要重新计算每个元素的索引位置，并且重新分配数组，如果多个线程同时进行 resize 操作，会导致多个线程在操作同一个数组，产生冲突，进而导致数据丢失或死循环等问题。\n另外，在进行 put 操作时，由于 HashMap 不是线程安全的，因此多个线程可能同时修改同一个链表，从而导致链表数据不一致或链表出现环等问题。\n\npublic class Test {\n    public static void main(String[] args) {\n        final HashMap<String, String> map = new HashMap<String, String>(2);\n        Thread t = Thread(new Runnable() {\n            public void run() {\n                for(int i = 0; i < 10000; i++) {\n                    new Thread(new Runnable() {\n                        @Override\n                        public void run() {\n                            map.put(UUID.randomUUID().toString(), \"\");\n                        }\n                    }, \"ftf\" + i).start();\n                }\n            }\n        }, \"ftf\");\n        t.start();\n        t.join();\n    }\n}\n```\n\n### HashMap的put操作为什么会出现环？原理是什么？\n\n```\n在 HashMap 内部，每个元素都是一个 Entry 对象，包含了键、值以及指向下一个 Entry 的指针，它们被存储在一个数组中。在执行 put 操作时，首先会计算 key 的哈希值，然后根据这个哈希值定位到数组中的一个索引位置。如果该索引位置为空，那么就将 Entry 对象放入该位置；如果该位置已经有了 Entry 对象，那么就顺着链表一直往下遍历，直到找到一个空的位置，并将 Entry 对象放入该位置。\n\n在多线程环境下，如果多个线程同时对 HashMap 进行 put 操作，可能会出现多个线程定位到了同一个索引位置，并且同时在链表头插入新的 Entry 对象，此时就会出现多个线程并发修改同一个链表的情况。这时就有可能出现覆盖的情况，即一个线程的修改被另一个线程覆盖了，导致数据丢失和死循环等问题。\n```\n\n\n\n### 为什么要使用ConcurrentHashMap？优势？\n\n```\n- 现有技术存在的问题\n1.【HashMap是线程非安全的】。\n\t在多线程环境下，使用hashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap\n2.【HashTable线程安全，但效率低下】\n  1）HashTable容器使用synchronized来保证线程安全，同一时刻只有一个线程能够访问哈希表，其他线程会被阻塞。一个线程put时其他线程不能put、get。\n  2）HashTable 在进行扩容时，需要将整个哈希表重新计算，并将数据复制到新的哈希表中，这也会导致性能的下降。\n  \n- ConcurrentHashMap的优势\n1.【线程安全】：ConcurrentHashMap是线程安全的，多个线程可以同时访问和修改ConcurrentHashMap中的元素，而不会导致数据结构的损坏或数据的丢失。\n2.【更高的并发性能】：ConcurrentHashMap的实现采用了分段锁的机制，对不同的数据段采用不同的锁，因此可以支持更高的并发性能，多个线程可以同时读取ConcurrentHashMap中的不同元素，而不会产生锁竞争。\n3.【更高的扩展性】：ConcurrentHashMap在扩容时可以分段进行扩容，只需要锁住当前需要扩容的数据段，而不需要锁住整个HashMap，因此扩容时可以支持更高的并发性能。\n4.【更好的迭代性能】：ConcurrentHashMap提供了一个专门的迭代器ConcurrentHashMap.KeySetView，可以在迭代过程中保证线程安全性和数据的一致性。\n```\n\n\n\n### 实现原理\n\nTodo\n\n\n\n## ConcurrentLinkedQueue\n\n### 实现安全队列的方法\n\n```\n1.使用阻塞算法\n  用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）来实现\n2.使用非阻塞算法\n  使用循环CAS的方式实现。即ConcurrentLinkedQueue的实现方式\n```\n\n### 是什么？\n\n```\nConcurrentLinkedQueue是Java中的一个线程安全的队列数据结构，可以被多个线程同时访问，支持高并发场景下的高效数据存储和访问。\n\n- 实现方式\nConcurrentLinkedQueue是基于链表实现的，它采用了一种叫做\"无锁并发编程\"的技术，利用CAS（Compare And Swap）操作和volatile关键字实现了线程安全。\n- 主要特点\n它的主要特点是在高并发情况下性能比较好，因为它没有使用锁，而是采用了一些比较高级的技术来实现并发控制，避免了因为锁竞争而导致的性能问题。\n\n- 基本操作\nConcurrentLinkedQueue支持队列的基本操作，包括入队（offer()）、出队（poll()）、获取队首元素（peek()）等。除此之外，它还提供了一些扩展操作，如批量添加元素（addAll()）、元素替换（replace()）等。\n- 主要缺点\n它的主要缺点是不支持随机访问，因为它是基于链表实现的，所以无法像ArrayList那样根据下标随机访问元素。\n```\n\n### 实现原理\n\nTODO\n\n\n\n## Java中的阻塞队列\n\n### 什么是阻塞队列？\n\n```\n\n```\n\n\n\n### 为什么使用？使用场景\n\n### Java中的阻塞队列\n\n```\nArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列\nLinkedBlockingQueue: 链表、无界队列\nPriorityBlockingQueue: 优先级排序、无界队列\nDelayQueue: 优先级队列实现的无界阻塞队列\nSynchronousQueue: 不存储元素的阻塞队列\nLinkedTransferQueue: 链表、无界阻塞队列\nLinkedBlockingQUeue: 链表、双向组设队列\n```\n\n### 实现原理\n\nTODO\n\n\n\n## Fork/Join框架\n\n### 是什么？\n\n```\n是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干小任务，最终汇总每个小任务结果后得到大任务结果的框架。\n```\n\n### 工作窃取算法\n\n### Fork/Join框架设计\n\n### 如何使用？\n\n### 实现原理\n\n\n\n","timestamp":1694102216563},{"name":"04-Java中的原子操作类.md","path":"008-JUC/001-Java并发编程/04-Java中的原子操作类.md","content":"# Java中的13个原子操作类\n\n## 原子更新基本类型类\n\n### 有哪些？\n\n```\nAtomicBoolean: 原子更新布尔类型\nAtomicInteger：原子更新整型\nAtomicLong：原子更新长整型\n```\n\n### 如何使用？\n\n三个类提供的方法几乎一摸一样，以`AtomicInteger`\n\n```\nint addAndGet(int delta)\nboolean compareAndSet(int expect, int update)  如果输入的数值等于预期值，则以原子方式将该值设置为输入的值\nint getAndIncrement() 以原子方式将当前值+1，返回自增前的值\nvoid lazySet(int newValue)\nint getAndSet(int newValue) 以原子方式设置为newValue值，返回旧值\n```\n\n### getAndIncrement实现原理\n\nTODO\n\n## 原子更新数组\n\n### 有哪些\n\n```\nAtomicIntegerArray 原子更新整型数组里的元素\nAtomicLongArray 原子更新长整型数组里的元素\nAtomicReferenceArray 原子更新引用类型数组里的元素\n```\n\n\n\n## 原子更新引用类型\n\n\n\n## 原子更新字段类","timestamp":1694102216563},{"name":"05-Java中的并发工具类.md","path":"008-JUC/001-Java并发编程/05-Java中的并发工具类.md","content":"# Java中的并发工具类\n\n## CountDownLatch\n\n### 是什么？有什么用？\n\n```\n\n```\n\n\n\n### 使用案例：模拟解析Excel里的多个sheel的数据\n\njoin()实现\n\n```java\npublic class JoinCountDownLatchTest {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread parser1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName());\n            }\n        });\n\n        Thread parser2 = new Thread(()->{\n            System.out.println(Thread.currentThread().getName());\n        }, \"parser2\");\n\n        parser1.start();\n        parser2.start();\n        parser1.join();\n        parser2.join();\n    }\n}\n```\n\nCountDownLatch实现\n\n```java\npublic class CountDownLatchTest {\n\n    static CountDownLatch c = new CountDownLatch(2);\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(()->{\n            System.out.println(1);\n            c.countDown();\n            System.out.println(2);\n            c.countDown();\n        }).start();\n\n        c.wait();\n        System.out.println(3);\n    }\n}\n```\n\n\n\n## 同步屏障CyclicBarrier\n\n### 是什么？\n\n```\nCyclicBarrier是Java中的一个同步辅助类，它可以让一组线程在某个屏障点处相互等待，然后同时继续执行。\n它的主要作用是实现线程间的同步，确保多个线程在某个点上达到同步状态后再同时执行后续操作。\n\nCyclicBarrier的构造函数可以指定一个参与同步的线程数量，当有足够数量的线程调用了CyclicBarrier的await()方法后，所有线程都会被释放，并继续执行后续的任务。\n\nCyclicBarrier适用于需要等待所有线程都到达某个状态后再同时执行后续操作的场景，常见的应用包括多线程计算任务的结果合并、分布式系统中任务的协调与等待等。\n```\n\n### 使用方法\n\n`CyclicBarrier(int parties)`\n\n`parties表示屏障拦截的线程数量`\n\n```java\npublic class CyclicBarrierTest {\n\n    static CyclicBarrier c = new CyclicBarrier(2);\t\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    c.await();\t\t// 调用await告诉CyclicBarrier已经到达屏障，然后阻塞；两个线程执行c.await()才继续执行\n                } catch (Exception e) {\n\n                }\n                System.out.println(1);\n            }\n        }).start();\n\n        try {\n            c.await();\n        } catch (Exception e) {\n\n        }\n        System.out.println(2);\n    }\n}\n```\n\n`CyclicBarrier(int parties, Runnable barrierAction)`\n\n`barrierAction表示到达屏障时优先执行的线程`\n\n```java\npublic class CyclicBarrierTest2 {\n\n    static CyclicBarrier c = new CyclicBarrier(2, new A());\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                try {\n                    c.await();\n                } catch (Exception e) {\n\n                }\n                System.out.println(1);\n            }\n        }).start();\n\n        try {\n            c.await();\n        } catch (Exception e) {\n\n        }\n        System.out.println(2);\n    }\n\n    static class A implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(3);\n        }\n\n    }\n\n}\n```\n\n### 应用场景\n\n```\nCyclicBarrier适用于需要等待所有线程都到达某个状态后再同时执行后续操作的场景，常见的应用包括多线程计算任务的结果合并、分布式系统中任务的协调与等待等。\n```\n\n```\n例子：用一个Excel保存了用户的所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户的日均银行流水：\n1 先用多线程处理每个sheet里的银行流水，都执行完后，得到每个sheet的日均银行流水\n2 barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水\n```\n\n```java\nimport java.util.concurrent.*;\nimport java.util.Map.Entry;\n\npublic class BankWaterService implements Runnable {\n\n    /* 创建4个屏障，处理完之后执行当前类的run方法 */\n    private CyclicBarrier c = new CyclicBarrier(4, this);\n\n    /* 假设有4个sheet， 所以只需要启动4个线程 */\n    private Executor executor = Executors.newFixedThreadPool(4);\n\n    /* 保存每个sheet计算出的银流结果 */\n    private ConcurrentHashMap<String, Integer> sheetBankWaterCount = new ConcurrentHashMap<>();\n\n    private void count() {\n        for(int i = 0; i < 4; i++) {\n            executor.execute(()->{\n                // 计算当前sheet的银流数据，计算代码省略\n                sheetBankWaterCount.put(Thread.currentThread().getName(), 1);\n\n                // 银流计算完成，插入一个屏障\n                try {\n                    c.await();\n                } catch (InterruptedException | BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n    }\n\n    public void run() {\n        int result = 0;\n        // 汇总每个sheet计算出的结果\n        for(Entry<String, Integer> sheet : sheetBankWaterCount.entrySet()) {\n            result += sheet.getValue();\n        }\n\n        // 将结果输出\n        sheetBankWaterCount.put(\"result: \", result);\n        System.out.println(result);\n    }\n\n    public static void main(String[] args) {\n        BankWaterService bankWaterService = new BankWaterService();\n        bankWaterService.count();\n    }\n}\n```\n\n## CountDownLatch和CyclicBarrier的区别\n\n```\n1.使用方式：CyclicBarrier用于一组线程中的多个线程等待彼此达到一个共同的屏障点后再同时继续执行；而CountDownLatch用于一个线程或多个线程等待其他线程完成某个操作后再继续执行。\n\n2.循环使用性：CyclicBarrier是可重用的，可以在多个循环中使用。当所有参与线程都到达屏障点后，CyclicBarrier会重置并可以再次使用；而CountDownLatch是一次性的，一旦计数器归零，就不能再次使用。\n\n3.参与线程数量：CyclicBarrier可以在创建时指定参与同步的线程数量，可以灵活地适应不同的场景需求；而CountDownLatch的计数器是固定的，一旦创建就无法修改。\n\n4.屏障动作：CyclicBarrier可以指定在所有线程到达屏障点时执行一个可选的屏障动作（Runnable）；而CountDownLatch没有提供屏障动作的功能。\n\n5.同步点的性质：CyclicBarrier是同步点，所有线程在此等待，直到所有线程都达到同步点才能继续执行；而CountDownLatch只是一个等待点，线程等待计数器变为0后就可以继续执行。\n```\n\n“一组线程中的多个线程等待彼此达到一个共同的屏障点后再同时继续执行” 和 “一个线程或多个线程等待其他线程完成某个操作后再继续执行”有啥区别\n\n```\n这两个描述之间的区别在于等待的对象和等待的条件。\n\n在CyclicBarrier中，一组线程中的多个线程等待彼此达到一个共同的屏障点后再同时继续执行。这意味着每个线程在达到屏障点之前都会阻塞等待其他线程的到来。只有当所有线程都到达屏障点后，它们才会同时继续执行后续操作。\n\n而在CountDownLatch中，一个线程或多个线程等待其他线程完成某个操作后再继续执行。这意味着某个线程或多个线程会调用CountDownLatch的await()方法进行等待，直到其他线程完成特定操作并调用CountDownLatch的countDown()方法将计数器减少到0，等待的线程才会被唤醒并继续执行。\n\n总的来说，CyclicBarrier用于多个线程之间相互等待达到一个共同的屏障点，而CountDownLatch用于一个或多个线程等待其他线程完成某个操作。CyclicBarrier是多线程间的同步，而CountDownLatch是线程间的等待和通信。\n```\n\n## 控制并线程数的semaphore\n\n### 是什么？使用场景？\n\n```\nSemaphore（信号量）是Java中的一个同步工具类，用于控制同时访问某个资源的线程数量。\n\nSemaphore维护了一组许可（permits），线程在访问资源之前必须先获取许可，如果许可数大于0，则线程可以获取许可并继续执行；如果许可数等于0，则线程必须等待，直到有其他线程释放许可。\n```\n\n### 主要特点\n\n```\nSemaphore的主要特点包括：\n\n1.许可数量：Semaphore可以指定初始化时的许可数量，表示可以同时访问某个资源的线程数量。\n\n2.许可获取和释放：线程可以通过acquire()方法获取许可，如果许可数大于0，则线程可以继续执行；否则，线程会被阻塞等待。线程在使用完资源后，需要通过release()方法释放许可，以供其他线程使用。\n\n3.公平性：Semaphore可以选择是否使用公平的获取许可的策略。如果设置为公平模式，那么等待时间最长的线程将优先获得许可。\n```\n\n### 使用场景\n\n```\nSemaphore适用于控制对某个资源的并发访问数量，例如限制数据库连接数、限制线程池的线程数等场景。通过合理地控制许可数量，可以避免资源过度竞争和线程的过度并发，从而保证系统的稳定性和性能。\n```\n\n### 使用方式\n\n```java\npublic class SemaphoreTest {\n\n    private static final int       THREAD_COUNT = 30;\t\t// 线程数\n\n    private static ExecutorService threadPool   = Executors.newFixedThreadPool(THREAD_COUNT);\n\n    private static Semaphore       s            = new Semaphore(10);\t\t// 最大并发数\n\n    public static void main(String[] args) {\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        s.acquire();\t// 获取许可证\n                        System.out.println(\"save data\");\n                        s.release();\t// 释放许可证\n                    } catch (InterruptedException e) {\n                    }\n                }\n            });\n        }\n\n        threadPool.shutdown();\n    }\n}\n\n```\n\n\n\n## 线程间交换数据的Exchanger\n\n### 是什么？\n\n```\nExchanger（交换器）是Java中的一个同步工具类，用于两个线程之间进行数据交换。\n\nExchanger提供一个点，两个线程可以通过该点交换数据。其中，一个线程会调用exchange()方法来等待另一个线程到达交换点，并将自己的数据传递给另一个线程。当两个线程都到达交换点时，它们会交换数据，并继续执行后续操作。\n```\n\n### 主要特点\n\n```\n1.数据交换：两个线程可以在交换点交换数据，通过exchange()方法来进行数据的发送和接收。\n\n2.线程同步：交换操作是同步的，即当一个线程调用exchange()方法时，如果另一个线程未到达交换点，则会阻塞等待，直到另一个线程到达交换点为止。\n\n3.数据一致性：通过Exchanger交换的数据可以保证在两个线程之间是一致的，即发送方线程传递的数据会被接收方线程接收到。\n```\n\n### 应用场景\n\n```\nExchanger适用于需要两个线程之间进行数据交换的场景，例如线程间的数据传递、协作计算等。通过Exchanger，可以实现线程之间的数据共享和协作，从而提高并发编程的灵活性和效率。\n```\n\n### 使用方式\n\n例子：将纸质银行流水通过人工方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel后，系统需要加载这两个Excel，并对数据进行校对，看录入是否一致。\n\n```java\npublic class ExchangerTest {\n\n    private static final Exchanger<String> exgr       = new Exchanger<String>();\n\n    private static ExecutorService         threadPool = Executors.newFixedThreadPool(2);\n\n    public static void main(String[] args) {\n\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    String A = \"银行流水A\";// A录入银行流水数据\n                    exgr.exchange(A);\n                } catch (InterruptedException e) {\n                }\n            }\n        });\n\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    String B = \"银行流水B\";// B录入银行流水数据\n                    String A = exgr.exchange(\"B\");\n                    System.out.println(\"A和B数据是否一致：\" + A.equals(B) + \"，A录入的是：\" + A + \"，B录入是：\" + B);\n                } catch (InterruptedException e) {\n                }\n            }\n        });\n\n        threadPool.shutdown();\n\n    }\n}\n```\n\n","timestamp":1694102216563},{"name":"06-Java中的线程池.md","path":"008-JUC/001-Java并发编程/06-Java中的线程池.md","content":"# Java中的线程池\n\n## 线程池概述\n\n### 是什么？\n\n```\nJava中的线程池是一种用于管理和复用线程的机制，它可以有效地管理线程的创建、销毁和复用，从而提高应用程序的性能和资源利用率。\n\nJava中的线程池是通过Executor框架来实现的，主要包括以下几个核心组件：\n1.Executor接口：\n\t定义了线程池的执行方法，用于提交任务。\n2.ExecutorService接口：\n\t继承自Executor接口，提供了更丰富的线程池操作方法，例如任务提交、任务执行状态管理、线程池的关闭等。\n2.ThreadPoolExecutor类：\n\t是Java中默认的线程池实现类，实现了ExecutorService接口。它提供了可配置的线程池，可以根据需要自定义线程池的核心线程数、最大线程数、线程空闲时间等参数。\n```\n\n### 优点\n\n```\n（1）减少线程创建和销毁开销：线程池可以重用已创建的线程，避免了频繁创建和销毁线程的开销。\n（2）控制并发度：线可以限制并发线程的数量，通过控制核心线程数、最大线程数和任务队列的大小来控制线程池的并发度，避免系统资源被过度占用。\n（3）提高响应速度：可以更快地获取到可用线程，从而更快地处理任务。\n（4）统一管理：线程池可以统一管理线程的生命周期、状态和执行结果，方便任务的提交、取消和获取执行结果。\n```\n\n\n\n## 实现原理\n\n![image-20230513125820492](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/13/12582016839539001683953900698IOTwhM-image-20230513125820492.png)\n\n![image-20230513125913452](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/13/12591316839539531683953953567PnBFMg-image-20230513125913452.png)\n\n工作流程：\n```\n1 创建线程池时，线程池中线程数为0\n2 调用execute()添加一个请求任务时：\n\t2.1 当前运行线程数 < corePoolSize   ==> 创建新线程执行任务（执行这一步需要获取全局锁）\n\t2.2 当前运行线程数 >= corePoolSize  ==> 将任务加入BlockingQueue\n\t2.3 如果BlockingQueue已满 & 正在运行线程数 < maximumPoolSize\t ==> 创建非核心线程处理任务（执行这一步需要获取全局锁）\n\t2.4 如果BlockingQueue已满 & 正在运行线程数 >= maximumPoolSize  ==> 按照饱和拒绝策略执行\n3 当工作线程执行完任务后，会从队列中取出任务执行；如果没有待执行的任务，则线程进入空闲状态，等待新的任务分配。\n4 当一个线程空闲超过一定时间（keepAliveTime）：\n\t4.1 当前运行线程数 >= corePoolSize\t\t==> 停掉线程\n\t4.2 线程池的所有任务执行完成，会收缩到corePoolSize的大小\n```\n\n## 线程池的使用\n\n### 拒绝策略\n\n```\n（1）CallerRunsPolicy: 使用调用者所在线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能上损失较大。\n（2）AbortPolicy（默认）: 抛出拒绝执行RejectedExecutionException异常来拒绝任务。必须处理好抛出的异常，否则会打断当前执行流程，影响后续的任务执行\n（3）DiscardPolicy: 直接丢弃。\n（4）DiscardOldestPolicy: 丢弃阻塞队列中等待时间最久的任务，并加入新任务\n```\n\n### 线程池的创建\n\n方式一：通过`ThreadPoolExecutor`构造函数来创建（推荐）\n\n```java\nnew ThreadPoolExecutor (\n    corePoolSize, \t\t// 线程池的核心线程数\n    maximumPoolSize,  // 能容纳的最大线程数\n    keepAliveTime, \t\t// 空闲线程存活时间\n    unit, \t\t\t\t\t\t// 时间单位\n    workQueue, \t\t\t\t// 任务队列，用来储存等待执行任务的队列\n    threadFactory, \t\t// 创建线程的工厂类\n    handler\t\t\t\t\t\t// 等待队列满后的拒绝策略\n  );\n```\n\n方式二：通过 `Executor` 框架的工具类 `Executors` 来创建。\n\n```\n（1）SingleThreadExecutor：只有一个线程\n（2）FixedThreadPool：固定线程数量\n（3）CachedThreadPool：可根据实际情况调整线程数量\n（4）ScheduledThreadPool：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。\n```\n\n### 线程池常用的阻塞队列有哪些？\n\n```\n\n```\n\n\n\n### 向线程池提交任务\n\n#### 方式一：execute()\n\n```java\n// 用于提交不需要返回值的任务，无法判断任务是否被线程池执行成功\nthreadsPool.execute(new Runnable() {\n  public void run() {\n    \n  }\n})\n```\n\n#### 方式二：submit()\n\n```java\n// 用于提交需要返回值的任务。\n// 线程池会返回一个future类型的对象，通过这个对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程知道任务完成; 通过get(long timeout, TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候任务可能没有执行完。\nFuture(Object) future = executor.submit(harReturnValuetask);\ntry {\n\tObject s- future.get();\n} catch (InterruptedExeception e) {\n  // 处理中断异常\n} catch(ExecutionException e) {\n  // 处理无法执行任务异常\n} finally {\n  // 关闭线程池\n  executor.shutdown();\n}\n\n```\n\n### 关闭线程池\n\n```\n可以调用线程池的shutdown或shutdownNow方法来关闭线程池。\n\n原理：\n它们的原理都是遍历线程池中工作线程，逐个调用线程中的interrupt方法来中断，所以无法响应中断的任务可能永远无法停止。\n\nshutdown()\n(1) 它将使执行器停止接受新任务，但它将继续执行所有已提交的任务\n(2) 所有在调用shutdown()方法时在执行器中排队但尚未开始执行的任务也将执行。\n(3) 所有在调用shutdown()方法时在执行器中排队但尚未开始执行的任务也将执行。\n\nshutdownNow()\n(1) 它将尝试停止所有正在执行的活动任务、暂停处理尚未开始执行的任务，并返回一个包含那些未开始执行的任务的列表。\n(2) 它不保证能够停止正在处理的任务，但会尽最大努力尝试这样做。\n\n\n区别：\nshutdownNow先将线程池的状态设置为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。\nshutdown只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行任务的线程\n\n共同点：\n调用任意一个关闭方法，isShutdown方法就会返回true。\n当所有的任务都已经关闭后，才表示线程池关闭成功，调用isTerminaed方法会返回true。\n\n如何选择：\n通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以选择shutdownNow方法。\n```\n\n\n\n### 为什么不允许 Executors.的方式手动创建线程池\n\n![image-20230514202727417](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/14/20272716840672471684067247591WgZgej-image-20230514202727417.png)\n\n```\n（1）通过ThreadPoolExecutor创建及其七个参数，可以让其他人能更加明确线程池的运行规则，规避资源耗尽的风险\n（2）通过Executors创建的线程池会存在一些隐患\n\t\t- FixedThreadPool和SingleThreadPool:允许「请求队列长度」为Integer.MAX_VALUE, 可能会堆积大量请求，导致OOM\n\t\t- CachedThreadPool和ScheduledThreadPool：允许「创建线程数量」为Integer.MAX_VALUE, 可能会创建大量的线程，从而导致OOM\n```\n\n\n\n\n\n### 入门案例\n\n```\n场景：火车站3个售票口，10个用户买票\n```\n\n```java\npackage ThreadPool;\n\nimport java.util.concurrent.*;\n\npublic class ThreadPoolDemo1 {\n\n    public static void main(String[] args) {\n        // 定义线程池，线程数量为3，模拟3个窗口\n        ExecutorService threadService = new ThreadPoolExecutor(\n                3,\n                3,\n                60L,\n                TimeUnit.SECONDS,\n                new LinkedBlockingQueue<>(),\n                Executors.defaultThreadFactory(),\n                new ThreadPoolExecutor.DiscardOldestPolicy()\n        );\n\n        // 10个人买票\n        try {\n            for(int i = 1; i <= 10; i++) {\n                threadService.execute(()->{\n                    try {\n                        System.out.println(Thread.currentThread().getName() + \"窗口，开始卖票\");\n                        Thread.sleep(5000);\n                        System.out.println(Thread.currentThread().getName() + \"窗口，买票结束\");\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                });\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            // 完成后结束\n            threadService.shutdown();\n        }\n    }\n}\n\n// 输出\npool-1-thread-1窗口，开始卖票\npool-1-thread-3窗口，开始卖票\npool-1-thread-2窗口，开始卖票\npool-1-thread-3窗口，买票结束\npool-1-thread-1窗口，买票结束\npool-1-thread-3窗口，开始卖票\npool-1-thread-1窗口，开始卖票\npool-1-thread-2窗口，买票结束\npool-1-thread-2窗口，开始卖票\npool-1-thread-3窗口，买票结束\npool-1-thread-3窗口，开始卖票\npool-1-thread-1窗口，买票结束\npool-1-thread-1窗口，开始卖票\npool-1-thread-2窗口，买票结束\npool-1-thread-2窗口，开始卖票\npool-1-thread-1窗口，买票结束\npool-1-thread-1窗口，开始卖票\npool-1-thread-2窗口，买票结束\npool-1-thread-3窗口，买票结束\npool-1-thread-1窗口，买票结束\n```\n\n\n\n\n\n\n\n# Executor框架\n\n## 概述\n\n### 是什么？\n\n```\nExecutor 框架是 Java 并发编程中提供的一个高级工具，用于简化多线程编程中线程的管理和任务的执行。它提供了一组接口和类，用于创建和管理线程池，提交任务，执行任务，并处理任务的完成结果。\n```\n\n### 已经有了线程池，为什么还需要Executor？\n\n```\n我们知道线程池就是线程的集合，线程池集中管理线程，以实现线程的重用，降低资源消耗，提高响应速度等。线程用于执行异步任务，单个的线程既是工作单元也是执行机制，从JDK1.5开始，为了把工作单元与执行机制分离开，Executor框架诞生了，他是一个用于统一创建与运行的接口。Executor框架实现的就是线程池的功能。\n```\n\n## Executor框架的结构\n\n```\nExecutor框架包括3大部分：\n（1）任务。也就是工作单元，包括被执行任务需要实现的接口：Runnable接口或者Callable接口；\n（2）任务的执行。也就是把任务分派给多个线程的执行机制，包括Executor接口及继承自Executor接口的ExecutorService接口。\n（3）异步计算的结果。包括Future接口及实现了Future接口的FutureTask类。\n\n```\n\n### Executor框架的成员及其关系\n\n![Java并发——Executor框架详解_Java并发](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/07/15515716940731171694073117712dRkPoT-22181516840738951684073895234TFvjIo-resize,m_fixed,w_1184-20230514221815144.jpg)\n\n### Executor框架的使用示意图\n\n![Java并发——Executor框架详解_线程池_02](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/07/15515716940731171694073117988YSmcyg-22184616840739261684073926767ZzkXVL-resize,m_fixed,w_1184-20230514221846665.jpg)\n\n### 使用步骤\n\n1.**创建 Executor 实例**：\n\n根据需要选择合适的 Executor 实现类来创建 Executor 实例。常见的实现类有 `ThreadPoolExecutor`、`ScheduledThreadPoolExecutor` 等。可以使用它们的构造函数或者工厂方法来创建 Executor 实例。\n\n```java\n// 创建ThreadPoolExecutor示例。 ThreadPoolExecutor可以替换为其父类ExecutorService 或 Executor\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n    2,  // 核心线程数\n    5,  // 最大线程数\n    1,  // 空闲线程存活时间\n    TimeUnit.SECONDS,  // 时间单位\n    new LinkedBlockingQueue<>() // 任务队列\n);\n\n\n// 创建 ScheduledExecutorService 实例\nScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n```\n\n2.**创建任务**：创建待执行的任务，可以实现 `Runnable` 接口或 `Callable` 接口，具体根据业务需求来定义任务的逻辑。\n\n```java\n// Runnable 无返回值\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Hello\")\n    }\n}\n\n// Callable 有返回值\nclass callableTest implements Callable<String >{\n  \t@Override\n  \tpublic String call() {\n      return \"Hello\";\n   }\n}\n```\n\n3.**提交任务**：使用 Executor 实例的 `execute(Runnable)` 方法或 `submit(Callable)` 方法将任务提交给 Executor 执行。`execute` 方法适用于不需要获取任务执行结果的情况，而 `submit` 方法适用于需要获取任务执行结果的情况。\n\n```java\n// 提交Runnable任务\nexecutor.execute(runnaleTask);\n\n// 提交Callable任务\nexecutor.submit(callableTask);\n```\n\n4.**等待任务执行完成**（可选）：根据需要，可以使用 `Future` 对象来等待任务执行完成并获取任务的执行结果。`submit` 方法返回一个 `Future` 对象，可以使用它的 `get()` 方法来阻塞等待任务执行完成并获取结果。\n\n```java\n// 提交任务给 Executor 执行，并获取 Future 对象\nFuture<String> future = executor.submit(callableTask);\n\n// 等待任务执行完成并获取结果\ntry {\n    String result = future.get();\t\t// get会阻塞等人任务完成\n    System.out.println(\"Task Result: \" + result);\n} catch (Exception e) {\n    e.printStackTrace();\n}\n```\n\n5.**关闭 Executor**：在不再需要执行新任务时，需要显式地关闭 Executor。可以调用 Executor 的 `shutdown()` 方法来平滑地关闭 Executor，它会等待所有已提交的任务执行完成后再关闭 Executor。也可以调用 `shutdownNow()` 方法来立即关闭 Executor，它会尝试中断正在执行的任务并返回尚未执行的任务列表。\n\n```java\n// 方式1\nexecutor.shutdown();\n\n// 方式2\nexecutor.shutdownNow();\n```\n\n### Executor框架成员\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/07/15515816940731181694073118285HcH1eD-131438168412767816841276789411OIKxd-20180318215737261.jpeg\" alt=\"img\" style=\"zoom: 67%;\" />\n\n#### ThreadPoolExecutor\n\n```\nSingleThreadExecutor\nFixedThreadPool\nCachedThreadPool\n```\n\n\n\n##### SingleThreadExecutor\n\n作用 & 场景\n\n```\n（1）这是一个只有一个线程的线程池。这可以确保所有任务都在一个线程中按顺序完成\n\n创建一个使用单个worker线程的 Executor，以无界队列方式来运行该 线程。\n（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程， 那么如果需要，一个新线程将代替它执行后续的任务）。\n可保证顺序地执行各 个任务，并且在任意给定的时间不会有多个线程是活动的。\n与其他等效的 newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。\n\n适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个 线程的场景\n```\n\n特点\n\n```\n线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此 执行\n```\n\n创建方式\n\n```java\nExecutorService executor = Executors.newSingleThreadExecutor();\n```\n\n源码\n\n```java\npublic static ExecutorService newSingleThreadExecutor() { \n    return new ThreadPoolExecutor(\n        1, \n        1, \n        0L, \n        TimeUnit.SECONDS, \n        new LinkedBlockingQueue<>(), \n        Executors.defaultThreadFactory(), \n        new ThreadPoolExecutor.AbortPolicy()\n    );\n}\n```\n\n\n\n##### FixedThreadPool\n\n作用 & 场景\n\n```\n（1）该线程池在创建时就固定了线程的数量，即使某些线程当前没有任务执行，它们也会被保持活跃状态。\n（2）如果提交的任务数少于线程池的线程数量，那么每个任务将立刻由一个独立的线程来执行。\n（3）如果任务数超过线程数量，额外的任务将被放在一个队列中等待，一旦有线程空闲就会从队列中取出任务来执行。\n\n\n适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严 格限制的场景\n```\n\n特点\n\n```\n特征：\n（1）线程池中的线程处于一定的量，可以很好的控制线程的并发量\n（2）线程可以重复被使用，在显示关闭之前，都将一直存在\n（3）超出一定量的线程被提交时候需在队列中等待\n```\n\n创建方式\n\n```java\nExecutorService executor = Executors.newFixedThreadPool(nThreads);\n```\n\n源码\n\n```java\npublic static ExecutorService newFixedThreadPool() { \n    return new ThreadPoolExecutor(\n      10, \n      10, \n      0L, \n      TimeUnit.SECONDS, \n      new LinkedBlockingQueue<>(), \n      Executors.defaultThreadFactory(), \n      new ThreadPoolExecutor.AbortPolicy()\n    );\n}\n```\n\n\n\n##### CachedThreadPool\n\n作用 & 场景\n\n```\n（1）创建一个可缓存线程池，该线程池最初没有任何线程。\n（2）当一个任务被提交时，线程池会尝试使用现有的空闲线程来执行该任务。\n（3）如果所有线程都在执行任务（或没有线程），它将创建一个新的线程来执行这个任务。\n（4）如果某个线程在一段时间内没有执行任何任务，它将被回收，从而减少系统资源的占用。\n```\n\n特点\n\n```\n线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）\n线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）\n当线程池中，没有可用线程，会重新创建一个线程\n```\n\n创建方式\n\n```\nExecutorService executor = Executors.newCachedThreadPool();\n```\n\n源码\n\n```java\npublic static ExecutorService newCachedThreadPool(){ \n  return new ThreadPoolExecutor(\n    0, \n    Integer.MAX_VALUE, \n    60L, \n    TimeUnit.SECONDS, \n    new SynchronousQueue<>(), \n    Executors.defaultThreadFactory(), \n    new ThreadPoolExecutor.AbortPolicy()\n  );\n}\n```\n\n\n\n#### ScheduledThreadPoolExecutor\n\n##### ScheduledThreadPoolExecutor\n\n##### SingleThreadScheduledExecutor\n\n\n\n#### ForkJoinPool\n\n```\n这是一个支持大规模并发任务的线程池，它主要用于“分而治之”的任务，即任务可以分解为更小的子任务并行执行。\n```\n\n\n\n\n\n","timestamp":1694102216563},{"name":"08-场景题.md","path":"008-JUC/001-Java并发编程/08-场景题.md","content":"### **一个请求A，需要得到B和C的返回结果**。\n\n```java\n使用wait和notify\n\npublic class WaitNotifyExample {\n    private Object lock = new Object();\n    private boolean isBCompleted = false;\n    private boolean isCCompleted = false;\n\n    public void requestA() {\n        Thread thread = new Thread(() -> {\n            synchronized (lock) {\n                while (!isBCompleted || !isCCompleted) {\n                    try {\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                System.out.println(\"Request A is processed after B and C.\");\n            }\n        });\n        thread.start();\n    }\n\n    public void completeB() {\n        new Thread(() -> {\n            // Simulating some work\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (lock) {\n                isBCompleted = true;\n                System.out.println(\"Request B is completed.\");\n                lock.notifyAll();\n            }\n        }).start();\n    }\n\n    public void completeC() {\n        new Thread(() -> {\n            // Simulating some work\n            try {\n                Thread.sleep(1500);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (lock) {\n                isCCompleted = true;\n                System.out.println(\"Request C is completed.\");\n                lock.notifyAll();\n            }\n        }).start();\n    }\n\n    public static void main(String[] args) {\n        WaitNotifyExample example = new WaitNotifyExample();\n        example.requestA();\n        example.completeB();\n        example.completeC();\n    }\n}\n\n```\n\n### [写两个线程打印 1-n，一个线程打印奇数，一个线程打印偶数](https://mp.weixin.qq.com/s/DLHpyEXTHHotxEYZd8P0KQ)\n\n```java\npublic class OddEvenPrinter {\n    private final Object lock = new Object();\n    int current = 1;\n    private final int n;\n\n    public OddEvenPrinter(int n) {\n        this.n = n;\n    }\n\n    public void printOdd() throws InterruptedException {\n        synchronized(lock) {\n            while(current <= n) {\n                while(current % 2 == 0) {\n                    lock.wait();\n                }\n\n                if(current <= n) {\n                    System.out.println(Thread.currentThread().getName() + \" - \" + current);\n                    current++;\n                    lock.notify();\n                }\n            }\n        }\n    }\n\n    public void printEven() throws InterruptedException {\n        synchronized(lock) {\n            while(current <= n) {\n                while(current % 2 != 0) {\n                    lock.wait();\n                }\n\n                if(current <= n) {\n                    System.out.println(Thread.currentThread().getName() + \" - \" + current);\n                    current++;\n                    lock.notify();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"===OddEvenPrinter===\");\n        OddEvenPrinter oddEvenPrinter = new OddEvenPrinter(100);\n        Thread thread = new Thread(()->{\n            try {\n                oddEvenPrinter.printOdd();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"OddThread\");\n\n        Thread thread2 = new Thread(()->{\n            try {\n                oddEvenPrinter.printEven();\n            } catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"EvenThread\");\n\n        thread.start();\n        thread2.start();\n    }\n}\n```\n\n","timestamp":1694102216563}]