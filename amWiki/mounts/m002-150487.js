if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m002']=[{"name":"000-Java基础.md","path":"002-数据结构与算法/000-Java基础.md","content":"资料\n\n-   [灵茶山艾府](https://github.com/EndlessCheng)\n\n\n\n## map\n\n```java\nList<String> list = map.getOrDefault(key, new ArrayList<String>())\n\n// map转list\nList<List<String>> list = new ArrayList<List<String>>(map.values()); \n\n// 初始化赋值\nMap<String, String> map  = new HashMap<String, String>() { {\n  put(\"key1\", \"value1\");\n  put(\"key2\", \"value2\");\n} };\n```\n\n\n\n## list\n\n```java\nList<List<Integer>> res = new ArrayList<>();\nres.add(Arrays.asList(nums[i], nums[l], nums[r]));\n```\n\n统计字母出现次数\n\n```java\nint[] counts = new int[26];\nint length = str.length();\nfor (int i = 0; i < length; i++) {\n  \tcounts[str.charAt(i) - \'a\']++;\n}\n```\n\nlist转数组\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\n\n// 转换为对象数组\nObject[] array = list.toArray();\n\n// 转换为Integer类型的数组\nInteger[] array = list.toArray(new Integer[list.size()]);\n\n// 使用流API转换为Integer类型的数组\nInteger[] array = list.stream().toArray(Integer[]::new);\n```\n\n","timestamp":1692285118436},{"name":"01-滑动窗口.md","path":"002-数据结构与算法/001-数组/01-滑动窗口/01-滑动窗口.md","content":"# [滑动窗口](https://labuladong.github.io/algo/di-ling-zh-bfe1b/wo-xie-le--f02cd/)\n\n## 什么时候考虑用滑动窗口？\n\n```\n相当给你一个 S 和一个 T，请问你 S 中是否存在一个子串，包含 T 中所有字符且不包含其他字符？\n```\n\n\n\n## 模版\n\n**开始套模板，只需要思考以下几个问题**：\n\n```\n1、什么时候应该移动 `right` 扩大窗口？窗口加入字符时，应该更新哪些数据？\n2、什么时候窗口应该暂停扩大，开始移动 `left` 缩小窗口？从窗口移出字符时，应该更新哪些数据？\n3、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？\n```\n\n注意\n\n-   Java 中的 Integer 和 String 这种包装类不能直接用 `==` 进行相等判断，而应该使用类的 `equals` 方法\n\n```java\n/* 滑动窗口算法框架 */\npublic void slidingWindow(string s) {\n    Map<Character, Integer> window = new HashMap<>();\t\t// 可用数组优化\n    \n  \t// [)区间\n    int left = 0, right = 0;\n    while (right < s.size()) {\n        // c 是将移入窗口的字符\n        char c = s.charAt(right);\n        // 增大窗口\n        right++;\n        // TODO: 进行窗口内数据的一系列更新\n        ...\n\n        /*** debug 输出的位置 ***/\n        // 注意在最终的解法代码中不要 print,因为 IO 操作很耗时，可能导致超时\n       System.out.println(\"window: \" + left + \" \" + right);\n        /********************/\n        \n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // d 是将移出窗口的字符\n            char d = s.charAt(left);\n            // 缩小窗口\n            left++;\n            // TODO: 进行窗口内数据的一系列更新\n            ...\n        }\n    }\n}\n```\n\n### 最小窗口模版\n\n```java\nwhile j < len(nums):\n    判断[i, j)是否满足条件\n    while 满足条件：\n        不断更新结果(注意在while内更新！)\n        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）\n    j += 1\n\n链接：https://leetcode.cn/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/\n```\n\n### 最大窗口模版\n\n```java\nwhile j < len(nums):\n    判断[i, j)是否满足条件\n    while 不满足条件：\n        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）\n    不断更新结果（注意在while外更新！）\n    j += 1\n\n链接：https://leetcode.cn/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/\n```\n\n\n\n## 题目\n\n\n\n### [3.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n\n最大窗口\n\n```\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> window = new HashMap<>();\n        int l = 0;\n        int r = 0;\n        int res = 0;\n        while(r < s.length()) {\n            char ch = s.charAt(r);\n            r++;\n\n            window.put(ch, window.getOrDefault(ch, 0) + 1);\n\n            while(window.get(ch) > 1) {\n                char del = s.charAt(l);\n                l++;\n\n                window.put(del, window.get(del) - 1);\n            }\n            res = Math.max(res, r - l);\n        }\n\n        return res;\n    }\n}\n```\n\n另一种写法（以上面写法为主）\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> window = new HashMap<>();   // <字符，下标>\n        int maxLen = 0;\n        int left = 0, right = 0;\n        while(right < s.length()) {\n            char ch = s.charAt(right);\n            int index = right;\n            right++;\n            if(window.containsKey(ch)) {\n               // left = map.get(ch) + 1; // 错解1\n                left = Math.max(left, window.get(ch) + 1);\n            }\n            window.put(ch, index);\n            maxLen = Math.max(maxLen, right - left);\n        }\n\n        return maxLen;\n    }\n}\n```\n\n错解1分析\n\n```\n考虑abba\na，b进map，此时遍历到b，map中已经含有，left = get(b) + 1 = 2;\n此时遍历到a，map中还是含有a，left = get(a) + 1 = 1, 而实际上left左边的已经在窗口之外，不在考虑范围。\n```\n\n\n\n\n\n\n\n###  209.[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)\n\n```\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n```\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int l = 0;\n        int r = 0;\n        int sum = 0;\n        int res = Integer.MAX_VALUE;\n        while(r < nums.length) {\n            int chIndex = r;\n            r++;\n            sum += nums[chIndex];\n\n            while(sum >= target) {\n                res = Math.min(res, chIndex - l + 1);\n                sum -= nums[l];\n                l++;\n            }\n        }\n\n        return res == Integer.MAX_VALUE ? 0 : res;\n    }\n}\n```\n\n\n\n### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)\n\n求最小窗口\n\n```\n输入：s = \"ADOBECODEBANC\", t = \"ABC\"\n输出：\"BANC\"\n解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 \'A\'、\'B\' 和 \'C\'。\n\n```\n\n思路：\n\n1.   我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」\n\n     ```\n     PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动（扩大）一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。\n     ```\n\n2.   我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T`中的所有字符）。\n\n3.   此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。\n\n4.   重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。\n\n```java\nclass Solution {\n    public String minWindow(String s, String t) {\n        Map<Character, Integer> window = new HashMap<>();\t\t// 窗口中已有的需要的字符个数\n        Map<Character, Integer> need = new HashMap<>();\t\t\t// 需要的字符个数\n        for(char ch : t.toCharArray()) {\n             need.put(ch, need.getOrDefault(ch, 0) + 1);\n        }\n      \n      \n        int left = 0;\n        int right = 0;\n        int valid = 0; // 表示窗口中满足 need 条件的字符个数。如need中a=2，b=3，则window中a=2时valid++,valid=2时表示a数量满足，b也满足\n        int start = 0, len = Integer.MAX_VALUE;\t// 记录最小覆盖子串的起始索引及长度\n\n        while(right < s.length()) {\n            char ch = s.charAt(right);\n            right++;\n            if(need.containsKey(ch)) {\t\t// 注意：window只记录有用的字符即可\n                window.put(ch, window.getOrDefault(ch, 0) + 1);\n                if(window.get(ch).equals(need.get(ch))) valid++;\t\t// 注意：要用equals\n            }\n\n            // System.out.println(\"window: \" + left + \" \" + right);\n\n            while(valid == need.size()) {\n              \t// 在这里更新最小覆盖子串\n                if(right - left < len) {\n                    start = left;\n                    len = right - left;\n                }\n              \t// delCh 是将移出窗口的字符，窗口左边右移\n                char delCh = s.charAt(left);\n                left++;\n                if(need.containsKey(delCh)) {  // 如果要删除的字符是need中的字符\n                    if(window.get(delCh).equals(need.get(delCh))) valid--;\n                    window.put(delCh, window.get(delCh) - 1);\n                }\n            }\n        }\n\n        return len == Integer.MAX_VALUE ? \"\" : s.substring(start, start + len);\n    }\n}\n```\n\n\n\n### [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)\n\n```\n给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。\n换句话说，s1 的排列之一是 s2 的 子串 。\n\n输入：s1 = \"ab\" s2 = \"eidbaooo\"\n输出：true\n解释：s2 包含 s1 的排列之一 (\"ba\").\n```\n\n这种题目，是明显的滑动窗口算法，**相当给你一个 `S` 和一个 `T`，请问你 `S` 中是否存在一个子串，包含 `T` 中所有字符且不包含其他字符**？\n\n```java\nclass Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        Map<Character, Integer> need = new HashMap<>();\n        Map<Character, Integer> window = new HashMap<>();\n        for(char s : s1.toCharArray()) {\n             need.put(s, need.getOrDefault(s, 0) + 1);\n        }\n\n        int left = 0, right = 0;\n        int valid = 0;\n        while(right < s2.length()) {\n            char ch = s2.charAt(right);\n            right++;\n            if(need.containsKey(ch)) {\n                window.put(ch, window.getOrDefault(ch, 0) + 1);\n                if(window.get(ch).equals(need.get(ch))) valid++;\n            }\n\n            // System.out.println(\"window: \" + left + \" \" + right);\n\n            // 判断左侧窗口是否要收缩, 相当于维护一个定长窗口\n            while(right - left >= s1.length()) {\n                // 判断是否找到合法子串\n                if(valid == need.size()) return true;\n                char d = s2.charAt(left);\n                left++;\n                if(need.containsKey(d)) {\n                    if(need.get(d).equals(window.get(d))) valid--;\n                    window.put(d, window.get(d) - 1);\n                }\n            }\n        }\n\n        return false;\n    }\n}\n```\n\n对于这道题的解法代码，基本上和76.最小覆盖子串一模一样，只需要改变几个地方：\n\n1、本题移动 `left` 缩小窗口的时机是窗口大小大于 `t.size()` 时，因为排列嘛，显然长度应该是一样的。\n\n2、当发现 `valid == need.size()` 时，就说明窗口中就是一个合法的排列，所以立即返回 `true`。\n\n至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。\n\n>   PS：由于这道题中 `[left, right)` 其实维护的是一个**定长**的窗口，窗口大小为 `t.size()`。因为定长窗口每次向前滑动时只会移出一个字符，所以可以把内层的 while 改成 if，效果是一样的。\n\n\n\n\n\n### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)\n\n```\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n输入: s = \"cbaebabacd\", p = \"abc\"\n输出: [0,6]\n解释:\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n```\n\n同567， 本题是找全部，567是 找一个\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> res = new ArrayList<>();\n        Map<Character, Integer> need = new HashMap<>();\n        Map<Character, Integer> window = new HashMap<>();\n        for(char ch : p.toCharArray()) {\n             need.put(ch, need.getOrDefault(ch, 0) + 1);\n        }\n\n        int left = 0, right = 0;\n        int valid = 0;\n        while(right < s.length()) {\n            char ch = s.charAt(right);\n            right++;\n            if(need.containsKey(ch)) {\n                window.put(ch, window.getOrDefault(ch, 0) + 1);\n                if(window.get(ch).equals(need.get(ch))) valid++;\n            }\n\n            if(right - left >= p.length()) { // while和if都行\n                if(valid == need.size()) {\n                    res.add(left);\n                }\n\n                char d = s.charAt(left);\n                left++;\n                if(need.containsKey(d)) {\n                    if(window.get(d).equals(need.get(d))) valid--;\n                    window.put(d, window.get(d) - 1);\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)\n\n```\n求最长连续数组长度，数组中只能有两类元素\n\n输入：fruits = [1,2,1]\n最长：1 2 1\n输出：3\n\n输入：fruits = [0,1,2,2]\n最长：1 2 2\n输出：3\n```\n\n求最大窗口\n\n```java\nclass Solution {\n    public int totalFruit(int[] fruits) {\n        int res = 0;\n        Map<Integer, Integer> window = new HashMap<>();\n        int l = 0;\n        int r = 0;\n        int kind = 0;\n\t\t\t\t\n      \t// [)区间\n        while(r < fruits.length) {\t// 移动右边界\n            int num = fruits[r];\t// 即将移入窗口的元素\n            r++;\n            window.put(num, window.getOrDefault(num, 0) + 1);\n            if(window.getOrDefault(num, 0) <= 1) kind++;\n\n            \n            while(kind > 2) {\t\t// 不满足条件，移动左边界\n                int del = fruits[l];\t// 即将移出的元素\n                l++;\n                window.put(del, window.get(del) - 1);\n                if(window.get(del) <= 0) kind--;\n\n            }\n\n          \t// 一旦满足条件，更新结果\n            res = Math.max(r - l, res);\n\n        }\n\n        return res;\n    }\n}\n```\n\n### [lc.1004 最大连续1的个数 III](https://leetcode.cn/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/[https://leetcode-cn.com/problems/max-consecutive-ones-iii/)\n\n最大窗口\n\n```\n\n```","timestamp":1692285118436},{"name":"02-239. 滑动窗口最大值.md","path":"002-数据结构与算法/001-数组/01-滑动窗口/02-239. 滑动窗口最大值.md","content":"### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)\n\n#### 方法一：单调队列\n\n思路：\n\n采用一个单调递减的队列存元素下标，队首始终为窗口最大值下标，\n\n队列为空时，直接加入\n\n始终保持队列单调递减，在加入元素x时，要将队列中>=x的元素下标移除\n\n当队首元素指向的下标不在窗口范围内则移除\n\n\n\n##### Java\n\n错解：\n\n存在的问题：当队首元素已经不再窗口内时，不能将其移出，如 [1,3,1,2,0,5]，窗口为[1,2,0]时，队列为[3,2]并不能把3移除\n\n```java\nclass Solution {\n    Deque<Integer> deque = new LinkedList<>();\n\n    public void myPush(Integer n, int k) {\n        if(deque.size() == k) { // [1,3,1,2,0,5]，到0时，队列为[3,2]并不能把3移除\n            deque.removeLast();\n        }\n        while(!deque.isEmpty() && n >= deque.getFirst()) {\n            deque.removeFirst();\n        }\n        deque.push(n);\n    }\n\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int[] res = new int[nums.length - k + 1];\n        int index = 0;\n\n        // 第一个窗口\n        for(int i=0; i<k; i++) {\n            myPush(nums[i], k);\n        }\n        res[index++] = deque.getLast();\n\n        for(int i=k; i<nums.length; i++) {\n            myPush(nums[i], k);\n            res[index++] = deque.getLast();\n        }\n        \n        return res;\n    }\n}\n```\n\n解决办法：队列中存储数组下标，不存实际值\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        List<Integer> list = new ArrayList<>();\n        Deque<Integer> q = new LinkedList<>(); // 存可能是最大值的下标\n\n        // 初始化第一个窗口\n        for(int i = 0; i < k; i++) {\n            while(!q.isEmpty() && nums[i] >= nums[q.peekLast()]) {\n                q.pollLast();\n            }\n            q.offerLast(i);\n        }\n        list.add(nums[q.peek()]);\n\n      \t// 定长窗口不断右移\n        for(int i = k; i < n; i++) {\n            while(!q.isEmpty() && nums[i] >= nums[q.peekLast()]) {\n                q.pollLast();\n            }\n            q.offerLast(i);\n\n            // 判断最大值是否在窗口外\n            if(i - q.peekFirst() + 1 > k) {\n                q.removeFirst();\n            }\n\n            list.add(nums[q.peek()]);\n        }\n\n        int[] res = new int[list.size()];\n        for(int i = 0; i < list.size(); i++) res[i] = list.get(i);\n        return res;\n    }\n}\n```\n\n优化：直接用数组存结果，不需要中间变量List\n\n```java\nclass Solution {\n\tpublic int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> deque = new LinkedList<>(); // 存可能是最大值的下标\n        int[] res = new int[nums.length - k + 1];\n\n        // 第一个窗口\n        for(int i = 0; i < k; i++) {\n            while(!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n        }\n        res[0] = nums[deque.peekFirst()];\n\n        for(int i = k; i < nums.length; i++) {\n            while(!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n\n            while(deque.peekFirst() <= i-k) {\n                deque.pollFirst();\n            }\n            res[i-k+1] = nums[deque.peekFirst()];  // 优化\n        }\n        \n        return res;\n    }\n}\n\n```\n\n#### 方法二：优先级队列\n\n思路跟单调队列一样，单调队列 是 优先级队列的优化\n\n[参考](https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/)\n\n","timestamp":1692285118436},{"name":"01-前缀和.md","path":"002-数据结构与算法/001-数组/02-前缀和/01-前缀和.md","content":"作用\n\n```\n快速计算区间和\n```\n\n代码\n\n```java\n// 计算前缀和数组, 注意下标便宜， [0, 2]的前缀和为preSum[3]，preSum[i]是[0, i-1]的和\nint[] preSum = new int[n + 1];\nfor(int i = 0; i < n; i++) {\n  \tpreSum[i + 1] = preSum[i] + nums[i];\n}\n```\n\n","timestamp":1692285118436},{"name":"02-560. 和为 K 的子数组.md","path":"002-数据结构与算法/001-数组/02-前缀和/02-560. 和为 K 的子数组.md","content":"### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)\n\n```\n给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。\n```\n\n#### 错解：滑动窗口\n\n```\n思路：窗口sum < k时不断扩大右边界，> k时缩小左边界\n\n问题：数组为负数时不适用\n[-1,-1,1]\n0\n```\n\n```java\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        // if(k == 0) return 0;\n        int n = nums.length;\n        int res = 0;\n        // Arrays.sort(nums);\n        int l = 0, r = 0;\n        int sum = 0;\n        while(r < n) {\n            sum += nums[r];\n            r++;\n\n            System.out.println(sum);\n            while(sum > k) {\n                sum -= nums[l];\n                l++;\n            }\n\n            if(sum == k) {\n                // System.out.println(sum + \"  \" + nums[r]);\n                res++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法一：枚举\n\n就是暴力破解\n\n```java\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        int res = 0;\n        for(int i = 0; i < nums.length; i++) {\n            // 求nums[0 : i]的前缀和\n            int sum = 0;\n            for(int end = i; end >= 0; end--) {\n                sum += nums[end];\n                if(sum == k) res++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n#### 方法二：前缀和\n\n暴力的优化，利用前缀和数组快速计算区间和\n\n```java\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        int res = 0;\n        int n = nums.length;\n      \t// 计算前缀和数组\n        int[] preSum = new int[n + 1];\n        for(int i = 0; i < n; i++) {\n            preSum[i + 1] = preSum[i] + nums[i];\n        }\n\n        for(int l = 0; l < n; l++) {\n            for(int r = l; r < n; r++) {\n              \t// 区间和，[l, r], 前缀和注意下表偏移\n                int sum = preSum[r + 1] - preSum[l];\n                if(sum == k) res++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/subarray-sum-equals-k/solution/bao-li-jie-fa-qian-zhui-he-qian-zhui-he-you-hua-ja/)\n\n#### 方法三： 前缀和 + 哈希表\n\n```\n区间和[0, j] = preSum[j + 1] - preSum[0]\n区间和[i, j] = preSum[j + 1] - preSum[i]\n要求的就是 区间和[i, j] == k，即preSum[j + 1] - preSum[i] = k的情况， 也可以变化为判断preSum[j + 1] - k = preSum[i]\n\n现在用一个变量preSum代替前缀和数组，preSum代表的是区间和[0, j]\n现在要求[0, j]内有没有区间和为k的情况，可以变化为判断是否存在preSum - k\n```\n\n```java\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, 1);\n        int preSum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            preSum += nums[i];\n            if(map.containsKey(preSum - k)) {\n                res += map.get(preSum - k);\n            }\n\n            map.put(preSum, map.getOrDefault(preSum, 0) + 1);\n        }\n\n        return res;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/subarray-sum-equals-k/solution/bao-li-jie-fa-qian-zhui-he-qian-zhui-he-you-hua-ja/)","timestamp":1692285118436},{"name":"01-二分查找理论.md","path":"002-数据结构与算法/001-数组/03-二分查找/01-二分查找理论.md","content":"### 知识点\n\n易错点\n\n- 如何确定while (left <= right) 还是 while (left < right)\n- 当 nums[middle] > target 时，right = middle - 1 还是 middle\n- int mid = low + ((high - low) >> 1)可以防止（low + high）/ 2 越界\n  - \\>>优先级低于+\n\n二分法种类\n\n- [left, right]\n- [left, right）\n\n[left, right]写法\n\n```java\npublic int search(int[] nums, int target) {\n  int low = 0, high = nums.length - 1;\t// 包含右边nums[nums.length - 1]\n  while(low <= high) {  // [1, 1]是合法的\n    int mid = low + ((high - low) >> 1);\t// 可以防止low+high越界; >>比-低\n    if(nums[mid] == target){\n      return mid;\n    } else if(nums[mid] > target){\n      high = mid - 1;\t\t// nums[middle]一定不是target，下一个查询区间不会去比较nums[middle],所以mid - 1\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n}\n```\n\n[left, right)写法\n\n```java\npublic int search(int[] nums, int target) {\n  int low = 0, high = nums.length; // 区别1: 不包含右边nums[nums.length]\n  while(low < high) {  // 区别2： [1, 1)非法,left == right在区间[left, right)无意义\n    int mid = low + ((high - low) >> 1);\t// 可以防止加号越界\n    if(nums[mid] == target){\n      return mid;\n    } else if(nums[mid] > target){\n      high = mid;\t\t// 区别3: 下一个查询区间不会去比较nums[middle]\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n}\n```\n\n### 题目\n\n","timestamp":1692285118436},{"name":"02-33. 搜索旋转排序数组.md","path":"002-数据结构与算法/001-数组/03-二分查找/02-33. 搜索旋转排序数组.md","content":"### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)\n\n```\n旋转有序数组，找目标值\n\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n```\n\n![fig1](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/30/15433816828406181682840618131DXVmpE-33_fig1.png)\n\n数组部分有序，思想就是尽可能的让搜索的范围变成有序的部分.\n\n每次取mid时，一定是有一部分有序，如何判断？\n\n```\n如果nums[0] <= nums[mid]。说明[l : mid]有序，另外半边无法确定。\n```\n\n\n\n#### 方式1\n\n以方式1为主，与[81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)统一写法\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int l = 0;\n        int r = n - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            System.out.println(\"mid: \" + nums[mid]);\n            if(nums[mid] == target) return mid;\n            if(nums[l] <= nums[mid]) {   // 左半边有序，右半边不一定有序\n                if(nums[l] <= target && target < nums[mid]) { // 判断target在[l, mid]中, 需要<=\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if(nums[mid] < target && target <= nums[r]) {\t// 需要<=\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n```\n\n\n\n#### 方式2\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int l = 0;\n        int r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            System.out.println(\"mid: \" + nums[mid]);\n            if(nums[mid] == target) return mid;\n            if(nums[0] <= nums[mid]) {   // 左半边有序，右半边不一定有序。 解释2\n                if(nums[0] <= target && target < nums[mid]) {\t// 解释1\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if(target > nums[mid] && target < nums[n - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n```\n\n解释1： 为什么要加`nums[0] <= target`?\n\n```\n仅由target < nums[mid]并不能确定target在左半边，如上左图，2小于mid = 7，但是在右半边\n```\n\n解释2: 为什么是 `nums[0] <= nums[mid]` 而不是 `nums[l] <= nums[mid]` ?\n\n```\n两种方法都能实现，nums[l]的写法即方式1\nnums[l] <= nums[mid]的另一种实现方式参考如下\nhttps://leetcode.cn/problems/search-in-rotated-sorted-array/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/\n\n此处nums[0] <= nums[mid]就能判断出哪半边有序了\n如上左图，target=2\n第一轮结束后 l = 4, r = 6\n下一轮： mid = 5， 此时nums[0] > nums[mid]， 说明是右半边有序\n\n\n```\n\n","timestamp":1692285118436},{"name":"03-找出第一个大于目标元素的索引.md","path":"002-数据结构与算法/001-数组/03-二分查找/03-找出第一个大于目标元素的索引.md","content":"### [找出第一个大于目标元素的索引](https://leetcode.cn/problems/search-insert-position/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-69ao/)\n\n```\n有序数中找\nnums = {1,3,5,5,6,6,8,9,11} target = 7\n```\n\n![二分查找模糊边界目标值](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/30/1721011682846461168284646153432irJ3-1608987488-NLxOHm-file_1608987488140.png)\n\n```java\npublic static int lowBoundnum(int[] nums,int target,int left, int right) {\n\n        while (left <= right) {\n            //求中间值\n            int mid = left + ((right - left) >> 1);\n            //大于目标值的情况\n            if (nums[mid] > target) {\n                 //返回 mid\n                if (mid == 0 || nums[mid-1] <= target) {\n                    return mid;\n                }\n                else{\n                    right = mid -1;\n                }\n\n            } else if (nums[mid] <= target){\n                left = mid + 1;\n            }\n        }\n        //所有元素都小于目标元素\n        return -1;\n    }\n\n作者：yuan-chu-de-suan-fa-xiao-wu\n链接：https://leetcode.cn/problems/search-insert-position/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-69ao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","timestamp":1692285118436},{"name":"04-找出最后一个小于目标元素的索引.md","path":"002-数据结构与算法/001-数组/03-二分查找/04-找出最后一个小于目标元素的索引.md","content":"### **找出最后一个小于目标元素的索引**\n\n```java\npublic static int upperBoundnum(int[] nums,int target,int left, int right) {\n\n        while (left <= right) {\n\n            int mid = left + ((right - left) >> 1);\n             //小于目标值\n            if (nums[mid] < target) {\n                //看看是不是当前区间的最后一位，如果当前小于，后面一位大于，返回当前值即可\n                if (mid == right || nums[mid+1] >= target) {\n                    return mid;\n                } else {\n                    left = mid + 1;\n                }\n\n            } else if (nums[mid] >= target) {\n                right = mid - 1;\n            }\n        }\n        //没有查询到的情况\n        return -1;\n    }\n\n作者：yuan-chu-de-suan-fa-xiao-wu\n链接：https://leetcode.cn/problems/search-insert-position/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-69ao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","timestamp":1692285118436},{"name":"05-34. 在排序数组中查找元素的第一个和最后一个位置.md","path":"002-数据结构与算法/001-数组/03-二分查找/05-34. 在排序数组中查找元素的第一个和最后一个位置.md","content":"\n\n### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n#### 二分\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int low = getLeftBound(nums, target);\n        int upper = getRightBound(nums, target);\n        if(upper < low) return new int[]{-1, -1};\n\n        return new int[]{low, upper};\n    }\n\n    // 计算下边界 \n    public int getLeftBound(int[] nums, int target) {\n        int l = 0; \n        int r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] >= target) {\n                r = mid - 1;\n            } else if(nums[mid] < target){\n                l = mid + 1;\n            }\n        }\n\n        return l;   // 考虑为什么返回l而不是r？\n    }\n\n    // 计算上编辑\n    public int getRightBound(int[] nums, int target) {\n        int l = 0; \n        int r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] > target) {\n                r = mid - 1;\n            } else if(nums[mid] <= target){\n                l = mid + 1;\n            }\n        }\n\n      \t// return nums[r] == target ? r : -1; 错误写法，r可能已经越界 如[1] 0\n        return r;   \n    }\n}\n```\n\n#### 双指针\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        if(nums.length == 0) return new int[]{-1, -1};\n\n        int l = 0; \n        int r = nums.length - 1;\n        while(l < r && nums[l] != target) l++;\n        while(l < r && nums[r] != target) r--;\n        if(l == r && nums[l] != target) return new int[]{-1, -1};\n\n        return new int[]{l, r};\n    }\n}\n```\n\n#### 二分+双指针\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int l = 0; \n        int r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] == target) {\n                int left = mid;\n                int right = mid;\n                while(left >= 0 && nums[left] == target) left--;\n                while(right < nums.length && nums[right] == target) right++;\n                return new int[]{left + 1, right - 1};\n            } else if(nums[mid] > target) {\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return new int[]{-1, -1};\n    }\n}\n```\n\n\n\n\n\n相同题：[剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)\n\n```\n统计一个数字在排序数组中出现的次数。\n\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n```\n\n","timestamp":1692285118436},{"name":"06-35. 搜索插入位置.md","path":"002-数据结构与算法/001-数组/03-二分查找/06-35. 搜索插入位置.md","content":"\n\n#### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)\n\n[]写法\n\n```java\npublic int searchInsert(int[] nums, int target) {\n  int low = 0; \n  int high = nums.length - 1; // 定义target在左闭右闭的区间里，[left, right]\n  while(low <= high) { // 当left==right，区间[left, right]依然有效\n    int mid = low + ((high - low) >> 1);\n    if(nums[mid] > target) {\n      high = mid - 1; // target 在左区间，所以[left, middle - 1]\n    } else if(nums[mid] < target) {\n      low = mid + 1; // target 在右区间，所以[middle + 1, right]\n    } else { // nums[middle] == target\n      return mid;\n    }\n  }\n  // 分别处理如下四种情况\n  // 目标值在数组所有元素之前  [0, -1]\n  // 目标值等于数组中某一个元素  return middle;\n  // 目标值插入数组中的位置 [left, right]，return  right + 1\n  // 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1\n  return high + 1;\t\t// return left也行\n}\n```\n\n[)写法\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0; \n        int r = nums.length;\n        while(l < r) {\n            int mid = l + ((r - l) >> 1);\n            // System.out.println(\"mid: \" + nums[mid]);\n            if(nums[mid] == target) {\n                return mid;\n            } else if(nums[mid] < target) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n\n        return r;\t\t// 方式二：return l也行\n    }\n}\n```\n\n```c++\n[1,3,5,6], target = 2\n  \nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n = nums.size();\n        int left = 0;\n        int right = n; // 定义target在左闭右开的区间里，[left, right)  target\n        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间\n            int middle = left + ((right - left) >> 1);\n            if (nums[middle] > target) {\n                right = middle; // target 在左区间，在[left, middle)中\n            } else if (nums[middle] < target) {\n                left = middle + 1; // target 在右区间，在 [middle+1, right)中\n            } else { // nums[middle] == target\n                return middle; // 数组中找到目标值的情况，直接返回下标\n            }\n        }\n        // 分别处理如下四种情况\n        // 目标值在数组所有元素之前 [0,0)\n        // 目标值等于数组中某一个元素 return middle\n        // 目标值插入数组中的位置 [left, right) ，return right 即可\n        // 目标值在数组所有元素之后的情况 [left, right)，因为是右开区间，所以 return right\n        return right;\t\t\n    }\n};\n\n[1,3,5,6], target = 2\nmid: 5 => mid: 3 => mid: 1\n  \n[1,3,5,6], target = 7\nmid: 5 => mid: 6\n\n[1,3,5,6], target = 0\nmid: 5 => mid: 3 => mid: 1\n```\n\n","timestamp":1692285118436},{"name":"07-81. 搜索旋转排序数组 II.md","path":"002-数据结构与算法/001-数组/03-二分查找/07-81. 搜索旋转排序数组 II.md","content":"### [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)\n\n与[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)的区别：有重复元素\n\n```\n[1,0,1,1,1]\n0\n```\n\n写法1（为主）\n\n```java\nclass Solution {\n    public boolean search(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] == target) return true;\n            if(nums[l] == nums[mid]) {\t\t// 与T33的区别\n                l++;\n                continue;\n            }\n            if(nums[l] < nums[mid]) {\n                if(nums[l] <= target && target < nums[mid]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if(nums[mid] < target && target <= nums[r]) {   // (], mid已经判断过不是target\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\nhttps://leetcode.cn/problems/search-in-rotated-sorted-array-ii/solution/zai-javazhong-ji-bai-liao-100de-yong-hu-by-reedfan/\n```\n\n写法二\n\n```java\nclass Solution {\n    public boolean search(int[] nums, int target) {\n        int n = nums.length;\n        int l = 0;\n        int r = n - 1;\n        while(l <= r) {\n            int mid = l + ((r - l) >> 1);\n            System.out.println(\"mid: \" + nums[mid]);\n            if(nums[mid] == target) return true;\n            if(nums[l] == nums[mid] && nums[mid] == nums[r]) {\n                l++;\n                r--;\n            } else if(nums[l] <= nums[mid]) {   // 左半边有序，右半边不一定有序\n                if(nums[l] <= target && target < nums[mid]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if(target > nums[mid] && target <= nums[n - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n```\n\n参考：官方题解\n","timestamp":1692285118436},{"name":"08-153. 寻找旋转排序数组中的最小值.md","path":"002-数据结构与算法/001-数组/03-二分查找/08-153. 寻找旋转排序数组中的最小值.md","content":"### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)\n\n```\n有序数组多次旋转，找最小值\n\n输入：nums = [3,4,5,1,2]\n输出：1\n解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n```\n\n\n\n```\n我们考虑数组中的最后一个元素x：\n- 在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 x；\n- 而在最小值左侧的元素，它们的值一定都严格大于 x。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。\n```\n\n\n\n第一种情况是pivot的值小于high值，这说明 `nums[pivot]`是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。（思考：能不能是因为pivot < low值？）\n\n![image-20230430202707458](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/30/20270716828576271682857627561i9OumE-image-20230430202707458.png)\n\n第二种情况是pivot的值大于high。这说明 `nums[pivot]`是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。\n\n![image-20230430202826683](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/04/30/20282616828577061682857706805qP4Oc2-image-20230430202826683.png)\n\n由于数组不包含重复元素，并且只要当前的区间长度不为 1，pivot就不会与high重合；\n\n而如果当前的区间长度为 1，这说明我们已经可以结束二分查找了。\n\n因此不会存在`nums[pivot]=nums[high]`的情况。\n\n当二分查找结束时，我们就得到了最小值所在的位置。\n\n```java\nclass Solution {\n    public int findMin(int[] nums) {\n        int l = 0;\n        int r = nums.length - 1;\n        while(l < r) {  // 不能是<=\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid]  < nums[r]) {\n                r = mid;  // 不能是mid-1，如nums[mid]就是最小值\n            } else {\n                l = mid + 1;    // nums[mid]一定不是最小值\n            }\n        }\n        return nums[l];\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-5irwp/)\n\n\n\n思考：情况1和情况2能不能考虑pivot和low值比较？\n\n```\n不能\n\n有序数组 [1 2 3 4 5]\n第一种情况成立，不会出现该情况\n第二种情况不成立，不能因为nums[pivot] > nums[l]就得出结论,最小值在右边\n\n```\n\n","timestamp":1692285118436},{"name":"09-154. 寻找旋转排序数组中的最小值 II.md","path":"002-数据结构与算法/001-数组/03-二分查找/09-154. 寻找旋转排序数组中的最小值 II.md","content":"### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n数组有重复值\n\n\n\n```\n考虑\n[1,3,3]\n[0,1,1,1,2,2]\n```\n\n\n\n#### 写法1（主要）\n\n```\nclass Solution {\n    public int findMin(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while(l < r) {\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] > nums[r]) {\n                l = mid + 1;\n            } else if(nums[mid] < nums[r]){\n                r = mid;\n            } else {\n                r--;\n            }\n        }\n\n        return nums[l];\n    }\n}\n```\n\n\n\n#### 写法2\n\n```java\nclass Solution {\n    public int findMin(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while(l < r) {\n            while(l < r && r > 0 && nums[r] == nums[r - 1]) r--;\n            int mid = l + ((r - l) >> 1);\n            if(nums[mid] >= nums[r]) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n\n        return nums[l];\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"10-704. 二分查找.md","path":"002-数据结构与算法/001-数组/03-二分查找/10-704. 二分查找.md","content":"### #### [704. 二分查找](https://leetcode.cn/problems/binary-search/)\n\n#### 递归\n\n```java\npublic static int binarySearch(int[] nums,int target,int left, int right) {\n        \n        if (left <= right) {\n            int mid = left + ((right - left) >> 1);\n            if (nums[mid] == target) {\n                //查找成功\n                return  mid;\n            }else if (nums[mid] > target) {\n                //新的区间,左半区间\n                return binarySearch(nums,target,left,mid-1);\n            }else if (nums[mid] < target) {\n                //新的区间，右半区间\n                return binarySearch(nums,target,mid+1,right);\n            }\n        }\n        //不存在返回-1\n        return -1;\n    }\n\n链接：https://leetcode.cn/problems/search-insert-position/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-69ao/\n```\n\n#### 迭代\n\n```\n\n```\n\n","timestamp":1692285118436},{"name":"01-总结.md","path":"002-数据结构与算法/001-数组/04-二维数组遍历/01-总结.md","content":"https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/er-wei-shu-150fb/","timestamp":1692285118436},{"name":"02-48. 旋转图像.md","path":"002-数据结构与算法/001-数组/04-二维数组遍历/02-48. 旋转图像.md","content":"### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n\n        // 对角线翻转\n        for(int i = 0; i < rows; i++) {\n            for(int j = i + 1; j < cols; j++) {\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = tmp;\n            }\n        }\n\n        // 竖直翻转\n        for(int i = 0; i < rows; i++) {\n            int l = 0, r = cols - 1;\n            while(l < r) {\n                int tmp = matrix[i][l];\n                matrix[i][l] = matrix[i][r];\n                matrix[i][r] = tmp;\n                l++;\n                r--;\n            }\n        }\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"03-54. 螺旋矩阵.md","path":"002-数据结构与算法/001-数组/04-二维数组遍历/03-54. 螺旋矩阵.md","content":"### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)\n\n```\nclass Solution {\n    public int[] spiralOrder(int[][] matrix) {\n        if(matrix.length == 0 || matrix[0].length == 0) return new int[]{};\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n\n        int[] res = new int[rows * cols];\n        int index = 0;\n\n        int t = 0, b = rows - 1, l = 0, r = cols - 1;\n        while(t <= b && l <= r) {\n            if(t <= b) {    // 保证上下没有越界\n                for(int i = l; i <= r; i++) {   // 保证左右没有越界\n                    res[index++] = matrix[t][i];\n                }\n                t++;\n            }\n\n            if(l <= r) {\n                for(int i = t; i <= b; i++) {\n                    res[index++] = matrix[i][r];\n                }\n                r--;\n            }\n\n            if(t <= b) {\n                for(int i = r; i >= l; i--) {\n                    res[index++] = matrix[b][i];\n                }\n                b--;\n            }\n\n            if(l <= r) {\n                for(int i = b; i >= t; i--) {\n                    res[index++] = matrix[i][l];\n                }\n                l++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"04-59. 螺旋矩阵 II.md","path":"002-数据结构与算法/001-数组/04-二维数组遍历/04-59. 螺旋矩阵 II.md","content":"### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)\n\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] res = new int[n][n];\n\n        int t = 0, b = n - 1;\n        int l = 0, r = n - 1;\n        int num = 1;\n        while(num <= n * n) {\n            if(t <= b) {\n                for(int i = l; i <= r; i++) {\n                    res[t][i] = num++;\n                }\n                t++;\n            }\n\n            if(l <= r) {\n                for(int i = t; i <= b; i++) {\n                    res[i][r] = num++;\n                }\n                r--;\n            }\n\n            if(t <= b) {\n                for(int i  = r; i >= l; i--) {\n                    res[b][i] = num++;\n                }\n                b--;\n            }\n\n            if(l <= r) {\n                for(int i = b; i >= t; i--) {\n                    res[i][l] = num++;\n                }\n                l++;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"01-121. 买卖股票的最佳时机.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/01-121. 买卖股票的最佳时机.md","content":"### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)\n\n注意：只能买一次，所以不能用[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)拆分利润的方法\n\n#### 方法一：贪心\n\n找低谷与顶峰\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n        int res = 0;\n\n        int min = prices[0];\n        for(int i = 1; i < prices.length; i++) {\n            min = Math.min(min, prices[i]);\n            int diff = prices[i] - min;\n            res = Math.max(res, diff);\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法二：动态规划\n\ndp含义\n\n```\ndp[i] 前i项利润最大值\n```\n\n递推公式\n\n```\ndp[i] = Math.max(prices[i] - min, dp[i - 1]);\n```\n\n源码\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n\n        int[] dp = new int[prices.length];\n        int min = prices[0];\n        dp[0] = 0;\n        for(int i = 1; i < prices.length; i++) {\n            dp[i] = Math.max(prices[i] - min, dp[i - 1]);\n            min = Math.min(min, prices[i]);\n        }\n\n        return dp[prices.length - 1];\n    }\n}\n```\n\n优化：滚动数组\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n\n        int res = 0;\n        int pre = 0;\n        int min = prices[0];\n        for(int i = 1; i < prices.length; i++) {\n            res = Math.max(prices[i] - min, pre);\n            min = Math.min(min, prices[i]);\n            pre = res;\n        }\n\n        return res;\n    }\n}\n```\n\n### 方法三：动态规划2\n\n方式1（为主）\n\n[参考](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/yi-ge-fang-3b01b/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        // dp[i][0]: 第i天不持有股票所得最多现金\n        // dp[i][1]: 第i天持有股票所得最多现金\n        int[][] dp = new int[n][2];  \n        dp[0][0] = 0;   \n        dp[0][1] = -prices[0];\n        for(int i = 1; i < n; i++) {\n            // 今天不持有： 1 昨天不持有 2 昨天持有，今天卖\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            // 今天持有： 1 昨天持有 2 昨天不持有，今天买\n            dp[i][1] = Math.max(dp[i - 1][1], - prices[i]);    // 解释1\n        }\n\n        return dp[n - 1][0];\n    }\n}\n```\n\n解释1:`为什么不是Math.max(dp[i - 1][1],  dp[i - 1][0] - prices[i]);`\n\n```\n因为只买卖一次，昨天不持有说明昨天及之前都没有发生过交易，持有的现金肯定是0\n而dp[i - 1][0]可能包含了两种情况，1 一直没持有； 2 持有过但卖了。\n而现在已经确定了今天要买，并且题目要求只能交易一次，所以只能取dp[i - 1][0]的第一种情况，也就是0\n```\n\n\n\n\n\n方式2\n\n<img src=\"/Users/kuan/Library/Application%20Support/typora-user-images/image-20221222123200226.png\" alt=\"image-20221222123200226\" style=\"zoom: 33%;\" />\n\n```\ndp[i][0] 就是用来记录最低谷的\ndp[i][1] 记录当前最大利润\n```\n\n\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0) return 0;\n\n        int[][] dp = new int[prices.length][2];\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i = 1; i < prices.length; i++) {\n            dp[i][0] = Math.max(-prices[i], dp[i - 1][0]);\n            dp[i][1] = Math.max(prices[i] + dp[i-1][0], dp[i - 1][1]);\n        }\n\n        return dp[prices.length - 1][1];\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"02-122. 买卖股票的最佳时机 II.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/02-122. 买卖股票的最佳时机 II.md","content":"### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)\n\n#### 方法一：贪心\n\n\n\n#### 方法二：dp\n\n##### 方式1（为主）\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        if(n == 0) return 0;\n\n        int[][] dp = new int[n][2];\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        for(int i = 1; i < n; i++) {\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); // 与121.对比\n        }\n        return dp[n - 1][0];\n    }\n}\n```\n\n优化: 滚动数组\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        if(n == 0) return 0;\n\n        int pre0 = 0;\n        int pre1 = -prices[0];\n        for(int i = 1; i < n; i++) {\n            pre0 = Math.max(pre0, pre1 + prices[i]);\n            pre1 = Math.max(pre1, pre0 - prices[i]);\n        }\n        return pre0;\n    }\n}\n```\n\n[参考](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/yi-ge-fang-3b01b/)\n\n##### 方式2\n\n与方式1的区别在于`dp[i][0]和dp[i`][1]相反\n\n[参考](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int[][] dp = new int[prices.length][2];\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i = 1; i < prices.length; i++) {\n            dp[i][0] = Math.max(dp[i-1][1] - prices[i], dp[i-1][0]);\n            dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]);\n        }\n\n        return dp[prices.length- 1][1];\n    }\n}\n```\n\n\n\n```\n7 1 2 5 3 6 4\n\n-7  0\n-1  0\n-1  1\n-4  4\n 1  4\n-2  7\n```\n\n","timestamp":1692285118436},{"name":"03-123. 买卖股票的最佳时机 III.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/03-123. 买卖股票的最佳时机 III.md","content":"### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)\n\n\n\n#### 方法一：三维dp\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int k = 2;\n        if(n == 0) return 0;\n        int[][][]dp = new int[n][k + 1][2];\n        dp[0][1][0] = 0;\n        dp[0][1][1] = -prices[0];\n        dp[0][2][0] = 0;\n        dp[0][2][1] = -prices[0];\n        for(int i = 1; i < n; i++) {\n            for(int j = 1; j <= 2; j++) {\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n\n        return dp[n - 1][k][0];\n    }\n}\n```\n\n优化初始化过程\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int k = 2;\n        if(n == 0) return 0;\n        int[][][]dp = new int[n][k + 1][2];\n        for(int i = 0; i < n; i++) {\n            for(int j = 1; j <= 2; j++) {\n                if(i == 0) {\n                    dp[i][j][0] = 0;\n                    dp[i][j][1] = -prices[i];\n                    continue;\n                }\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n\n        return dp[n - 1][k][0];\n    }\n}\n```\n\nk倒着写才符合语义\n\n第0天还没开始卖，所以最大交易次数应该为k_max\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int k = 2;\n        if(n == 0) return 0;\n        int[][][]dp = new int[n][k + 1][2];\n        for(int i = 0; i < n; i++) {\n            for(int j = k; j >= 1; j--) {\n                if(i == 0) {\n                    dp[i][j][0] = 0;\n                    dp[i][j][1] = -prices[i];\n                    continue;\n                }\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n\n        return dp[n - 1][k][0];\n    }\n}\n```\n\n优化：k次数较小，可以直接列举，滚动数组\n\n```java\n// 状态转移方程：\n// dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\n// dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\n// dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\n// dp[i][1][1] = max(dp[i-1][1][1], -prices[i])\n\n// 空间复杂度优化版本\nint maxProfit_k_2(int[] prices) {\n    // base case\n    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;\n    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;\n    for (int price : prices) {\n        dp_i20 = Math.max(dp_i20, dp_i21 + price);\n        dp_i21 = Math.max(dp_i21, dp_i10 - price);\n        dp_i10 = Math.max(dp_i10, dp_i11 + price);\n        dp_i11 = Math.max(dp_i11, -price);\n    }\n    return dp_i20;\n}\n\n```\n\n\n\n空间优化2: 本质上还是因为k的次数较小，可以直接列举，缩小一个纬度\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int[][] dp = new int[prices.length][5];\n        dp[0][1] = -prices[0];\n        dp[0][3] = -prices[0];\n\n        for(int i = 1; i < prices.length; i++) {\n            dp[i][0] = dp[i-1][0];\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n        }\n\n        return dp[prices.length - 1][4];\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"04-188. 买卖股票的最佳时机 IV.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/04-188. 买卖股票的最佳时机 IV.md","content":"### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)\n\n```\nclass Solution {\n    public int maxProfit(int k, int[] prices) {\n        int[][] dp = new int[prices.length][2 * k + 1];\n        for(int i = 1; i < k*2; i += 2) {\n            dp[0][i] = -prices[0];\n        }\n\n        for(int i = 1; i < prices.length; i++) {\n            for(int j = 0; j < k*2 - 1; j += 2) {\n                dp[i][j + 1] = Math.max(dp[i-1][j + 1], dp[i-1][j] - prices[i]);\n                dp[i][j + 2] = Math.max(dp[i-1][j + 2], dp[i-1][j + 1] + prices[i]);\n            }\n        }\n\n        return dp[prices.length - 1][k*2];\n    }\n}\n```\n\n三维数组\n\n```\n\n```\n\n","timestamp":1692285118436},{"name":"05-309. 最佳买卖股票时机含冷冻期.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/05-309. 最佳买卖股票时机含冷冻期.md","content":"\n\n\n\n\n\n### [309最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int[][] dp = new int[n][2];\n\n        for(int i = 0; i < n; i++) {\n            if(i - 1 == -1) {\n                dp[i][0] = 0;\n                dp[i][1] = -prices[0];\n                continue;\n            }\n            if(i - 2  == -1) {\n                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n                dp[i][1] = Math.max(dp[i-1][1], - prices[i]);\n                continue;\n            }\n\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n            // 当天持有：1 前一天持有  2 前一天没有&没有卖 今天买\n            dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);  // 解释1\n        }\n\n        return dp[n - 1][0];\n    }\n}\n```\n\n解释1：为什么是`dp[i-2][0] - prices[i]`\n\n```\n题目要求：1 卖出股票后，第二天不能买； 2 有切仅持有1支股票\n所以当前持有分为两种情况\n- 情况1：前一天持有\n- 情况2: 今天刚买。按要求1 那么就要求昨天不能卖； 按要求2 昨天不能持有\n\n为什么不能是dp[i - 1][0] - prices[i]呢？\ndp[i-1][0]有两个含义：1 前天买昨天卖； 2 前天没有，昨天也没有；\n现在已经明确今天要买，只能是“前天没有，昨天也没有”这种情况\n```\n\n","timestamp":1692285118436},{"name":"06-714. 买卖股票的最佳时机含手续费.md","path":"002-数据结构与算法/002-动态规划/01-买卖股票问题/06-714. 买卖股票的最佳时机含手续费.md","content":"### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices, int fee) {\n        int n = prices.length;\n        int[][] dp = new int[n][2];\n        for(int i = 0; i < n; i++) {\n            if(i - 1 < 0) {\n                dp[i][0] = 0;\n                dp[i][1] = -prices[0];\n                continue;\n            }\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);\t// 与模版的唯一区别\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n        }\n\n        return dp[n - 1][0];\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"01-718.最长重复子数组.md","path":"002-数据结构与算法/002-动态规划/02-子序列问题/01-718.最长重复子数组.md","content":"### [718.最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/)\n\n```\n给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。\n\n输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n输出：3\n解释：长度最长的公共子数组是 [3,2,1] 。\n```\n\n\n\ndp数组\n\n```\ndp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 \n（特别注意： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）\n\ndp[0][5]对应7，7在nums2中是nums[5-1] = nums[4]\n```\n\n定义`dp[i][j]`为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。不行么？\n\n行倒是行！ 但实现起来就麻烦一点，需要单独处理初始化部分\n\n![image-20221229171246639](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/11/22193516838147751683814775530sDft8r-17124616723051661672305166836EFLQqv-image-20221229171246639.png)\n\n```java\nclass Solution {\n    public int findLength(int[] nums1, int[] nums2) {\n        int res = 0;\n        int[][] dp = new int[nums1.length + 1][nums2.length + 1];\n        for(int i = 1; i <= nums1.length; i++) {\n            for(int j = 1; j <= nums2.length; j++) {\n                if(nums1[i - 1] == nums2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }\n                res = Math.max(res, dp[i][j]);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n滚动数组\n\n```java\nclass Solution {\n    public int findLength(int[] nums1, int[] nums2) {\n        int res = 0;\n        int[] dp = new int[nums2.length + 1];\n        for(int i = 1; i <= nums1.length; i++) {\n            for(int j = nums2.length; j > 0; j--) {\n                if(nums1[i - 1] == nums2[j - 1]) {\n                    dp[j] = dp[j - 1] + 1;\n                } else {\n                    dp[j] = 0;\t// 注意一定要置0\n                }\n                res = Math.max(res, dp[j]);\n\n            }\n            //  System.out.println(Arrays.toString(dp));\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"01-70. 爬楼梯.md","path":"002-数据结构与算法/002-动态规划/03-爬楼梯问题/01-70. 爬楼梯.md","content":"### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)\n\n可以跳一步、两步，所以分解为跳到n-1然后再跳一步 + 跳到n-2 再跳 2步\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        if(n <= 2) return n;\n        int[] dp = new int[n + 1];\n        // dp[0] = 0;\n        dp[1] = 1;\n        dp[2] = 2;\n        for(int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n\n        return dp[n];\n    }\n}\n```\n\n优化空间\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        if(n <= 2) return n;\n        int[] dp = new int[3];\n        dp[1] = 1;\n        dp[2] = 2;\n        for(int i = 3; i <= n; i++) {\n            int sum = dp[1] + dp[2];\n            dp[1] = dp[2];\n            dp[2] = sum;\n        }\n\n        return dp[2];\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"02-746. 使用最小花费爬楼梯.md","path":"002-数据结构与算法/002-动态规划/03-爬楼梯问题/02-746. 使用最小花费爬楼梯.md","content":"### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)\n\ndp[i] ：跳到第i个台阶的最小代价\n\n```java\ndp[i] = {\n\tdp[i] = Math.min(cost[i-2], dp[i-1] + cost[i-1])    \t\t\t\t\ti <= 3\n\tdp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1])\t\t其他\n}\n```\n\n\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        if(n <= 1) return Math.min(cost[0], cost[1]);\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = cost[0];\n        dp[2] =  Math.min(cost[0], cost[1]);\n        for(int i = 3; i <= n; i++) {\n            if(i - 2 <= 1) {\n                dp[i] = Math.min(cost[i-2], dp[i-1] + cost[i-1]);\n            } else {\n                dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]);\n            }\n            \n        }\n        \n        return dp[n];\n    }\n}\n```\n\n优化：\n\n初始化时搭配dp[0] 和 dp[1] 为0\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]);\n        }\n        \n        return dp[n];\n    }\n}\n```\n\n优化：空间复杂度\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int dp0 = 0;\n        int dp1 = 0;\n        for(int i = 2; i <= cost.length; i++) {\n            int dpi = Math.min(dp0 + cost[i-2], dp1 + cost[i-1]);\n            dp0 = dp1;\n            dp1 = dpi;\n        }\n        \n        return dp1;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"03-爬楼梯进阶.md","path":"002-数据结构与算法/002-动态规划/03-爬楼梯问题/03-爬楼梯进阶.md","content":"参考背包问题","timestamp":1692285118436},{"name":"01-模版.md","path":"002-数据结构与算法/003-栈与队列/01-单调栈/01-模版.md","content":"## 什么时候用单调栈呢？\n\n```\n通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了\n```\n\n\n\n## 模版\n\n### 模版1：正序遍历\n\n```java\nclass Solution {\n    public int[] dailyTemperatures(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        Deque<Integer> s = new LinkedList<>();\n        s.push(0);\t// 思考：存下标 还是 存元素\n        for(int i = 1; i < n; i++) {\n            while(!s.isEmpty() && nums[i] > nums[s.peek()]) {\n                res[s.peek()] = nums[s.peek()];\t// 思考：结果集要存的东西\n                s.pop();\n            }\n            s.push(i);\n        }\n\n        return res;\n    }\n}\n```\n\n### [模版2](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-daeca/dan-diao-z-1bebe/)：逆序遍历\n\n```java\nint[] nextGreaterElement(int[] nums) {\n    int n = nums.length;\n    // 存放答案的数组\n    int[] res = new int[n];\n    Stack<Integer> s = new Stack<>(); \n    // 倒着往栈里放\n    for (int i = n - 1; i >= 0; i--) {\n        // 判定个子高矮\n        while (!s.isEmpty() && s.peek() <= nums[i]) {\n            // 矮个起开，反正也被挡着了。。。\n            s.pop();\n        }\n        // nums[i] 身后的更大元素\n        res[i] = s.isEmpty() ? -1 : s.peek();\n        s.push(nums[i]);\n    }\n    return res;\n}\n\n```\n\n","timestamp":1692285118436},{"name":"02-496. 下一个更大元素 I.md","path":"002-数据结构与算法/003-栈与队列/01-单调栈/02-496. 下一个更大元素 I.md","content":"### [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)\n\n在nums2中找大于nums1各元素的第一个值\n\n```\n输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n```\n\n解题思路：\n\n```\nnums1是nums2的子集\n求nums2的个元素的下一个最大元素，用map记录\n再从map中取nums1的个元素的下一个最大元素\n```\n\n\n\n```java\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n\t\t\t\t// 求nums2的个元素的下一个最大元素\n        Map<Integer, Integer> map = new HashMap<>();\n        Deque<Integer> s = new LinkedList<>();\n        s.push(nums2[0]);\n        for(int i = 1; i < nums2.length; i++) {\n            while(!s.isEmpty() && nums2[i] > s.peek()) {\n                map.put(s.peek(), nums2[i]);\n                s.pop();\n            }\n            s.push(nums2[i]);\n        }\n\n      \t// 求nums1的个元素的下一个最大元素（nums1s是nums2的子集）\n      \tint[] res = new int[nums1.length];\n        for(int i = 0; i < nums1.length; i++) {\n            if(map.containsKey(nums1[i])) {\n                res[i] = map.get(nums1[i]);\n            } else {\n                res[i] = -1;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n[参考](https://programmercarl.com/0496.下一个更大元素I.html#其他语言版本)","timestamp":1692285118436},{"name":"03-503. 下一个更大元素 II.md","path":"002-数据结构与算法/003-栈与队列/01-单调栈/03-503. 下一个更大元素 II.md","content":"### [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)\n\n\n\n思路：将数据拼接 nums + nums，遍历两次nums\n\n优化：在遍历过程中模拟遍历两次nums\n\n```java\nclass Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        if(nums == null || nums.length <= 1) {\n            return new int[]{-1};\n        }\n\n        int len = nums.length;  \n        int[] res = new int[len];\n        Arrays.fill(res, -1);\n        Deque<Integer> s = new LinkedList<>();\n        for(int i = 0; i < len * 2; i++) {\n            while(!s.isEmpty() && nums[i % len] > nums[s.peek()]) {\n                res[s.peek() % len] = nums[i % len];\n                s.pop();\n            }\n            s.push(i % len);\n        }\n\n        return res;\n    }\n}\n```\n\n[参考](https://programmercarl.com/0503.下一个更大元素II.html#其他语言版本)","timestamp":1692285118436},{"name":"04-739. 每日温度.md","path":"002-数据结构与算法/003-栈与队列/01-单调栈/04-739. 每日温度.md","content":"### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)\n\n题目\n\n```\n给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n示例 1:\n输入: t = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n```\n\n思路：\n\n用单调栈，初始化时t[0]入栈，依次遍历剩余元素，新元素入栈时先将站内比自己小的元素取出，更新结果集res\n\n```java\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        int n = temperatures.length;\n        int[] res = new int[n];\n        Deque<Integer> s = new LinkedList<>();\n        s.push(0);\n        for(int i = 1; i < n; i++) {\n            while(!s.isEmpty() && temperatures[i] > temperatures[s.peek()]) {\n                res[s.peek()] = i - s.peek();\n                s.pop();\n            }\n            s.push(i);\n        }\n\n        return res;\n    }\n}\n```\n\n优化\n\n```java\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        int[] res = new int[temperatures.length];\n        Deque<Integer> stack = new LinkedList<>();\n      \t// s.push(0); 优化一，for从0开始\n        for(int i = 0; i < temperatures.length; i++) {\n            while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n                res[stack.peek()] = i - stack.peek();\n                stack.pop();\n            }\n            stack.push(i);\n        }\n\n        // System.out.println(Arrays.toString(res));\n\n        return res;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"05-42.接雨水.md","path":"002-数据结构与算法/003-栈与队列/01-单调栈/05-42.接雨水.md","content":"### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)\n\n#### 方法一：单调栈\n\n情况2：高度 = 栈顶元素高度\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/15/16373116841398511684139851299uftOQg-19583216733519121673351912945DlbuoT-image-20230110195832788.png\" alt=\"image-20230110195832788\" style=\"zoom: 50%;\" />\n\n情况3：高度 > 栈顶元素高度\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/01/10/20044816733522881673352288357WQw3Qe-image-20230110200448235.png\" alt=\"image-20230110200448235\" style=\"zoom:50%;\" />\n\n\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        // int[] next = new int[height.length];\n        int res = 0;\n        Deque<Integer> s = new LinkedList<>();  // height下标\n        s.push(0);\n        for(int i = 1; i < height.length; i++) {\n            if(height[i] < height[s.peek()]) {  // 情况1: 高度 < 栈顶元素高度\n                s.push(i);\n            } else if (height[i] == height[s.peek()]) { \t// 情况2: 高度 = 栈顶元素高度\n                s.pop();\n                s.push(i);\n            } else {\t\t// 情况3: 高度 > 栈顶元素高度\n                while(!s.isEmpty() && height[i] > height[s.peek()]) {\n                    int mid = s.peek();\n                    s.pop();\n                    if(!s.isEmpty()) {\n                        int left = s.peek();\n                        int width = i - left - 1;\n                        int h = Math.min(height[left], height[i]) - height[mid];\n                        res += h * width;\n                    }\n                }\n                s.push(i);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法二：双指针\n\n按列计算雨水，宽度为1，只需计算每一列的高度\n\n如何求高度？\n\n```\n可以看出每一列雨水的高度，取决于，该列 左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度。\n例如4那一列的高度，4两边最高的高度是3和7，列4的雨水高度为列3-列4\n```\n\n![image-20230516131247597](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/16/13124716842139671684213967737fHAFo4-image-20230516131247597.png)\n\n\n\n思路：按列计算雨水，遍历到i时，分别找到`i`两侧比`i`**最高**的的柱子\n\n![image-20230111103046060](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/15/16373216841398521684139852308WGZPpK-10304616734042461673404246243ffXz0b-image-20230111103046060.png)\n\n错解：只找了比i高的，没有找最高的。如遍历到5时，找的柱子是4和6，导致少算了1滴雨水\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int res = 0;\n        for(int i = 0; i < height.length; i++) {\n            if(i == 0 || i == height.length - 1) continue;\n\n            int left = i - 1;\n            while(left > 0 && height[left] <= height[i]) left--;\n\n            int right = i + 1;\n            while(right < height.length - 1 && height[right] <= height[i]) right++;\n\n            int h = Math.min(height[left], height[right]) - height[i];\n\n            System.out.print(h + \" \");\n\n            if(h > 0) res += h;\n        }\n\n        return res;\n    }\n}\n```\n\njava\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int res = 0;\n        for(int i = 0; i < height.length; i++) {\n            if(i == 0 || i == height.length - 1) continue;\n\n          \t// 找左边自己高的最高柱子\n            int left = height[i];\n            for(int l = i; l >= 0; l--) {\n                if(height[l] > left) left = height[l];\n            }\n\n          \t// 找右边比自己高的最高柱子\n            int right = height[i];\n            for(int r = i + 1; r < height.length; r++) {\n                if(height[r] > right) right = height[r];\n            }\n\n            int h = Math.min(left, right) - height[i];\n\n            // System.out.print(h + \" \");\n\n            if(h > 0) res += h;\n\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法三：dp\n\n双指针解法中，每次向两侧寻找最高柱子是会重复计算的\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int len = height.length;\n        int[] dpL = new int[len];\n        int[] dpR = new int[len];\n\n        dpL[0] = height[0];\n        for(int i = 1; i < len; i++) {\n            dpL[i] = Math.max(height[i], dpL[i - 1]);\n        }\n\n        dpR[len - 1] = height[len - 1];\n        for(int i = len - 2; i >= 0; i--) {\n            dpR[i] = Math.max(height[i], dpR[i + 1]);\n        }\n\n        int res = 0;\n        for(int i = 0; i < len; i++) {\n            int h = Math.min(dpL[i], dpR[i]) - height[i];\n            if(h > 0) res += h;\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n#### 方法四：双指针2（最简单）\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int l = 0, r = height.length - 1;\n        int lMax = 0, rMax = 0;\n\n        int res = 0;\n        while(l < r) {\n            lMax = Math.max(lMax, height[l]);\n            rMax = Math.max(rMax, height[r]);\n\n            if(lMax < rMax) {\n                res += lMax - height[l];\n                l++;\n            } else {\n                res += rMax - height[r];\n                r--;\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n参考：https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-gao--0d5eb/\n","timestamp":1692285118436},{"name":"06-84. 柱状图中最大的矩形.md","path":"002-数据结构与算法/003-栈与队列/01-单调栈/06-84. 柱状图中最大的矩形.md","content":"### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)\n\n#### 方法一：单调栈\n\n**思考**： \n\n为什么会用单调栈\n\n```\n在一维数组中对每一个数找到第一个比自己小的元素。这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。\n```\n\n为什么是找到第一个比自己小的？\n\n```\n当右侧元素比自己大时，那么面积一定是变大的，当碰到比栈顶元素小时，说明面积可能在变小\n```\n\n开头为什么要加元素0？\n\n```\n如果数组本身是降序的，例如 [8,6,4,2]，在 8 入栈后，6 开始与8 进行比较，此时我们得到 mid（8），rigt（6），但是得不到 left，无法计算面积\n```\n\n结尾为什么要加元素0？\n\n```\n输入为[2,1,2]时，当遍历到第二个2，右边已经没有比它小的元素了，所以永远不会计算第二个2的面积\n```\n\n**错解**：计算面积时用[ )\n\n```\n[2,1,2]\nOutput: 2\nExpected: 3\n```\n\n\n\n```java\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        // 扩容数组，首尾添0\n        int[] newHeights = new int[n + 2];\n        newHeights[0] = 0;\n        newHeights[newHeights.length - 1] = 0;\n        for(int i = 0; i < heights.length; i++) newHeights[i + 1] = heights[i];\n\n        int res = 0;\n        Deque<Integer> s = new LinkedList<>();\n        s.push(0);\n        for(int i = 1; i < newHeights.length; i++) {\n            // System.out.println(newHeights[i]);\n            if(newHeights[i] > newHeights[s.peek()]) {\n                s.push(i);\n            } else if(newHeights[i] == newHeights[s.peek()]) {\n                s.push(i);\n            } else {\n                while(!s.isEmpty() && newHeights[i] < newHeights[s.peek()]) {\t// 依次取栈中比当前元素大的元素作为高计算面积\n                    // 面积区间[)\n                    int r = i;  // 面积不包括r\n                    int l = s.peek();\n                    int h = newHeights[l];\n                    int width = r - l;\n                    res = Math.max(res, width * h);\n                    s.pop();\n                    // System.out.println(\"res: \" + res);\n                }\n                s.push(i);\n            }\n        }\n\n        return res; // [2,1,2]\n    }\n}\n```\n\n正解\n\n```\n[2 3 1]\n计算面积时用()\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/16/09572816842022481684202248434V0WfWT-image-20230516095728201.png\" alt=\"image-20230516095728201\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/16/09585916842023391684202339502Z24Nww-image-20230516095859380.png\" alt=\"image-20230516095859380\" style=\"zoom:50%;\" />\n\n```java\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        // 扩容数组，首尾添0\n        int[] newHeights = new int[n + 2];\n        newHeights[0] = 0;\n        newHeights[newHeights.length - 1] = 0;\n        for(int i = 0; i < heights.length; i++) newHeights[i + 1] = heights[i];\n\n        int res = 0;\n        Deque<Integer> s = new LinkedList<>();\n        s.push(0);\n        for(int i = 1; i < newHeights.length; i++) {\n            // System.out.println(newHeights[i]);\n            if(newHeights[i] > newHeights[s.peek()]) {\n                s.push(i);\n            } else if(newHeights[i] == newHeights[s.peek()]) {\n                // s.pop();    // 可省略, 省略后思路不同\n                s.push(i);\n            } else {\n                while(!s.isEmpty() && newHeights[i] < newHeights[s.peek()]) {\n                    // 面积区间()\n                    int r = i;  // 面积不包括r\n                    int mid = s.peek();\n                    s.pop();\n                    int l = s.peek();\n                    int h = newHeights[mid];\n                    int width = r - l - 1;\n                    res = Math.max(res, width * h);\n                    \n                    // System.out.println(\"res: \" + res);\n                }\n                s.push(i);\n            }\n        }\n\n        return res; // [2,1,2]\n    }\n}\n```\n\n\n\n#### 方法二：双指针\n\n找两侧比自己小的第一个元素\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/16/10145116842032911684203291336gjNWii-13345516734152951673415295957n7eOWJ-image-20230111133455755.png\" alt=\"image-20230111133455755\" style=\"zoom:50%;\" />\n\n在接雨水中，按列计算，宽度始终是1，所以l、r直接记录高度，此处记录下标\n\n接雨水要分别找两侧比自己最高的柱子，用`for`；此处分别找两侧第一个比自己小的，用`while`\n\n```java\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int res = 0;\n        int len = heights.length;\n        for(int i = 0; i < len; i++) {\n            // 找左边比自己小的\n            int l = i;\n            while(l >= 0 && heights[l] >= heights[i]) l--;\n\n          \t// 找右边比自己小的\n            int r = i;\n            while(r < len && heights[r] >= heights[i]) r++;\n\n            int w = r - l - 1;\t// 面积区间为（l, r）\n\n            // System.out.print(w * heights[i] + \" \");\n\n            res = Math.max(w * heights[i], res);\n        }\n\n        return res;\n    }\n}\n```\n\n#### 方法三：dp\n\n难点：如何找出左侧第一个比自己小的\n\n错解：\n\n左边邻居不一定比自己小，左邻居的第一个最小值dp[i - 1]`也不一定比自己小，以2为例，所以不能用if\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/05/16/10145116842032911684203291705qa4rPz-13584416734167241673416724919Nz5c2y-image-20230111135844803.png\" alt=\"image-20230111135844803\" style=\"zoom:33%;\" />\n\n```java\nfor(int l = 1; l < len; l++) {\n    if(heights[l - 1] < heights[l]) {\n      dpL[l] = l - 1;\n    } else if(heights[dpL[l - 1]] < heights[l]) {\n      dpL[l] = dpL[l - 1];\n    } else {\n      dpL[l] = l;\n    }\n}\n```\n\n正解：\n\n```java\ndpL[0] = -1;\t// 为了能让while退出循环\n  for(int l = 1; l < len; l++) {\n    int tmp = l - 1;\n    while(tmp >= 0 && heights[tmp] >= heights[l]) tmp = dpL[tmp];\n    dpL[l] = tmp;\n}\n```\n\njava\n\n```java\nclass Solution {\n    public int largestRectangleArea(int[] heights) {\n        int len = heights.length;\n        int[] dpL = new int[len];\n        int[] dpR = new int[len];\n\n        dpL[0] = -1;\n        for(int l = 1; l < len; l++) {\n            int tmp = l - 1;\n            while(tmp >= 0 && heights[tmp] >= heights[l]) tmp = dpL[tmp];\n            dpL[l] = tmp;\n        }\n        // System.out.println(Arrays.toString(dpL));\n\n        dpR[len - 1] = len;\n        for(int r = len - 2; r >= 0; r--) {\n            int tmp = r + 1;\n            while(tmp < len && heights[tmp] >= heights[r]) tmp = dpR[tmp];\n            dpR[r] = tmp;\n        }\n        //  System.out.println(Arrays.toString(dpR));\n\n        int res = 0;\n        for(int i = 0; i < len; i++) {\n            int w = dpR[i] - dpL[i] - 1;\n            int area = w * heights[i];\n            res = Math.max(res, area);\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"01-nSum问题.md","path":"002-数据结构与算法/004-哈希表/01-nSum问题.md","content":"# [一个函数秒杀 2Sum 3Sum 4Sum 问题](https://mp.weixin.qq.com/s/fSyJVvggxHq28a0SdmZm6Q)\n\n\n\n### [1. 两数之和](https://leetcode.cn/problems/two-sum/)\n\n```\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n#### 哈希表\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++) {\n          \tint need = target - nums[i]);\n            if(map.containsKey(need) {\n                return new int[]{i, map.get(need};\n            } else {\n                map.put(nums[i], i);\n            }\n        }\n        return new int[]{};\n    }\n}\n```\n\n\n\n### 1.两数之和改编\n\n```\n改题：\n1 返回元素，不返回下标\n2 数组中可能出现多组答案，要求答案去重\tnums = [1,1,1,2,2,3,3], target = 4\n```\n\n```java\nvector<vector<int>> twoSumTarget(vector<int>& nums, int target) {\n    // nums 数组必须有序\n    sort(nums.begin(), nums.end());\n    int lo = 0, hi = nums.size() - 1;\n    vector<vector<int>> res;\n    while (lo < hi) {\n        int sum = nums[lo] + nums[hi];\n        int left = nums[lo], right = nums[hi];\n        if (sum < target) {\n            while (lo < hi && nums[lo] == left) lo++;\n        } else if (sum > target) {\n            while (lo < hi && nums[hi] == right) hi--;\n        } else {\n            res.push_back({left, right});\n            while (lo < hi && nums[lo] == left) lo++;\n            while (lo < hi && nums[hi] == right) hi--;\n        }\n    }\n    return res;\n}\n```\n\n\n\n### [15. 三数之和](https://leetcode.cn/problems/3sum/)\n\n```\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n```\n\n\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        int n = nums.length;\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i++) {\n            // 排序后第一个值大于0，一定找不到和为0的解\n            if(nums[i] > 0) return res;\n            \n            if (i > 0 && nums[i] == nums[i - 1]) {  // 去重第一个数\n                continue;\n            }\n\n            // 两数之和\n            int l = i + 1, r = n - 1;\n            while(l < r) {\n                if(nums[i] + nums[l] + nums[r] < 0) {\n                    l++;\n                } else if(nums[i] + nums[l] + nums[r] > 0) {\n                    r--;\n                } else {\n                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                    // 对第2、3个数去重\n                    while(l < r && nums[l] == nums[l+1]) l++;\n                    while(l < r && nums[r] == nums[r-1]) r--;\n                    \n                    l++;\n                    r--;\n                }\n            }\n        }\n\n        return res;\n    }\n}\n\n代码随想录：https://programmercarl.com/0015.三数之和.html#双指针\n```\n\n\n\n### [18. 四数之和](https://leetcode.cn/problems/4sum/)\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        int n = nums.length;\n        for(int i = 0; i < n; i++) {\n            if (nums[i] > 0 && nums[i] > target) {  // 理论上已经不存在解\n                return res;\n            }\n\n            if(i > 0 && nums[i] == nums[i - 1]) continue;\n\n            for(int j = i + 1; j < n; j++) {\n                if(j > i + 1 && nums[j] == nums[j - 1]) continue;\n\n                int l = j + 1, r = n - 1;\n                while(l < r) {\n                    long sum = (long)nums[i] + nums[j] + nums[l] + nums[r];\n                    if(sum == target) {\n                        res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));\n                        while(l < r && nums[l] == nums[l + 1]) l++;\n                        while(l < r && nums[r] == nums[r - 1]) r--;\n\n                        l++;\n                        r--;\n                    } else if(sum < target) {\n                        l++;\n                    } else {\n                        r--;\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n}\n\n代码随想录：https://programmercarl.com/0018.四数之和.html#其他语言版本\n```\n\n写法二\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        int n = nums.length;\n        // [-2 -1 0 0 1 2]\n        for(int i = 0; i < n; i++) {\n            \n            if (nums[i] > 0 && nums[i] > target) {  // 理论上已经不存在解\n                return res;\n            }\n            \n            if(i > 0 && nums[i] == nums[i - 1]) continue;   // 第一个数去重\n\n            // 找三数和\n            long target1 = (long)target - nums[i];\n            for(int j = i + 1; j < n; j++) {\n                if(j > i + 1 && nums[j] == nums[j - 1]) continue;   // 第二个数去重\n                \n                // 找两数和\n                long target2 = target1 - nums[j];\n                int l = j + 1, r = n - 1;\n                while(l < r) {\n                    long sum = (long)nums[l] + nums[r];\n                    if(sum == target2) {\n                        res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));\n                        while(l < r && nums[l] == nums[l + 1]) l++;     // 第三个数去重\n                        while(l < r && nums[r] == nums[r - 1]) r--;     // 第四个数去重\n\n                        l++;\n                        r--;\n                    } else if(sum < target2) {\n                        l++;\n                    } else {\n                        r--;\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"00-总结.md","path":"002-数据结构与算法/005-回溯法/01-组合问题/00-总结.md","content":"![image-20230711170612540](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/11/17061216890663721689066372731gdhAG4-image-20230711170612540.png)","timestamp":1692285118436},{"name":"01-77. 组合.md","path":"002-数据结构与算法/005-回溯法/01-组合问题/01-77. 组合.md","content":"### [77. 组合](https://leetcode.cn/problems/combinations/)\n\n\n\n```java\nclass Solution {\n\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>(); // 优化：LinkedList<Integer> path = new LinkedList<>();\n\n    public List<List<Integer>> combine(int n, int k) {\n        trackback(1, n, k);\n\n        return res;\n    }\n\n    public void trackback(int startIndex, int n, int k) {\n        if(path.size() == k) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = startIndex; i <= n; i++) {\n            path.add(i);    // 处理节点\n            trackback(i + 1, n, k);     // 递归，下一层， 此处是i + 1， 不是startIndex+1, 问题见下方\n            path.remove(path.size() - 1);   // 回溯\n        }\n    }\n}\n```\n\n如果是trackback(startIndex + 1, n, k); \n\n```\n如startIndex为1，\n遍历完第一个分支（即第一次取1）,\nfor(int i = startIndex; i <= n; i++)开始横向遍历下一个节点，即取2\npath.add(2)\t// 取2\ntrackback(startIndex + 1 = 2, n, k)  // 进入下一层， i = 2, path.add（2）,会导致重复\n\n4 2\n输出：[[1,2],[1,3],[1,4],[2,2],[2,3],[2,4],[3,2],[3,3],[3,4],[4,2],[4,3],[4,4]]\n预期：[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n```\n\n**优化：剪枝**\n\n![image-20221020144841245](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/20/14484116662485211666248521351PPcsDf-image-20221020144841245.png)\n\n-   已经选择的个数：path.size()\n-   需要的个数：k - path.size();\n-   n个元素中极限的遍历起始位置 n - (k - path.size()) + 1;\n    -   例题中，第一层，从2开始，只有三个元素，已经达不到要求的k=4个元素，剪枝\n    -   为什么要+1？ n = 4, k = 4, path.size() = 0 时，n - (k - path.size())  = 0。根据实际情况，至少会包含起始位置\n\n```java\nclass Solution {\n\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> combine(int n, int k) {\n        trackback(1, n, k);\n\n        return res;\n    }\n\n    public void trackback(int startIndex, int n, int k) {\n        if(path.size() == k) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = startIndex; i <= n - (k - path.size()) + 1; i++) {\t// 剪枝\n            path.add(i);    // 处理节点\n            trackback(i + 1, n, k);     // 递归，下一层，\n            path.remove(path.size() - 1);   // 回溯\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n","timestamp":1692285118436},{"name":"02-216. 组合总和 III.md","path":"002-数据结构与算法/005-回溯法/01-组合问题/02-216. 组合总和 III.md","content":"### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)\n\n```java\nclass Solution {\n\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    int pathSum = 0;\n\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        trackback(n, k, 1);\n        return res;\n    }\n\n    public void trackback(int target, int k, int startIndex) {\n        if(pathSum == target && path.size() == k) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = startIndex; i <= 9; i++) {\n            path.add(i);\n            pathSum += i;\n          \n            trackback(target, k, i + 1);\n          \n            path.remove(path.size() - 1);\n            pathSum -= i;\n        }\n    }\n}\n```\n\n剪枝\n\n```java\nclass Solution {\n\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    int pathSum = 0;\n\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        trackback(n, k, 1);\n        return res;\n    }\n\n    public void trackback(int target, int k, int startIndex) {\n        // 剪枝2: 总和已经超过target\n        if(pathSum > target) {\n            return;\n        }\n        if(pathSum == target && path.size() == k) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) {  // 剪枝1：极限起始点\n            path.add(i);\n            pathSum += i;\n            trackback(target, k, i + 1);\n            path.remove(path.size() - 1);\n            pathSum -= i;\n        }\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"03-39. 组合总和.md","path":"002-数据结构与算法/005-回溯法/01-组合问题/03-39. 组合总和.md","content":"\n\n### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)\n\n![image-20221021101144121](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/21/13190216663295421666329542095IDpPXK-10114416663183041666318304237D8ptwh-image-20221021101144121.png)\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    Integer pathSum = 0;\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        trackback(candidates, target, 0);\n        return res;\n    }\n\n    public void trackback(int[] nums, int target, int start) {\n        // 结束条件\n        if(pathSum == target) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        // // 剪枝1: 超出后结束\n         if(pathSum > target) {\n             return;\n         }\n\n        for(int i = start; i < nums.length; i++) {  // 剪枝2: 加上pathSum + nums[i] <= target\n            // if(pathSum > target) { // 剪枝(在上边剪枝更优)\n            //    continue;\n            // }\n            path.add(nums[i]);\n            pathSum += nums[i];\n\n            trackback(nums, target, i);\n\n            path.remove(path.size() - 1);\n            pathSum -= nums[i];\n        }\n    }\n}\n```\n[参考](https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/)\n\n","timestamp":1692285118436},{"name":"04-40. 组合总和 II.md","path":"002-数据结构与算法/005-回溯法/01-组合问题/04-40. 组合总和 II.md","content":"### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)\n\n与39.组合总和的不同处在于：\n\n-   集合有重复元素\n-   要求不能重复使用\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    int pathSum = 0;\n\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\t// 区别1: 先排序，用于限制使用相同元素\n        trackback(candidates, target, 0);\n        return res;\n    }\n\n    public void trackback(int[] candidates, int target, int start) {\n        if(pathSum == target) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        if(pathSum > target) {\n            return;\n        }\n\n        for(int i = start; i < candidates.length; i++) {\n            if(i > start && candidates[i] == candidates[i - 1]) {\t // 区别1: 元素不能重复使用\n                continue;\n            }\n\n            path.add(candidates[i]);\n            pathSum += candidates[i];\n\n            trackback(candidates, target, i + 1);  // 区别3: 从i+1下一个元素开始\n\n            path.remove(path.size() - 1);\n            pathSum -= candidates[i];\n        }\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"05-17. 电话号码的字母组合.md","path":"002-数据结构与算法/005-回溯法/01-组合问题/05-17. 电话号码的字母组合.md","content":"### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)\n\n```java\nclass Solution {\n    List<String> res = new ArrayList<>();\n    String[] letterMap = new String[]{\n        \"\",     // 0\n        \"\",     // 1\n        \"abc\",  // 2\n        \"def\",  // 3\n        \"ghi\",  // 4\n        \"jkl\",  // 5\n        \"mno\",  // 6\n        \"pqrs\", // 7\n        \"tuv\",  // 8\n        \"wxyz\", // 9\n    };\n    String str = \"\";\n\n    public List<String> letterCombinations(String digits) {\n        if(\"\".equals(digits)) {    // 此处不能用==\n            return res;\n        }\n        trackback(digits, 0);\n        return res;\n    }\n\n    public void trackback(String digits, int start) {  // start：遍历到的digits的下标\n        // 结束条件，递归层数 = digits的长度\n        if(str.length() == digits.length()) {\n            res.add(str);\n            return;\n        }\n\n        String letterStr = letterMap[digits.charAt(start) - \'0\'];  // 以digits[0]对应的字符串作为树根\n        for(int i = 0; i < letterStr.length(); i++) {  \n            str += letterStr.charAt(i);\n\n            trackback(digits, start + 1);\n\n            str = str.substring(0, str.length() - 1);\n        }\n    }\n}\n```\n\n优化：使用StringBuilder\n\n```java\nclass Solution {\n    List<String> res = new ArrayList<>();\n    String[] letterMap = new String[]{\n        \"\",     // 0\n        \"\",     // 1\n        \"abc\",  // 2\n        \"def\",  // 3\n        \"ghi\",  // 4\n        \"jkl\",  // 5\n        \"mno\",  // 6\n        \"pqrs\", // 7\n        \"tuv\",  // 8\n        \"wxyz\", // 9\n    };\n    // String str = \"\";\n    StringBuilder sb = new StringBuilder();\n\n    public List<String> letterCombinations(String digits) {\n        if(\"\".equals(digits)) {    // 此处不能用==\n            return res;\n        }\n        trackback(digits, 0);\n        return res;\n    }\n\n    public void trackback(String digits, int start) {  // start：遍历到的digits的下标\n        // 结束条件，递归层数 = digits的长度\n        if(start == digits.length()) {\n            res.add(sb.toString());\n            return;\n        }\n\n        String letterStr = letterMap[digits.charAt(start) - \'0\'];  // 以digits[0]对应的字符串作为树根\n        for(int i = 0; i < letterStr.length(); i++) {  \n            sb.append(letterStr.charAt(i));\n\n            trackback(digits, start + 1);\n\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"01-46. 全排列.md","path":"002-数据结构与算法/005-回溯法/02-排列问题/01-46. 全排列.md","content":"### [46. 全排列](https://leetcode.cn/problems/permutations/)\n\n![image-20221022115431243](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/22/11543116664108711666410871351OvvpEi-image-20221022115431243.png)\n\n不重复元素全排列\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>(); // 频繁增删用LinkedList\n\n    public List<List<Integer>> permute(int[] nums) {\n        trackback(nums, new boolean[nums.length]);\n        return res;\n    }\n\n    public void trackback(int[] nums,  boolean[] used) {\n        if(path.size() == nums.length) {\n            res.add(new ArrayList<>(path));\t// 易错点\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(used[i]) {\t\t// used[i]==true 说明同一树枝使用过\n                continue;\n            }\n\n            path.add(nums[i]);\n            used[i] = true;\n\n            trackback(nums, used);\n\n            used[i] = false;\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n**优化：**\n\n不使用used，直接在path中判断是否存在该数字来判断是否已经使用\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> permute(int[] nums) {\n        trackback(nums);\n        return res;\n    }\n\n    public void trackback(int[] nums) {\n        if(path.size() == nums.length) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            // 如果path中已有，则跳过\n            if (path.contains(nums[i])) {\n                continue;\n            } \n\n            path.add(nums[i]);\n\n            trackback(nums);\n\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n其他写法：频繁增删用LinkedList\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n\n    public List<List<Integer>> permute(int[] nums) {\n        LinkedList<Integer> path = new LinkedList<>();\n        boolean[] used = new boolean[nums.length];\n        backtrack(nums, path, used);\n        return res;\n    }\n\n    public void backtrack(int[] nums, LinkedList<Integer> path, boolean[] used) {\n        if(path.size() == nums.length) {\n            res.add(new LinkedList(path));\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(used[i]) {\n                continue;\n            }\n\n            used[i] = true;\n            path.add(nums[i]);\n            backtrack(nums, path, used);\n            path.removeLast();\n            used[i] = false;\n        }\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"02-47. 全排列 II.md","path":"002-数据结构与算法/005-回溯法/02-排列问题/02-47. 全排列 II.md","content":"### [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)\n\n包含重复元素的全排列\n\n#### 写法1: 树枝去重\n\n![image-20230713135753288](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/13/13575316892278731689227873425K8WHBe-image-20230713135753288.png)\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        trackback(nums, new boolean[nums.length]);\n        return res;\n    }\n\n    public void trackback(int[] nums, boolean[] used) {\n        if(path.size() == nums.length) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(i > 0 && nums[i] == nums[i-1] && used[i-1]) {  // 树枝去重\n                continue;\n            }\n            if(used[i]) {  // 树枝去重，已使用过的元素\n                continue;\n            }\n\n            used[i] = true;\n            path.add(nums[i]);\n\n            trackback(nums, used);\n\n            used[i] = false;\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n#### 写法2: 树层去重\n\n优化\n\n![image-20221022145505061](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/22/14550516664217051666421705203uD1Rvn-image-20221022145505061.png)\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        trackback(nums, new boolean[nums.length]);\n        return res;\n    }\n\n    public void trackback(int[] nums, boolean[] used) {\n        if(path.size() == nums.length) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(i > 0 && nums[i] == nums[i-1] && used[i-1] == false) {  // 树层去重\n                continue;\n            }\n            if(used[i]) {  // 树枝去重，已使用过的元素\n                continue;\n            }\n\n            used[i] = true;\n            path.add(nums[i]);\n\n            trackback(nums, used);\n\n            used[i] = false;\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n\n[参考](https://programmercarl.com/0047.全排列II.html#拓展)\n\n\n\n为什么需要`used[i-1]`\n\n```\nnums = [1, 1, 2]\n\n如果没有used[i-1]， if(i > 0 && nums[i] == nums[i-1]) \n该条件会把所有情况过滤掉\n\n第一次选1， 剩余[1, 2]\nused[0] = true\n下一层, \n\ti = 0: 由于used[0] = true，continue\n\ti = 1: i > 0 && nums[i] == nums[i-1], 本该选择1，但会直接过滤掉\n\n```\n\n为什么used[i-1]==0表示树层去重\n\n```\nfor循环表示横向遍历\ni=1时，i=0的分支已经遍历完了，used[i]就会回溯为0，\nnums[i] == nums[i - 1]表示前一个分支和当前分支相同\n```\n\n","timestamp":1692285118436},{"name":"03-n 51. N 皇后.md","path":"002-数据结构与算法/005-回溯法/03-n 51. N 皇后.md","content":"#### [51. N 皇后](https://leetcode.cn/problems/n-queens/)\n\n#### 错解\n\n不能通过`(i < n-1 && used[i+1]) || (i > 0 && used[i-1])`判断是否在同一斜线，隔行后不适用\n\n```java\nclass Solution {\n    List<List<String>> res = new ArrayList<>();\n    List<String> path = new ArrayList();\n    // List<Integer> location = new ArrayList();\n\n    public List<List<String>> solveNQueens(int n) {\n        trackback(n, new boolean[n]);\n        return res;\n\n    }\n\n    public void trackback(int n, boolean[] used) {\n        if(path.size() == n) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        for(int i=0; i<n; i++) {\n            if(used[i]) {  // 同一列\n                continue;\n            }\n            if((i < n-1 && used[i+1]) || (i > 0 && used[i-1])) {  // 同一斜线\n                continue;\n\n            }\n\n            used[i] = true;\n            path.add(buildStr(i));\n\n            trackback(n, used);\n\n            used[i] = false;\n            path.remove(path.size() - 1);\n\n        }\n    }\n\n    public String buildStr(int i) {\n        StringBuilder sb = new StringBuilder(\"....\");\n        sb.setCharAt(i, \'Q\');\n        return sb.toString();\n    }\n}\n```\n\n![image-20221023104747966](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/23/1047481666493268166649326815890zpR9-image-20221023104747966.png)\n\n```java\nclass Solution {\n    List<List<String>> res = new ArrayList<>();\n\n    public List<List<String>> solveNQueens(int n) {\n        char[][] chessboard = new char[n][n];\n        for (char[] c : chessboard) {\n            Arrays.fill(c, \'.\');\t\t// x\n        }\n\n        trackback(n, 0, chessboard);\n        return res;\n\n    }\n\n    public void trackback(int n, int row, char[][] chessboard) {\t// x\n        if(row == n) {\n            res.add(Array2List(chessboard));\n            return;\n        }\n\n        for(int col=0; col<n; col++) {\n            if(!isValid(row, col, n, chessboard)) {\n                continue;\n            }\n\n            chessboard[row][col] = \'Q\';\n            trackback(n, row + 1,  chessboard);\n            chessboard[row][col] = \'.\';\n        }\n    }\n\n    public List Array2List(char[][] chessboard) {\n        List<String> list = new ArrayList<>();\n\n        for (char[] c : chessboard) {\n            list.add(String.copyValueOf(c));\t\t// x\n        }\n        return list;\n    }\n\n    public boolean isValid(int row, int col, int n, char[][] chessboard) {\n        // 同列\n        for(int i=0; i<row; i++) {\n            if(chessboard[i][col] == \'Q\') {\n                return false;\n            }\n        }\n\n        // 45度斜线\n        for(int i=row-1, j=col+1; i>=0 && j<n; i--, j++) {\n            if(chessboard[i][j] == \'Q\') {\n                return false;\n            }\n        }\n\n        // 135度斜线\n        for(int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {\n            if(chessboard[i][j] == \'Q\') {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"04- 52. N皇后 II.md","path":"002-数据结构与算法/005-回溯法/04- 52. N皇后 II.md","content":"### [52. N皇后 II](https://leetcode.cn/problems/n-queens-ii/)\n\n解题过程同n皇后1\n\n```\nclass Solution {\n\n    int res = 0;\n\n    public int totalNQueens(int n) {\n        int[][] chessboard = new int[n][n];\n        trackback(chessboard, n, 0);\n        return res;\n    }\n\n    public void trackback(int[][] chessboard, int n, int row) {\n        if(row == n) {\n            res++;\n            return;\n        }\n\n        for(int col = 0; col < n; col++) {\n            if(!isValid(chessboard, n, row, col)) {\n                continue;\n            }\n\n            chessboard[row][col] = 1;\n            trackback(chessboard, n, row + 1);\n            chessboard[row][col] = 0;\n        }\n    }\n\n    public boolean isValid(int[][] chessboard, int n, int row, int col) {\n        // 同列\n        for(int i = 0; i < row; i++) {\n            if(chessboard[i][col] == 1) return false;\n        }\n\n        // 45度\n        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n            if(chessboard[i][j] == 1) return false;\n        }\n\n        // 135度\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if(chessboard[i][j] == 1) return false;\n        }\n\n        return true;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"01-理论.md","path":"002-数据结构与算法/006-堆/01-理论.md","content":"优先级队列PriorityQueue\n\n```java\nPriorityQueue<Integer> numbers = new PriorityQueue<>();\n\n// 添加\nadd() - 将指定的元素插入队列。如果队列已满，则会引发异常。\noffer() - 将指定的元素插入队列。如果队列已满，则返回false。\n  \n// 队列头部\npeek()\n  \n// 删除\nremove() - 从队列中删除指定的元素\npoll() - 返回并删除队列的开头\n  \n// 遍历\n// 1. 使用iterator()方法\nIterator<Integer> iterate = numbers.iterator();\nwhile(iterate.hasNext()) {\n  System.out.print(iterate.next());\n  System.out.print(\", \");\n}\n\n// 其他\ncontains(element)\t\t// 在优先级队列中搜索指定的元素。如果找到该元素，则返回true，否则返回false。\ntoArray()\t\t// 将优先级队列转换为数组，并返回它。‘\nsize()\t\t\t//返回队列元素个数\nisEmpty()\t\t//判断队列是否为空，为空返回true,不空返回false\n```\n\n比较器\n\n```java\n//自定义比较器，降序排列\nstatic Comparator<Integer> cmp = new Comparator<Integer>() {\n      public int compare(Integer e1, Integer e2) {\n        // 降序\n        return e2 - e1;\t\n        \n        //升序\n        // return e1-e2;\n      }\n};\n\npublic static void main(String[] args) {\n        //不用比较器，默认升序排列。输出结果2 3 4 \n        Queue<Integer> q = new PriorityQueue<>();\n        q.add(3);\n        q.add(2);\n        q.add(4);\n        while(!q.isEmpty()) System.out.print(q.poll() + \" \");\n\n        //使用自定义比较器，降序排列 4 3 2 \n        Queue<Integer> qq = new PriorityQueue<>(cmp);\n        qq.add(3);\n        qq.add(2);\n        qq.add(4);\n  \t\t\twhile(!q.isEmpty()) System.out.print(q.poll() + \" \");\n  \n}\n```\n\n简写\n\n```java\nPriorityQueue<int[]> pq = new PriorityQueue<>(o1, o2) -> o1-o2);\n```\n\n[参考](https://www.cnblogs.com/wei-jing/p/10806236.html)\n\n[参考](https://www.cainiaojc.com/java/java-priorityqueue.html)","timestamp":1692285118436},{"name":"01-岛屿问题.md","path":"002-数据结构与算法/007-图论/01-岛屿问题.md","content":"[岛屿类问题](https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)\n\n### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)\n\n```java\nclass Solution {\n    public int numIslands(char[][] grid) {\n        int res = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == \'1\') {\n                    dfs(grid, i, j);\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n\n    public void dfs(char[][] grid, int r, int c) {\n        if(!inArea(grid, r, c)) {\n            return;\n        }\n\n        if(grid[r][c] != \'1\') {\n            return;\n        }\n\n        grid[r][c] = 2;\n\n        dfs(grid, r - 1, c);\n        dfs(grid, \n            r + 1, c);\n        dfs(grid , r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\n    boolean inArea(char[][]grid, int r, int c) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        return r >= 0 && r < rows && c >=0 && c < cols;\n    }\n}\n```\n\n\n\n### [463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)\n\n![image-20221212102508604](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/12/12/10250816708119081670811908804Ql7ILJ-image-20221212102508604.png)\n\n\n\n```java\nclass Solution {\n    public int islandPerimeter(int[][] grid) {\n        int res = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == 1) {\n                    res += dfs(grid, i, j);\n                }\n            }\n        }\n\n        return res;\n    }\n\n    public int dfs(int[][]grid, int row, int col) {\n        // 超出范围返回，对应黄边\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) {\n            return 1;\n        }\n\n        // 遇到海洋返回，对应蓝边\n        if(grid[row][col] == 0) {\n            return 1;\n        }\n\n        // 已经遍历过了\n        if(grid[row][col] == 2) {\n            return 0;\n        }\n\n        // 标记已经遍历\n        grid[row][col] = 2;\n\n        return dfs(grid, row - 1, col) + \n               dfs(grid, row + 1, col) + \n               dfs(grid, row, col - 1) +\n               dfs(grid, row, col + 1);\n    }\n}\n```\n\n\n\n### [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)\n\n```java\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int res = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == 1) {\n                    res = Math.max(res, dfs(grid, i, j)); \n                }\n            }\n        }\n\n        return res;\n    }\n\n    public int dfs(int[][]grid, int row, int col) {\n        // 超出范围返回，对应黄边\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) {\n            return 0;\n        }\n\n        // 已经遍历过了\n        if(grid[row][col] != 1) {\n            return 0;\n        }\n\n        // 标记已经遍历\n        grid[row][col] = 2;\n\n        return 1 +\n               dfs(grid, row - 1, col) + \n               dfs(grid, row + 1, col) + \n               dfs(grid, row, col - 1) +\n               dfs(grid, row, col + 1);\n    }\n}\n```\n\n\n\n### [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/)\n\n思路：\n\n-   dfs遍历，求每块岛屿面积并进行标记\n-   遍历海水，依次变成陆地，求连接到岛屿总面积。即1 + 上下左右连接的不同岛屿的面积\n\n![image-20221212202449305](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/12/12/20244916708478891670847889489DC18W7-image-20221212202449305.png)\n\n```java\nclass Solution {\n    public int largestIsland(int[][] grid) {\n        // 给每一块岛屿编号，计算并存储每块岛屿面积\n        Map<Integer, Integer> map = new HashMap<>();\n        int id = 2;  // 0 和 1已经有含义了，从2开始，避免冲突\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == 1) {\n                    map.put(id, calcArea(grid, i, j, id));\n                    id++;\n                }\n            }\n        }\n\n        // for (Integer i : map.keySet()) {\n        //     System.out.println(\"key: \" + i + \" value: \" + map.get(i));\n        // }\n\n        // 填海造路，找最大\n        int res = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                \n                if(grid[i][j] == 0) {\n                    // System.out.println(\"===\" + i + \" \" + j + \"===\");\n                    Set<Integer> ids = getNearAreaIds(grid, i, j);\n                    int tmpArea = 0;\n                    \n                    for(int item : ids) {\n                        tmpArea += map.get(item);\n                    }\n                    res = Math.max(res, tmpArea + 1);\n                }\n            }\n        }\n\n        return res == 0 ? map.get(2) : res;  // res为0表示全是陆地，没有海\n    }\n\n   // 计算岛屿面积，并用岛屿id标记每块方格\n    public int calcArea(int[][] grid, int row, int col, int id) {\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) {\n            return 0;\n        }\n\n        if(grid[row][col] != 1) {\n            return 0;\n        }\n\n        grid[row][col] = id;\n\n        return 1 \n            + calcArea(grid, row, col + 1, id) \n            + calcArea(grid, row, col - 1, id) \n            + calcArea(grid, row + 1, col, id)\n            + calcArea(grid, row - 1, col, id);\n    }\n\n    // 判断该方格是否在界内\n    boolean inArea(int[][]grid, int r, int c) {\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\n    }\n\n    // 获取四周的陆地id\n    public Set<Integer> getNearAreaIds(int[][] grid, int row, int col) {\n        Set<Integer> islandIds = new HashSet<>();   // 岛屿编号集合\n        if(inArea(grid, row - 1, col) && grid[row - 1][col] != 0) {  // 在边界内，且不是海\n            islandIds.add(grid[row - 1][col]);\n        }\n        if(inArea(grid, row + 1, col) && grid[row + 1][col] != 0) {\n            islandIds.add(grid[row + 1][col]);\n        }\n        if(inArea(grid, row, col - 1) && grid[row][col - 1] != 0) {\n            islandIds.add(grid[row][col - 1]);\n        }\n        if(inArea(grid, row, col + 1) && grid[row][col + 1] != 0) {\n            islandIds.add(grid[row][col + 1]);\n        }\n\n        // for(int id : islandIds) {\n        //     System.out.print(id + \" \");\n        // }\n        return islandIds;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/making-a-large-island/solution/by-muse-77-37hi/)\n","timestamp":1692285118436},{"name":"02-994.腐烂的橘子.md","path":"002-数据结构与算法/007-图论/02-994.腐烂的橘子.md","content":"### [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)\n\n```java\nclass Solution {\n    public int orangesRotting(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int[][] dir = new int[][]{ {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\n        Deque<int[]> q = new LinkedList<>();\n\n        // 统计新鲜橘子熟了，腐烂橘子入队列\n        int cnt = 0;    // 新鲜橘子数量\n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                if(grid[i][j] == 1) {\n                    cnt++;\n                } else if(grid[i][j] == 2) {\n                    q.offer(new int[] {i, j});\n                }\n            }\n        }\n\n        // 统计腐烂轮数\n        int round = 0;  // 轮数\n        while(cnt > 0 && !q.isEmpty()) {\n            round++;\n            int n = q.size();\n            while(n-- > 0) {\n                int[] tmp = q.poll();\n                // 往四个方向腐烂\n                for(int i = 0; i < 4; i++) {\n                    int r = tmp[0] + dir[i][0];\n                    int c = tmp[1] + dir[i][1];\n                    if(r >= 0 && c >= 0 && r < rows && c < cols && grid[r][c] == 1) {   // 界内 & 新鲜\n                        grid[r][c] = 2;\n                        q.offer(new int[]{r, c});\n                        cnt--;\n                    }\n                }\n            }\n            \n\n        }\n\n        return cnt == 0 ? round : -1;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/rotting-oranges/solution/li-qing-si-lu-wei-shi-yao-yong-bfsyi-ji-ru-he-xie-/)","timestamp":1692285118436},{"name":"03-207. 课程表.md","path":"002-数据结构与算法/007-图论/03-207. 课程表.md","content":"### [207. 课程表](https://leetcode.cn/problems/course-schedule/)\n\n#### 方法一：入度表（广度优先遍历）\n\n```java\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] indegrees = new int[numCourses];              // 入度\n        List<List<Integer>> adjacency = new ArrayList<>();  // 邻接表\n        Deque<Integer> q = new LinkedList<>();              // 入度为0的节点\n\n        // 初始化空的邻接表\n        for(int i = 0; i < numCourses; i++) {\n            adjacency.add(new ArrayList<>());\n        }\n        // 输出化节点入度 pr[1] -> pr[0]\n        for(int[] pr : prerequisites) {\n            indegrees[pr[0]]++;\n            adjacency.get(pr[1]).add(pr[0]);\n        }\n        // 初始化辅助队列\n        for(int i = 0; i < indegrees.length; i++) {\n            if(indegrees[i] == 0) q.offer(i);\n        }\n        // 判断能否进行拓扑排序\n        while(!q.isEmpty()) {\n            int node = q.poll();\n            numCourses--;\n            for(int next : adjacency.get(node)) {           // 遍历pre的邻接节点, 入度-1\n                if(--indegrees[next] == 0) q.offer(next);   // 入度为0，则入队\n            }\n        }\n\n        return numCourses == 0;\n    }\n}\n```\n\n[什么是拓扑排序](https://www.jianshu.com/p/b59db381561a)\n\n[参考](https://leetcode.cn/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/)\n\n\n\n#### 方法二：深搜","timestamp":1692285118436},{"name":"04-79. 单词搜索.md","path":"002-数据结构与算法/007-图论/04-79. 单词搜索.md","content":"### [79. 单词搜索](https://leetcode.cn/problems/word-search/)","timestamp":1692285118436},{"name":"05-剑指 Offer 13. 机器人的运动范围.md","path":"002-数据结构与算法/007-图论/05-剑指 Offer 13. 机器人的运动范围.md","content":"#### [剑指 Offer 13. 机器人的运动范围](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)\n\n错误思想\n\n```\n遍历二维数组，求每个位置的和，统计小于k的个数\n\n问题：部分位置虽然满足小于k的条件，但并不可达\n```\n\n\n\n#### 方法1： dfs\n\n```\nclass Solution {\n\n    int m, n, k;\n    boolean[][] visited;\n\n    public int movingCount(int m, int n, int k) {\n        visited = new boolean[m][n];    // 记录是否走过\n        this.m = m;\n        this.n = n;\n        this.k = k;\n        return dfs(0, 0);\n    }\n\n    public int dfs(int r, int c) {  \n        if(r >= m || c >= n || visited[r][c] || sum(r, c) > k) return 0;    // 超出边界 & 访问过 & 坐标和超出\n        visited[r][c] = true;   // 标记为访问\n        return 1 + dfs(r + 1, c) + dfs(r, c + 1);   // 想右向下走\n    }\n\n    // 计算坐标和\n    public int sum(int r, int c) {\n        int sum = 0;\n        while(r != 0) {\n            sum += r % 10;\n            r /= 10;\n        }\n        while(c != 0) {\n            sum += c % 10;\n            c /= 10;\n        }\n\n        return sum;\n    }\n\n\n}\n```\n\nhttps://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/dfshe-bfsliang-chong-jie-jue-fang-shi-by-sdwwld/\n\n#### 方法2: bfs\n\n```java\nclass Solution {\n\n\n    public int movingCount(int m, int n, int k) {\n        int res = 0;\n        boolean[][] visited = new boolean[m][n];    // 记录是否走过\n        Deque<int[]> q = new LinkedList<>();\n        q.offer(new int[]{0, 0});\n        while(!q.isEmpty()) {\n            int[] pos = q.poll();\n            int i = pos[0], j = pos[1];\n            if(i >= m || j >= n || visited[i][j] || sum(i, j) > k) continue;\n\n            visited[i][j] = true;\n            res++;\n            q.offer(new int[]{i + 1, j});\n            q.offer(new int[]{i, j + 1});\n        }\n\n        return res;\n    }\n\n    // 计算坐标和\n    public int sum(int r, int c) {\n        int sum = 0;\n        while(r != 0) {\n            sum += r % 10;\n            r /= 10;\n        }\n        while(c != 0) {\n            sum += c % 10;\n            c /= 10;\n        }\n\n        return sum;\n    }\n\n\n}\n```\n\nhttps://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/dfshe-bfsliang-chong-jie-jue-fang-shi-by-sdwwld/","timestamp":1692285118436},{"name":"06-其他.md","path":"002-数据结构与算法/007-图论/06-其他.md","content":"https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/by-da-fei-de-tian-kong-dhms/","timestamp":1692285118436},{"name":"01-236. 二叉树的最近公共祖先.md","path":"002-数据结构与算法/008-二叉树/01-公共祖先问题/01-236. 二叉树的最近公共祖先.md","content":"### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n[参考1:代码随想录](https://programmercarl.com/0236.二叉树的最近公共祖先.html)\n\n[参考2:Labuladong](https://mp.weixin.qq.com/s/njl6nuid0aalZdH5tuDpqQ)\n\n\n\n情况1：左子树为p，右子树为q\n\n判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。\n\n![image-20221018135134765](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/18/13513416660722941666072294867gKQGEF-image-20221018135134765.png)\n\n情况2：\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/18/135357166607243716660724375217VWQOU-image-20221018135357442.png\" alt=\"image-20221018135357442\" style=\"zoom: 33%;\" />\n\n\n\n<img src=\"/Users/kuan/Library/Application%20Support/typora-user-images/image-20221018140701731.png\" alt=\"image-20221018140701731\" style=\"zoom: 33%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/202102041512582.png\" alt=\"236.二叉树的最近公共祖先2\" style=\"zoom:50%;\" />\n\n#### 方法一：后序遍历\n\n通过返回的是不是null来判断，是否找到p 或 q\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n       \treturn find(root, p, q);\n    }\n  \n  \tpublic TreeNode find(TreeNode root, TreeNode p, TreeNode q) {\n      if(root == null) {\n            return null;\n        }\n\n        if(root == p || root == q) { // 情况二，根节点为p或q\n            return root;\n        }\n\n        TreeNode left = lowestCommonAncestor(root.left, p, q);      // 左\n        TreeNode right = lowestCommonAncestor(root.right, p, q);    // 右\n\n        // 根\n        if(left != null && right != null ) {    // 情况一\n            return root;\n        }\n        if(left != null && right == null) {\n            return left;\n        }\n        if(left == null && right != null) {\n            return right;\n        }\n\n        return null;\n    }\n}\n```\n\n[参考](https://programmercarl.com/0236.二叉树的最近公共祖先.html#java)\n\n写法2\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        return traversal(root, p.val, q.val);\n    }\n\n    public TreeNode traversal(TreeNode root, int val1, int val2) {\n        if(root == null) return null;\n\n        if(root.val == val1 || root.val == val2)  {\t\t// 放在后序位置也行\n            return root;\n        }\n\n        TreeNode left = traversal(root.left, val1, val2);\n        TreeNode right = traversal(root.right, val1, val2);\n\n        if(left != null && right != null) return root;\n\n        return left != null ? left : right;\n    }\n}\n```\n\n\n\n###  [1676 题「二叉树的最近公共祖先 IV」](https://mp.weixin.qq.com/s/njl6nuid0aalZdH5tuDpqQ)\n\n多个节点的最近公共祖先，且nodes一定存在二叉树中\n\n```java\nTreeNode lowestCommonAncestor(TreeNode root, TreeNode[] nodes) { \n\t\tHashSet<Integer> hs = new HashSet<>();\n  \tfor(TreeNode node : nodes) {\n    \t\ths.add(node.val);\n    }\n  \n  \treturn find(root, hs);\n}\n\nTreeNode find(TreeNode root, HashSet<Integer> values) {\n  \tif(root == null) return null;\n  \tif(values.contains(root.val)) returnn root;\n  \tTreeNode left = find(root.left, values);\n  \tTreeNode right = find(root.right, values);\n  \t\n  \t// 同上一题\n  \tif(left != null && right != null) return root;\n  \t\n  \treturn left != null ? left, right;\n}\n```\n\n\n\n### 1644 题「二叉树的最近公共祖先 II」\n\n找p和q的公共祖先，如果p或q不存在，返回null\n\n```java\nboolean findP = false, findQ = false;\n\nTreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { \n\t\tTreeNode res = find(root, p.val, q.val);\n    if (!foundP || !foundQ) {\n        return null;\n    }\n    // p 和 q 都存在二叉树中，才有公共祖先\n    return res;\n}\n\nTreeNode find(TreeNode root, int val1, int val2) {\n\tif(root == null) return null;\n  \n  TreeNode left = find(root.left, val1, val2);\n  TreeNode right = find(root.right, val1, val2);\n  \n  if(left ！= null && right != null) return root;\n  \n  // 后序位置，判断当前节点是不是目标值\n    if (root.val == val1 || root.val == val2) {\n        // 找到了，记录一下\n        if (root.val == val1) foundP = true;\n        if (root.val == val2) foundQ = true;\n        return root;\n    }\n\n    return left != null ? left : right;\n}\n```\n\n\n\n### 235 二叉搜索树的最近公共祖先\n\n见7-b28\n\n\n\n```\n\n```\n\n\n\n\n\n### 1650 二叉树的最近公共祖先 III\n\n带父节点的二叉树\n\n将root看成next，就是相交链表的问题\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/02/27/111705167746782516774678255115BRRu5-640.png\" alt=\"图片\" style=\"zoom:50%;\" />\n\n```java\nNode lowestCommonAncestor(Node p, Node q) {\n    // 施展链表双指针技巧\n    Node a = p, b = q;\n    while (a != b) {\n        // a 走一步，如果走到根节点，转到 q 节点\n        if (a == null) a = q;\n        else           a = a.parent;\n        // b 走一步，如果走到根节点，转到 p 节点\n        if (b == null) b = p;\n        else           b = b.parent;\n    }\n    return a;\n}\n```\n\n方式二\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) {\n            return null;\n        }\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while(a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"02-b28 235. 二叉搜索树的最近公共祖先.md","path":"002-数据结构与算法/008-二叉树/01-公共祖先问题/02-b28 235. 二叉搜索树的最近公共祖先.md","content":"### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n思路：\n\n利用二叉搜索树性质，在二叉树的最近公共祖先的基础上剪枝，不需要遍历整颗树。\n\n-   当 root > p && root > q时，解在左子树\n-   当root < p && root < q时，解在右子树\n\n![image-20221019105429448](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/19/105429166614806916661480695639EIibL-image-20221019105429448.png)\n\n以0，5为例，都小于6，则在左子树求解，然后遍历以2为根的树进一步求解（后续情况就跟普通二叉树一样，此处可优化）\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null) return null;\n        if(root == p || root == q) return root;\n\n        if(root.val > p.val && root.val > q.val) {\t// 剪枝，解在左子树\n            return lowestCommonAncestor(root.left, p, q);\n        }\n\n        if(root.val < p.val && root.val < q.val) {\t// 剪枝，解在右子树\n            return lowestCommonAncestor(root.right, p, q);\n        }\n\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\t\t// 此处可优化\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n        if(left != null && right != null ) {    \n            return root;\n        }\n        if(left != null && right == null) {\n            return left;\n        }\n        if(left == null && right != null) {\n            return right;\n        }\n\n        return null;\n    }\n}\n```\n\n优化： 找到答案提前返回，少遍历半边树\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null) return null;\n        if(root == p || root == q) return root;\n\n        if(root.val > p.val && root.val > q.val) {\n             TreeNode left =  lowestCommonAncestor(root.left, p, q);\n             if(left != null) return left;\n        }\n\n        if(root.val < p.val && root.val < q.val) {\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\n            if(right != null) return right;\n        }\n\n      \t// 一个大于root，一个小于root，那么root就是最近公共祖先\n        return root;\n    }\n}\n```\n\n**疑问**\n\n因为是有序树，所有 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在p, q区间的.\n\n那么只要从上到下去遍历，遇到 cur节点（第一个节点是5）是数值在[p, q]区间中则一定可以说明该节点cur就是q 和 p的公共祖先。 \n\n那问题来了，**一定是最近公共祖先吗**？\n\n**答**\n\n以1 和 9 为例，我们从根节点搜索，第一次遇到 cur节点是数值在[p, q]区间中，即 节点5，此时可以说明 p 和 q 一定分别存在于 节点 5的左子树，和右子树中。此时节点5是不是最近公共祖先？ 如果 以5继续向下遍历，（即采用普通二叉树找最近公共祖先的方法遍历），左和右都会分别找到节点，即5一定是1 和 9 的最近公共祖先\n\n![image-20221019110915902](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/19/11091616661489561666148956018S9OSeB-image-20221019110915902.png)\n\n[参考](https://programmercarl.com/0235.二叉搜索树的最近公共祖先.html#递归法)\n\n\n\n#### 写法2\n\nhttps://mp.weixin.qq.com/s/njl6nuid0aalZdH5tuDpqQ\n\n```java\nTreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    // 保证 val1 较小，val2 较大\n    int val1 = Math.min(p.val, q.val);\n    int val2 = Math.max(p.val, q.val);\n    return find(root, val1, val2);\n}\n\n// 在 BST 中寻找 val1 和 val2 的最近公共祖先节点\nTreeNode find(TreeNode root, int val1, int val2) {\n    if (root == null) {\n        return null;\n    }\n    if (root.val > val2) {\t// 大于val2一定大于val1\n        // 当前节点太大，去左子树找\n        return find(root.left, val1, val2);\n    }\n    if (root.val < val1) {\n        // 当前节点太小，去右子树找\n        return find(root.right, val1, val2);\n    }\n    // val1 <= root.val <= val2\n    // 则当前节点就是最近公共祖先, 解释见上方\n    return root;\n}\n```\n\n\n\n#### 方法二：迭代\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        while(root != null) {\n            if(root.val > p.val && root.val > q.val) {\n                root = root.left;\n            } else if(root.val < p.val && root.val < q.val) {\n                root = root.right;\n            } else {\n                return root;\n            }\n        }\n\n        return null;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"01-概述.md","path":"002-数据结构与算法/009-排序算法/01-归并排序及应用/01-概述.md","content":"https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/gui-bing-p-1387f/","timestamp":1692285118436},{"name":"02-912. 排序数组.md","path":"002-数据结构与算法/009-排序算法/01-归并排序及应用/02-912. 排序数组.md","content":"### [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)\n\n归并排序：先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并。\n\n```java\nclass Solution {\n    int[] tmp;\n    public int[] sortArray(int[] nums) {\n        tmp = new int[nums.length];\n        sort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void sort(int[] nums, int l, int r) {\n        if(l == r) return;\n        int mid = l + (r - l) / 2;\n        sort(nums, l, mid);\n        sort(nums, mid + 1, r);\n        merge(nums, l, mid, r);\n    }\n\n    public void merge(int[] nums, int l, int mid, int r) {\n        for(int i = l; i <= r; i++) {\n            tmp[i] = nums[i];\n        }\n\n        int p1 = l;\n        int p2 = mid + 1;\n        int index = l;\n        while(p1 <= mid && p2 <= r) {\n            if(tmp[p1] < tmp[p2]) nums[index++] = tmp[p1++];\n            else nums[index++] = tmp[p2++];\n        }\n        while(p1 <= mid) nums[index++] = tmp[p1++];\n        while(p2 <= r) nums[index++] = tmp[p2++];\n\n    }\n}\n```\n\n\n\n","timestamp":1692285118436},{"name":"03-剑指 Offer 51. 数组中的逆序对.md","path":"002-数据结构与算法/009-排序算法/01-归并排序及应用/03-剑指 Offer 51. 数组中的逆序对.md","content":"### [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)\n\n```\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\n\n输入: [7,5,6,4]\n输出: 5\n```\n\n\n\n解法同：[315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)\n\n写法1\n\n```java\nclass Solution {\n    int res = 0;\n\n    public int reversePairs(int[] nums) {\n        sort(nums, 0, nums.length - 1);\n        // System.out.println(Arrays.toString(nums));\n        return res;\n    }\n\n    public void sort(int[] nums, int l, int r) {\n        if(l >= r) return;\n        int mid = l + ((r - l) >> 1);\n        sort(nums, l, mid);\n        sort(nums, mid + 1, r);\n        merge(nums, l, mid, r);\n    }\n\n    public void merge(int[] nums, int l, int mid, int r) {\n        int[] tmp = new int[nums.length];\n        for(int i = l; i <= r; i++) tmp[i] = nums[i];\n\n        int p1 = l, p2 = mid + 1;\n        int index = l;\n        while(p1 <= mid && p2 <= r) {\n            if(tmp[p1] <= tmp[p2]) {\n                nums[index++] = tmp[p1++];\n                res += p2 - (mid + 1);\n            } else {\n                nums[index++] = tmp[p2++];\n            }\n        }\n\n        while(p1 <= mid) {\n            nums[index++] = tmp[p1++];\n            res += p2 - (mid + 1);\n        }\n        while(p2 <= r) nums[index++] = tmp[p2++];\n    }\n}\n```\n\n写法2\n\n```java\nclass Solution {\n    int res = 0;\n    int[] tmp;\n    public int reversePairs(int[] nums) {\n        tmp = new int[nums.length];\n        sort(nums, 0, nums.length - 1);\n        // System.out.println(Arrays.toString(nums));\n        return res;\n    }\n\n    public void sort(int[] nums, int l, int r) {\n        if(l >= r) return;\n        int mid = l + ((r - l) >> 1);\n        sort(nums, l, mid);\n        sort(nums, mid + 1, r);\n        merge(nums, l, mid, r);\n    }\n\n    public void merge(int[] nums, int l, int mid, int r) {\n        for(int i = l; i <= r; i++) tmp[i] = nums[i];\n\n        int p1 = l, p2 = mid + 1;\n        for(; p1 <= mid; p1++) {\n            while(p2 <= r && nums[p1] > nums[p2]) p2++;\n            res += p2 - (mid + 1);\n        }\n\n        p1 = l;\n        p2 = mid + 1;\n        for(int index = l; index <= r; index++) {\n            if(p1 == mid + 1) {  // 左边遍历完\n                nums[index] = tmp[p2++];\n            } else if(p2 == r + 1) {     // 右边遍历完\n                nums[index] = tmp[p1++];\n            } else if(tmp[p1] <= tmp[p2]) {\n                nums[index] = tmp[p1++];\n            } else {\n                nums[index] = tmp[p2++];\n            }\n        }\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"02-912. 排序数组.md","path":"002-数据结构与算法/009-排序算法/02-快排及应用/02-912. 排序数组.md","content":"#### [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)\n\n取随机数作为partition中的pivot\n\n```java\nimport java.util.Random;\n\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        quickSort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void quickSort(int[] nums, int l, int r) {\n        if (l >= r) return;\n        int pivot = partition(nums, l, r);\n        quickSort(nums, l, pivot - 1);\n        quickSort(nums, pivot + 1, r);\n    }\n\n    public int partition(int[] nums, int l, int r) {\n        int randomIndex = new Random().nextInt(r - l + 1) + l;\n        swap(nums, l, randomIndex); // 将随机选取的数交换到首位，作为pivot\n        int pivot = nums[l];\n      \n        int i = l, j = r;\n        while (i < j) {\n            while (j > i && nums[j] >= pivot) j--;\n            nums[i] = nums[j];\n\n            while (i < j && nums[i] <= pivot) i++;\n            nums[j] = nums[i];\n        }\n        nums[i] = pivot;\n\n        return i;\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n\n```\n\n","timestamp":1692285118436},{"name":"03-剑指 Offer 45. 把数组排成最小的数.md","path":"002-数据结构与算法/009-排序算法/02-快排及应用/03-剑指 Offer 45. 把数组排成最小的数.md","content":"### [剑指 Offer 45. 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)\n\n```\n输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n输入: [3,30,34,5,9]\n输出: \"3033459\"\n```\n\n使用Arrays.sort算法\n\n```java\nclass Solution {\n    public String minNumber(int[] nums) {\n        String[] strs = new String[nums.length];\n        for(int i = 0; i < nums.length; i++) {\n            strs[i] = Integer.toString(nums[i]);\n        }\n\n        Arrays.sort(strs, (a, b)->{\n            return (a + b).compareTo(b + a);\n        });\n\n        return String.join(\"\", strs);\n    }\n}\n```\n\n快排\n\n```java\nclass Solution {\n    public String minNumber(int[] nums) {\n        String[] strs = new String[nums.length];\n        for(int i = 0; i < nums.length; i++) {\n            strs[i] = Integer.toString(nums[i]);\n        }\n\n        quickSort(strs, 0, strs.length - 1);\n\n        return String.join(\"\", strs);\n    }\n\n    public void quickSort(String[] strs, int l, int r) {\n        if(l >= r) return;\n        int pivot = paritition(strs, l, r);\n        quickSort(strs, l, pivot - 1);\n        quickSort(strs, pivot + 1, r);\n    }\n\n    public int paritition(String[] strs, int l, int r) {\n        int index = new Random().nextInt(r - l + 1) + l;\n        swap(strs, l, index);\n\n        String pivot = strs[l];\n        while(l < r) {\n            while(l < r && (strs[r] + pivot).compareTo(pivot + strs[r]) >= 0) r--;\n            strs[l] = strs[r];\n\n            while(l < r && (strs[l] + pivot).compareTo(pivot + strs[l]) <= 0) l++;\n            strs[r] = strs[l];\n        }\n        strs[l] = pivot;\n\n        return l;\n    }\n\n    public void swap(String[] strs, int i, int j) {\n        String tmp = strs[i];\n        strs[i] = strs[j];\n        strs[j] = tmp;\n    }\n}\n```\n\n[参考](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/)","timestamp":1692285118436},{"name":"04-剑指 Offer 40. 最小的k个数.md","path":"002-数据结构与算法/009-排序算法/02-快排及应用/04-剑指 Offer 40. 最小的k个数.md","content":"### [剑指 Offer 40. 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)\n\n```\n输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n```\n#### 方法1: 排序\n\n```java\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n        int[] res = new int[k];\n        Arrays.sort(arr);\n        for(int i = 0; i < k; i++) {\n            res[i] = arr[i];\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n#### 方法2: 大根堆\n\n```java\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->{\n            return b - a;\n        });\n\n        for(int i = 0; i < arr.length; i++) {\n            pq.add(arr[i]);\n            if(pq.size() > k) {\n                pq.poll();\n            }\n        }\n\n\n        int[] res = new int[k];\n        for(int i = 0; i < k; i++) {\n            res[i] = pq.poll();\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n#### 方法3: 快排\n\n```java\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n        if(k >= arr.length) return arr;\n        return quickSort(arr, 0, arr.length - 1, k);\n    }\n\n    public int[] quickSort(int[] nums, int l, int r, int k) {\n        int pivot = partition(nums, l, r);\n        if(pivot > k) return quickSort(nums, l, r - 1, k);\n        if(pivot < k) return quickSort(nums, l + 1, r, k);\n        return Arrays.copyOf(nums, k);\n    }\n\n    public int partition(int[] nums, int l, int r) {\n        int index = new Random().nextInt(r - l + 1) + l;\n        int pivot = nums[index];\n        swap(nums, index, l);\n\n        int i = l, j = r;\n        while(i < j) {\n            while(i < j && nums[j] >= pivot) j--;\n            nums[i] = nums[j];\n\n            while(i < j && nums[i] <= pivot) i++;\n            nums[j] = nums[i];\n        }\n        nums[i] = pivot;\n\n        return i;\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"03-排序算法.md","path":"002-数据结构与算法/009-排序算法/03-排序算法.md","content":"https://leetcode.cn/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/","timestamp":1692285118436},{"name":"01-22. 括号生成.md","path":"002-数据结构与算法/100-hot100/02-回溯/01-22. 括号生成.md","content":"### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)\n\n#### 方法一： dfs\n\n```java\nclass Solution {\n\n    List<String> res = new ArrayList<>();\n\n    public List<String> generateParenthesis(int n) {\n        dfs(\"\", n, n);\n        return res;\n    }\n\n    // l: 可使用的(数  r: 可使用的)数\n    public void dfs(String str, int l, int r) {\n        if(l == 0 && r == 0) {\n            res.add(str);\n            return;\n        }\n\n        if(l < 0 || r < l) return;\t\t// r < l 说明出现了 ())类似情况\n\n        dfs(str + \"(\", l - 1, r);\n        dfs(str + \")\", l, r - 1);\n\n    }\n}\n```\n\n#### 方法二： 回溯法\n\n```java\nclass Solution {\n\n    List<String> res = new ArrayList<>();\n\n    public List<String> generateParenthesis(int n) {\n        backtrack(new StringBuilder(), 0, 0, n);\n        return res;\n    }\n\n    // l: 已用的(数  r: 已用的)数\n    public void backtrack(StringBuilder sb, int l, int r, int n) {\n        if(sb.length() == n * 2) {\n            res.add(sb.toString());\n            return;\n        }\n\n        if(l < n) {\n            sb.append(\"(\");\n            backtrack(sb, l + 1, r, n);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n\n        if(r < l) {\n            sb.append(\")\");\n            backtrack(sb, l, r + 1, n);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"02-79. 单词搜索.md","path":"002-数据结构与算法/100-hot100/02-回溯/02-79. 单词搜索.md","content":"### [79. 单词搜索](https://leetcode.cn/problems/word-search/)\n\n![image-20230602131905020](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/02/13190516856831451685683145196AAhj0z-image-20230602131905020.png)\n\n#### 方法1: 回溯\n\n```java\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        int h = board.length, w = board[0].length;\n        boolean[][] visited = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                boolean flag = check(board, visited, i, j, word, 0);\n                if (flag) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) {\n        if (board[i][j] != s.charAt(k)) {\n            return false;\n        } else if (k == s.length() - 1) {\n            return true;\n        }\n        visited[i][j] = true;\n        int[][] directions = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };\n        boolean result = false;\n        for (int[] dir : directions) {\n            int newi = i + dir[0], newj = j + dir[1];\n            if (newi >= 0 && newi < board.length && newj >= 0 && newj < board[0].length) {\n                if (!visited[newi][newj]) {\n                    boolean flag = check(board, visited, newi, newj, s, k + 1);\n                    if (flag) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n        visited[i][j] = false;\n        return result;\n    }\n}\n\n作者：LeetCode-Solution\n链接：https://leetcode.cn/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n优化：\n\n-   直接在原数组上修改，无须visited数组\n\n-   先污染，后治理\n\n```java\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[0].length; j++) {\n                if(board[i][j] == word.charAt(0)) {\n                    boolean flag = dfs(board, word, 0, i, j);\n                    if(flag) return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public boolean dfs(char[][] board, String word, int index, int r, int c) {\n        if(index == word.length()) return true;\n        if(r < 0 || r >= board.length || c < 0 || c >= board[0].length) return false;\n        if(board[r][c] != word.charAt(index)) return false;\n\n        char ch = board[r][c];  \n        board[r][c] = 0;    // 防止重复遍历走回头路\n\n        // 先污染，后治理，在下一层判断是否越界\n        boolean res = dfs(board, word, index + 1, r - 1, c)\n                   || dfs(board, word, index + 1, r + 1, c)\n                   || dfs(board, word, index + 1, r, c - 1)\n                   || dfs(board, word, index + 1, r, c + 1);\n\n        // 回溯\n        board[r][c] = ch;\n\n        return res;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"01-32. 最长有效括号.md","path":"002-数据结构与算法/100-hot100/03-动态规划/01-32. 最长有效括号.md","content":"### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)\n\n```\n给你一个只包含 \'(\' 和 \')\' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n\n输入：s = \"(()\"\n输出：2\n解释：最长有效括号子串是 \"()\"\n```\n\n#### 方法1: dp\n\ndp含义\n\n```\ndp[i]: 以i为结尾的，最长有效括号数\n```\n\n递推公式\n\n```\n情况1\n...()\n省略号的长度为dp[i - 2], 即dp[i] = dp[i - 2] + 2\ni - 2  < 0时 dp[i] = 2\n\n情况2\n...((...))\n难点：如何找到中间部分的左括号\n中间有效括号长度：dp[i - 1]\n中间有效括号左边界: leftIndex = i - dp[i - 1] - 1\ns[i]需要和 s[leftIndex - 1] 匹配\n\ndp[i] = 中间长度 + 2 + 左边省略号长度\n\t\t  = 匹配的()长度 + 左边省略号长度\n\t\t  = (i - leftIndex + 1) + dp[leftIndex - 2]\n```\n\n```java\n    public int longestValidParentheses(String s) {\n        int n = s.length();\n        if(n == 0) return 0;\n\n        int[] dp = new int[n];\n        dp[0] = 0;\n\n        int res = 0;\n        for(int i = 1; i < n; i++) {\n            if(s.charAt(i) == \')\') {\n                if(s.charAt(i - 1) == \'(\') {\n                    if(i - 2 <= 0) {\n                        dp[i] = 2;\n                    } else {\n                        dp[i] = dp[i - 2] + 2;\n                    }\n                     \n                } else if(dp[i - 1] > 0) {\n                    if(i - dp[i - 1] - 1 >= 0 && s.charAt(i - dp[i - 1] - 1) == \'(\') {\n                        dp[i] = i - (i - dp[i - 1] - 1) + 1;\n                        if(i - dp[i - 1] - 2 >= 0) {\n                            dp[i] += dp[i - dp[i - 1] - 2];\n                        }\n                    }\n                }\n     \n                res = Math.max(res, dp[i]);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n>   参考：https://leetcode.cn/problems/longest-valid-parentheses/solution/dong-tai-gui-hua-si-lu-xiang-jie-c-by-zhanganan042/\n\n\n\n#### 方法2: dp + 栈\n\n用栈简化了找左括号的过程\n\n```java\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Deque<Integer> stack = new LinkedList<>();\n        int n = s.length();\n        int[] dp = new int[n + 1]; // dp[i] 表示以i-1为结尾的最长有效数\n        int res = 0;\n        for(int i = 0; i < n; i++) {\n            char ch = s.charAt(i);\n            if(ch == \'(\') {\n                stack.push(i);  // 记录(的下标\n                dp[i + 1] = 0;  // 以(为结尾，一定不是有效的\n            } else {\n                if(!stack.isEmpty()) {\n                    int left = stack.pop();\n                    int len = (i - left + 1) + dp[left];    // dp[left]表示left-1为结尾的最长有效数\n                    res = Math.max(len, res);\n                    dp[i + 1] = len;\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n>   参考： https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-jie--306f6\n\n","timestamp":1692285118436},{"name":"04-31. 下一个排列.md","path":"002-数据结构与算法/100-hot100/04-31. 下一个排列.md","content":"### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)\n\n```java\n123456\n123465\n123546\n...\n654321\n\nclass Solution {\n    // 12345 12354 12435 12453\n    public void nextPermutation(int[] nums) {\n        // 从后向前，找第一个[i, j]，其中nums[i] < nums[j]\n        int n = nums.length;\n        int i = n - 2;\n        int j = n - 1;\n        while(i >= 0 && nums[i] >= nums[j]) {\n            i--;\n            j--;\n        }\n\n        // 从后向前，找第一个比nums[i]大的，交换\n        if(i >= 0) {    // 不是最后一个排列, 即321已经没有比它大的了\n            int k = n - 1;\n            while(k >= j && nums[k] <= nums[i]) {\n                k--;\n            }\n            swap(nums, i, k);\n        }\n        \n        // 将[j, n - 1]逆序\n        while(j < n - 1) {\n            swap(nums, j, n - 1);\n            j++; \n            n--;\n        }\n\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n\n参考：https://leetcode.cn/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/","timestamp":1692285118436},{"name":"05-49. 字母异位词分组.md","path":"002-数据结构与算法/100-hot100/05-49. 字母异位词分组.md","content":"","timestamp":1692285118436},{"name":"01-921. 使括号有效的最少添加.md","path":"002-数据结构与算法/101-其他题型/01-括号问题/01-921. 使括号有效的最少添加.md","content":"### [921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)\n\n求填补最少的括号数量，使其有效\n\n```\n输入：s = \"())\"\n输出：1\n```\n\n```java\nclass Solution {\n    public int minAddToMakeValid(String s) {\n        int res = 0;\n        int need = 0;   // 需要的右括号数\n        for(int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if(ch == \'(\') {\n                need ++;\n            } else {\n                need--;\n\n                if(need < 0) {  // 需要补左括号 ()))\n                    res++;\n                    need = 0;\n                }\n            }\n        }\n\n        return res + need;\n    }\n}\n```\n\n**当 `need == -1` 的时候意味着什么**？\n\n```\n因为只有遇到右括号 ) 的时候才会 need--，need == -1 意味着右括号太多了，所以需要插入左括号。\n比如说 s = \"))\" 这种情况，需要插入 2 个左括号，使得 s 变成 \"()()\"，才是一个有效括号串。\n```\n\n**算法为什么返回 `res + need`**？\n\n```\n因为 res 记录的左括号的插入次数，need 记录了右括号的需求，当 for 循环结束后，若 need 不为 0，那么就意味着右括号还不够，需要插入。\n比如说 s = \"))(\" 这种情况，插入 2 个左括号之后，还要再插入 1 个右括号，使得 s 变成 \"()()()\"，才是一个有效括号串。\n```\n\n[参考](https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-jie--306f6/)","timestamp":1692285118436},{"name":"02-1541. 平衡括号字符串的最少插入次数.md","path":"002-数据结构与算法/101-其他题型/01-括号问题/02-1541. 平衡括号字符串的最少插入次数.md","content":"### [1541. 平衡括号字符串的最少插入次数](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/)\n\n```\n一个\'(\'对应两个\')\', 求最少数量使括号有效\n```\n\n```java\nclass Solution {\n    public int minInsertions(String s) {\n        int res = 0;\n        int need = 0;\n        for(int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if(ch == \'(\') {\n                need += 2;\n\n                if(need % 2 == 1) { // 需要补右括号：()( => ())(\n                    res++;\n                    need--;\n                }\n            } else {  \n                need--;\n\n                if(need == -1) {    // ())) ，需要补左括号，同时还需要一个右括号\n                    res++;\n                    need = 1;\n                }\n            }\n        }\n        \n        return res + need;\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"03-32. 最长有效括号.md","path":"002-数据结构与算法/101-其他题型/01-括号问题/03-32. 最长有效括号.md","content":"### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)\n\n```\n给你一个只包含 \'(\' 和 \')\' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n\n输入：s = \"(()\"\n输出：2\n解释：最长有效括号子串是 \"()\"\n```\n\n参考dp","timestamp":1692285118436},{"name":"04-20. 有效的括号.md","path":"002-数据结构与算法/101-其他题型/01-括号问题/04-20. 有效的括号.md","content":"### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)","timestamp":1692285118436},{"name":"01-理论.md","path":"002-数据结构与算法/101-其他题型/02-丑数问题/01-理论.md","content":"参考：https://mp.weixin.qq.com/s/XXsWwDml_zHiTEFPZtbe3g","timestamp":1692285118436},{"name":"02-263. 丑数.md","path":"002-数据结构与算法/101-其他题型/02-丑数问题/02-263. 丑数.md","content":"### [263. 丑数](https://leetcode.cn/problems/ugly-number/)\n\n```java\nclass Solution {\n    public boolean isUgly(int n) {\n        if(n <= 0) return false;\n        while(n % 2 == 0) n /= 2;\n        while(n % 3 == 0) n /= 3;\n        while(n % 5 == 0) n /= 5;\n\n        return n == 1;\n    }\n}\n```\n\n参考：https://mp.weixin.qq.com/s/XXsWwDml_zHiTEFPZtbe3g","timestamp":1692285118436},{"name":"03-264. 丑数 II.md","path":"002-数据结构与算法/101-其他题型/02-丑数问题/03-264. 丑数 II.md","content":"### [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)\n\n### [剑指 Offer 49. 丑数](https://leetcode.cn/problems/chou-shu-lcof/)\n\n我们可以把丑数分为三类：2 的倍数、3 的倍数、5 的倍数。这三类丑数就好像三条有序链表，如下：\n\n(注意是没有7x2、7x3、7x5的，7不是丑数，所以每条链上并不是简单的每次都乘2、3、5，丑数 III才是)\n\n```\n能被 2 整除的丑数：\n1*2 -> 2*2 -> 3*2 -> 4*2 -> 5*2 -> 6*2 -> 8*2 ->...\n能被 3 整除的丑数：\n1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 8*3 ->...\n能被 5 整除的丑数：\n1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 8*5 ->...\n```\n\n我们如果把这三条「有序链表」合并在一起并去重，得到的就是丑数的序列，其中第`n`个元素就是题目想要的答案：\n\n```\n1 -> 1*2 -> 1*3 -> 2*2 -> 1*5 -> 3*2 -> 4*2 ->...\n```\n\n\n\n```java\nclass Solution {\n    // 理解为三个有序链表合并\n    public int nthUglyNumber(int n) {\n        int p2 = 1, p3 = 1, p5 = 1;     // 理解为三个链表头指针\n        int v2 = 1, v3 = 1, v5 = 1;     // 三个链表对应值\n\n        int[] ugly = new int[n + 1];    // 理解为合并的链表\n        int p = 1;                      // 合并链表指针\n\n        // 合并链表\n        while(p <= n) {\n            int min = Math.min(v2, Math.min(v3, v5));\n            ugly[p] = min;\n            p++;\n\n            // 前进对应有序链表上的指针\n            if(min == v2) {             // 链表2的节点为1 2 4 8 ...\n                v2 = 2 * ugly[p2];\n                p2++;\n            }\n\n            if(min == v3) {             // 链表3的节点为1 3 6 9 ...\n                v3 = 3 * ugly[p3];\n                p3++;\n            }\n\n            if(min == v5) {             // 链表5的节点为1 5 10 15 ...\n                v5 = 5 * ugly[p5];\n                p5++;\n            }\n        }\n\n        return ugly[n];\n    }\n}\n```","timestamp":1692285118436},{"name":"04-313. 超级丑数.md","path":"002-数据结构与算法/101-其他题型/02-丑数问题/04-313. 超级丑数.md","content":"### [313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/)\n\n理解为合并n个链表\n\n```java\nclass Solution {\n    // 当primes为[2,3,5]时同T264.丑数\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        // 优先队列中装三元组 int[] {value, prime, pi}\n        // 其中 value 代表链表节点的值，prime 是计算下一个节点所需的质数因子，pi 代表链表上的指针\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->{\n            // 优先级队列按照节点的值排序\n            return a[0] - b[0];\n        });\n\n        // 把多条链表的头结点加入优先级队列\n        for(int i = 0; i < primes.length; i++) {\n            pq.offer(new int[]{1, primes[i], 1});\n        }\n\n         // 可以理解为最终合并的有序链表（结果链表）\n        int[] ugly = new int[n + 1];\n        int p = 1;  //  可以理解为结果链表上的指针\n\n        while(p <= n) {\n            // 取三个链表的最小结点\n            int[] pair = pq.poll();\n            int value = pair[0];\n            int prime = pair[1];\n            int index = pair[2];\n\n            // 避免结果链表出现重复元素\n            if(value != ugly[p - 1]) {\n                // 接到结果链表上\n                ugly[p] = value;\n                p++;\n            }\n\n            // 生成下一个节点加入优先级队列\n            int[] nextPair = new int[]{ ugly[index] * prime, prime, index+1 };\n            pq.offer(nextPair);\n        }\n\n        return ugly[n];\n    }\n}\n```\n\n","timestamp":1692285118436},{"name":"05-1201. 丑数 III.md","path":"002-数据结构与算法/101-其他题型/02-丑数问题/05-1201. 丑数 III.md","content":"### [1201. 丑数 III](https://leetcode.cn/problems/ugly-number-iii/)\n\n```\n给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。\n\n丑数是可以被 a 或 b 或 c 整除的 正整数 。\n```\n\n```\n1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 7*3 ->...\n1*4 -> 2*4 -> 3*4 -> 4*4 -> 5*4 -> 6*4 -> 7*4 ->...\n1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 7*5 ->...\n\n合并为\n1*3 -> 1*4 -> 1*5 -> 2*3 -> 2*4 -> 3*3 -> 2*5 ->...\n```\n\n问题：n很大时无法通过用例\n\n```java\nclass Solution {\n    public int nthUglyNumber(int n, int a, int b, int c) {\n        long v1 = a, v2 = b, v3 = c;\n        int p = 1;\n\n        long min = Long.MIN_VALUE;\n        while(p <= n) {\n            min = Math.min(v1, Math.min(v2, v3));\n            p++;\n\n            if(min == v1) {\n                v1 += a;\n            }\n\n            if(min == v2) {\n                v2 += b;\n            }\n\n            if(min == v3) {\n                v3+= c;\n            }\n        }\n\n        return (int)min;\n    }\n}\n```\n\n[参考](https://mp.weixin.qq.com/s/XXsWwDml_zHiTEFPZtbe3g)","timestamp":1692285118436}]