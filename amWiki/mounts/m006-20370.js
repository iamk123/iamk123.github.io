if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m006']=[{"name":"01-基础篇.md","path":"006-MySQL/01-基础篇.md","content":"## 执行一条查询语句流程\n\n![查询语句执行流程](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/08/13522416914739441691473944041VX9yWt-mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)\n\n```\n（1）连接器：简历连接，管理连接、校验用户身份\n（2）查询缓存：如果命中，直接返回（mysql8.0后移除）\n（3）解析器：\n\t\t- 词法分析：提取关键字、表名、字段名、查询条件\n\t\t- 语法分析：判断sql是否正确\n（4）优化器：选择最优的方案执行：如何选择索引？如何关联表的顺序？\n（5）执行器：调用引擎接口，返回结果\n```\n\n## 为什么移除查询缓存？","timestamp":1691669630396},{"name":"02-索引.md","path":"006-MySQL/02-索引.md","content":"## 什么是索引？\n\n```\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n形象的说就是索引是数据的目录。\n```\n\n## 索引的分类\n\n```\n按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。\n按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。\n按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。\n按「字段个数」分类：单列索引、联合索引。\n```\n\n### 按「数据结构」分类\n\n![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/08/13595216914743921691474392492IpVp9e-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png)\n\n\n\n\n\n## 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？\n\n```\nB+树 vs B树\n（1）B+树只在在叶子节点存放数据，B+树在非叶子节点也存放数据，存储相同数据量级别的情况下，B+树比B树低，磁盘IO次数更少\n（2）B+树叶子结点用双向链表连接，适合范围查询，B树不行\n\nB+树 vs 二叉树\n（1）随着数量的增加，二叉树会越来越高，磁盘IO次数也会更多。B+树在千万级别的数据量下，高度依旧维持在3-4层左右，差一次数据只需要3-4次磁盘IO\n\nB+树 vs Hash\n（1）Hash等值查询效率很高，但无法范围查询\n```\n\n","timestamp":1691669630396},{"name":"03-事务.md","path":"006-MySQL/03-事务.md","content":"## 事物有哪些特性 ACID\n\n```\n（1）原子性（Atomicity）：事务是最小的执行单位。一个事务中的所有操作，要么都执行，要么都不执行。发生错误时会进行回滚\n（2）一致性（Consistency：执行事务前后，数据保持一致。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；\n（3）隔离性（Isolation）：并发访问数据库时，一个用户的事务不会被其他事物所干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。\n（4）持久性（Durability）：事务处理结束后，对数据的修改是永久的，即使系统故障也不会丢失。\n```\n\n## InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？\n\n```\n原子性是通过 「undo log（回滚日志）」 来保证的；\n持久性是通过 「redo log （重做日志）」来保证的；\n隔离性是通过 「MVCC（多版本并发控制）」 或「锁机制」来保证的；\n一致性则是通过「持久性」+「原子性」+「隔离性」来保证；\n```\n\n## 并发事务会引发什么问题？\n\n```\n脏读、不可重复读、幻读\n```\n\n### 脏读\n\n```\n一个事务读到其他事务未提交的数据\n```\n\n出现场景\n\n```\n事务A对数据进行修改还未提交，事务B读取这条数据，此时事务A进行了回滚,\n```\n\n### 不可重复读\n\n```\n在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。\n```\n\n出现场景\n\n```\n事务A读取某条数据，此时事务B更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。\n```\n\n### 幻读\n\n```\n一个事务，查询条件相同，先后读取数据的数量不一致\n```\n\n出现场景\n\n```\n事务A读取某个范围内的数据，事务B在这个范围内添加/删除数据，事务A再次读取时，查询的数量会不一致\n```\n\n### 丢失修改\n\n```\n事务A修改某条数据未提交前，事务B也对这条数据进行了修改并提交，此时事务A进行提交，事务A的修改就会丢失。\n```\n\n### 不可重复读和幻读有什么区别？\n\n```\n不可重复读是对某一条数据 多次读取不一致\n幻读是对某一个范围内的数据 多次读取不一致\n\n幻读是不可重复读的一种特殊情况，单独区分是因为解决方法不同。\n```\n\n## 并发事务的控制方式有哪些？ TODO\n\n```\nhttps://javaguide.cn/database/mysql/mysql-questions-01.html#并发事务的控制方式有哪些\n```\n\n\n\n## 事务的隔离级别\n\n### 有哪些？\n\n```\n（1）读未提交：可以读取未提交事务。可能导致脏读、幻读、不可重复读\n（2）读提交：指一个事务提交之后，它做的变更才能被其他事务看到；可能导致幻读、不可重复读\n（3）可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；可能导致幻读 【具体原因见方法】\n（4）串行化：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/100133169154649316915464935760bAug5-4e98ea2e60923b969790898565b4d643.png\" alt=\"图片\" style=\"zoom:50%;\" />\n\n### 可重复读很大程度上解决了幻读问题，是怎么解决的？\n\n```\n（1）针对「快照读」（普通select语句），通过「mvcc」方式解决：\n    事务启动后，会创建一个读取视图（read view），该视图包含了事务开始时数据库中的所有数据。在事务执行期间，其他事务对数据的修改\n是查询不出来的。\n\n（2）针对「当前读」（select...for update等语句），通过「next-key lock(记录锁+间隙锁)」方式解决。\n\t\t因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。\n\n【SELECT ... FOR UPDATE 是一种用于在事务中对数据行进行加锁的语句】\n```\n\n#### 快照读是如何避免幻读的？\n\n```\n实现方式：undo log + mvcc\n\n可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，该视图包含了事务开始时数据库中的所有数据。在事务执行期间，每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。\n```\n\n#### 当前读是如何避免幻读的？\n\n```\n什么是当前读？\nMySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。\n这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。\n\n通过添加next-key lock解决\n```\n\n### MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？\n\n```\n在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。\n\nhttps://xiaolincoding.com/mysql/lock/lock_phantom.html#加锁分析\n```\n\n\n\n### 可重复读中幻读被完全解决了吗？\n\n```\n可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读。\n\nhttps://www.xiaolincoding.com/mysql/transaction/phantom.html\n```\n\n场景1:\n\n```\n事务A查询某个范围内的数据，事务B在这个范围内添加一条数据，此时事务A是看不到的。\n如果事务A去更新这个记录，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/10402916915488291691548829458XOS6lA-%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n场景2\n\n```\nT1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。\nT2 时刻：事务 B 往插入一个 id= 200 的记录并提交；\nT3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。\n\n要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。\n```\n\n### MySQL 的隔离级别是怎么实现的？\n\n```\nMySQL 的隔离级别基于锁和 MVCC 机制共同实现的。\n\n（1）「串行化」 隔离级别是通过锁来实现的，\n（2）「提交读」和 「可重复读」隔离级别是基于 MVCC 实现的。不过， 「串行化」 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。\n\nhttps://javaguide.cn/database/mysql/mysql-questions-01.html#sql-标准定义了哪些事务隔离级别\n```\n\n### 这四种隔离级别具体是如何实现的呢？？？\n\n```\n（1）对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；\n（2）对于「串行化」隔离级别的事务来说，通过加「读写锁」的方式来避免并行访问；\n（3）对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同；\n\t\t- 读提交：在「每个语句执行前」都会重新生成一个 Read View。也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。\n\t\t- 可重复读： 是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。这样就保证了在事务期间读到的数据都是事务启动前的记录。\n```\n\n### 启动事务的方式\n\n```\n两种方式：\n第一种：begin/start transaction 命令：执行后并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；\n第二种：start transaction with consistent snapshot 命令：就会马上启动事务。\n```\n\n## Read View 在 MVCC 里如何工作的？\n\n```\nhttps://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-在-mvcc-里如何工作的\n```\n\n```\nread view有四个重要的字段：\n（1）creator_trx_id: 创建该readview的的事务的事务id\n（2）m_ids: 创建readView时，数据库中「活跃事务」的事务id列表（活跃事务指启动但未提交的事务）\n（3）min_trx_id: m_ids的最小值\n（4）max_trx_id: 创建readView时当前数据库中应该给下一个事务的id值，即m_ids的最大值+1\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/13493616915601761691560176829NlsMaT-readview%E7%BB%93%E6%9E%84.drawio.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n```\n聚簇索引中的两个隐藏列\n（1）trx_id: 当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；\n（2）roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。\n```\n\n```\n一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：\n（1）trx_id < min_trx_id, 则该条记录对当前事务「可见」。表示这个版本的记录是在创建 Read View 前已经提交的事务生成的\n（2）trx_id >= min_trx_id, 则该条记录对当前事务「不可见」\n（3）处于之间，则判断trx_id是否在m_ids里：\t？？？（应该是可重复读 和 读提交会有区别，不在列表中只会在读提交中出现，每次都会创建新的readview）\n\t\t- 在列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务「不可见」。\n\t\t- 不在列表中，则对当前事务「可见」\n\t\t\n这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。\n```\n\n\n\n## 可重复读是如何工作的？\n\n```\nhttps://xiaolincoding.com/mysql/transaction/mvcc.html#可重复读是如何工作的\n```\n\n```\n例子：事务A启动，接着B也跟着启动\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/14125216915615721691561572562VsQsN0-%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n```\n操作流程 & 现象：\n事务 B 读取小林的账户余额记录，读到余额是 100 万；\n事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；\n事务 B 读取小林的账户余额记录，读到余额还是 100 万；\n事务 A 提交事务；\n事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；\n```\n流程分析\n```\n分析，B三次读取时为什么都能读到100:\n（1）第一次：该条记录的trx_id = 50, 小于事务B的活跃事务m_ids，表示在事务启动前就提交，所以该版本记录对B可见\n（2）第二次：\n\t\t- A修改但未提交，mysql会记录相应的undolog，并以链表的形式串联起来，形成「版本链」，然后修改该条记录的trx_id=51。\n\t\t- B此时去读，发现trx_id=51，在自己的活跃事务m_ids里。说明这条记录被修改但未提交。所以不会读取该记录，而是沿着undolog链条找旧版本的记录，找到第一条小于事务B的min_trx_id(即在活跃事务m_ids左侧)，即trx_id=50的记录\n（3）第三次：事务A已经提交，但是事务B用的启动事务时创建的readview，所以修改依旧不可见。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/14171816915618381691561838130jD2AHR-image-20230809141717983.png\" alt=\"image-20230809141717983\" style=\"zoom:50%;\" />\n\n## 读提交是如何工作的？\n\n```\nhttps://xiaolincoding.com/mysql/transaction/mvcc.html#读提交是如何工作的\n```\n\n```\n操作流程 & 现象：\n事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；\n事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；\n事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；\n事务 A 提交事务；\n事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；\n```\n\n流程分析\n\n```\n与「可重复读事务」的区别在第三次：\n「读提交」每次创建时，都会创建一个新的readview，所以事务A提交后，B再去读，会新建一个视图，提交后的数据对B来说是可见的\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/14431816915633981691563398800novU0H-%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A12.drawio.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n","timestamp":1691669630396},{"name":"04-锁.md","path":"006-MySQL/04-锁.md","content":"## **加锁的对象是索引，加锁的基本单位是 next-key lock**MySQL 有哪些锁？\n\n```\n根据加锁的范围, 分为：全局锁、表级锁、行级锁\n```\n\n### 全局锁\n\n#### 如何使用？\n\n```\nflush tables with read lock\t\t// 整个数据库就处于只读状态了。\nunlock tables\t\t// 解锁，当会话断开了，全局锁也会被自动释放。\n```\n\n#### 全局锁应用场景是什么？\n\n```\n全库逻辑备份\n```\n\n#### 加全局锁又会带来什么缺点呢？\n\n```\n数据库都是只读状态，如果数据库里有很多数据，备份就会花费很多的时间。\n关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。\n```\n\n#### 使用全局锁会影响业务，那有什么其他方式可以避免？\n\n```\n如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。\n\nMyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法\n```\n\n### 表级锁\n\n#### MySQL 表级锁有哪些？具体怎么用的。\n\n```\n表锁；\n元数据锁（MDL）;\n意向锁；\nAUTO-INC 锁；\n```\n\n#### 表锁\n\n```\n\n```\n\n#### 元数据锁（MDL）\n\n```\n\n```\n\n#### 意向锁\n\n```\n意向锁快速判断是否可以对某个表使用表锁，而不用逐行遍历\n\n意向锁是表级锁，共有两种\n（1）意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。\n（2）意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。\n```\n\n意向锁之间是互相兼容的。\n\n|       | IS 锁 | IX 锁 |\n| ----- | ----- | ----- |\n| IS 锁 | 兼容  | 兼容  |\n| IX 锁 | 兼容  | 兼容  |\n\n「意向锁」和「共享锁、排它锁」互斥（这里指的是表级别的共享锁和排他锁，不会与行级的共享锁和排他锁互斥）。\n\n|      | IS 锁 | IX 锁 |\n| ---- | ----- | ----- |\n| S 锁 | 兼容  | 互斥  |\n| X 锁 | 互斥  | 互斥  |\n\n####  自增锁（AUTO-INC锁）\n\n```\n一个事务插入的数据中有自增列表时，就会获取自增锁，获取不到就阻塞，等待插入语句执行完后才释放锁，以保证插入数据时是连续递增的。\n大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。\n\n优化：\nMySQL 5.1.22，InnoDB 存储引擎提供了一种「轻量级的锁」来实现自增。\n插入的数据中有自增列表时，就会获取轻量级的锁，给该字段赋值完后就会释放\n```\n\n### 行级锁\n\n#### 行级锁有哪些种类？\n\n```\n不同隔离级别下，行级锁的种类是不同的。\n（1）读提交：记录锁\n（2）可重复读：\n\t\t- 记录锁 Record Lock：\n\t\t- 间隙锁 Gap Lock：\n\t\t- 临键锁 Next-Key Lock：\n\t\n```\n\n\n\n#### Record Lock\n\n```\n记录锁，锁住的是一条记录。\n\n记录锁是有 S 锁和 X 锁之分的：\n- 一个事务对一条记录加了S锁，其他事务可以加S锁，但不能加X锁\n- 一个事务对一条记录加了X锁, 其他事务既不能加S锁，也不能加X锁\n\n事务commit后，锁释放\n```\n\n#### Gap Lock\n\n```\n间隙锁，锁定一个范围，不包括记录本身。\n只存在于「可重复读隔离级别」，目的是为了解决可重复读隔离级别下幻读的现象。\n\n如表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。\n\n间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。\n```\n\n#### Next-Key Lock\n\n```\n临键锁，是「记录锁」+「间隙锁」的组合，锁定一个范围，并且锁定记录本身。\n\n表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。\n\n如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。\n```\n\n#### 插入意向锁\n\n```\n\n```\n\n## 表级锁和行级锁了解吗？有什么区别？\n\n```\n（1）表级锁：\n\t\t粒度比较大的锁，它锁定整个表，当一个事务获得了某个表的锁后，其他事务就不能对该表进行任务操作。所以，并发效率极低，锁冲突概率也很高\n（2）行级锁：\n\t\t粒度较小，只会锁定特定行（一行或多行），其他事务可以操作其他行。所以并发性相对较高，可能会出现死锁\n```\n\n## 共享锁和排他锁\n\n```\n不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）\n\n（1）共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。\n（2）排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）\n\n```\n\n## 当前读和快照读有什么区别？\n\n当前读：\n\n```\n读取最新版本数据，并对读取的记录加锁，阻塞其他事务同时改动相同记录，避免出现安全问题。\n\nselect...lock in share mode (共享读锁)\nselect...for update\nupdate , delete , insert\n```\n\n快照读\n\n```\n\n```\n\n## MySQL 是怎么加锁的？\n\n### 什么 SQL 语句会加行级锁？\n\n```\nInnoDB 引擎是支持行级锁的， MyISAM 引擎并不支持行级锁\n\n（1）普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。\n（2）可以用「锁定读」在查询时对记录加行级锁\n\n  // 对读取的记录加共享锁(S型锁)\n  select ... lock in share mode;\n  //对读取的记录加独占锁(X型锁)\n  select ... for update;\n  \n（3）update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/10231716916341971691634197297eYLxWQ-x%E9%94%81%E5%92%8Cs%E9%94%81.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n## MySQL 是怎么加行级锁的？TODO\n\n```\n不同的场景，加锁的形式是不同的\n加锁的对象是索引，加锁的基本单位是 next-key lock，在能使用「记录锁」或者「间隙锁」就能避免幻读现象的场景下， next-key lock 就会退化成「记录锁」或「间隙锁」。\n\nhttps://xiaolincoding.com/mysql/lock/how_to_lock.html#mysql-是怎么加行级锁的\n```\n\n### 唯一索引等值查询\n\n```\n（1）当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。\n（2）当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」\n```\n\n### 唯一索引范围查询\n\n```\n\n```\n\n## update 没加索引会锁全表？\n\n```\n(不带索引就是全表扫扫描，也就是表里的索引项都加锁，相当于锁了整张表，并不是表锁)\n\n在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁\n\n比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁（锁是加在索引上）。\nupdate socre = 100 where id = 1\n\n但是，在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。只能用select ... from\nupdate socre = 100 where name = \"xxx\"\n```\n\n\n\n\n\n## MySQL 死锁了，怎么办？TODO\n\n```\nhttps://xiaolincoding.com/mysql/lock/deadlock.html#死锁的发生\n```\n\n### 死锁的发生\n\n```\n事务A，需要插入订单1007\n事务B，需要插入订单1008\n插入前两个事务都进行了「当前读」操作，判断订单是否存在\n\n\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/14032516916474051691647405423hZW5el-90c1e01d0345de639e3426cea0390e80.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n## 加了什么锁，导致死锁的？TODO\n\n```\nhttps://xiaolincoding.com/mysql/lock/show_lock.html\n```\n\n","timestamp":1691669630396},{"name":"05-日志.md","path":"006-MySQL/05-日志.md","content":"\n\n## undo log（回滚日志）\n\n### 是什么\n\n```\nundo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。\n```\n\n### undo log 作用\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/1428331691648913169164891359542tTLG-%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png\" alt=\"回滚事务\" style=\"zoom:50%;\" />\n\n```\n（1）实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。\n（2）实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。\n```\n\n\n\n## Buffer Pool\n\n###  为什么需要 Buffer Pool？\n\n```\nInnodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。\n\n（1）当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。\n（2）当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。\n```\n\n### Buffer Pool 缓存什么？\n\n```\nInnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。\n\nBuffer Pool 除了缓存「索引页」和「数据页」，还包括了 「Undo 页」，「插入缓存」、「自适应哈希索引」、「锁信息」等等。\n\nhttps://xiaolincoding.com/mysql/log/how_update.html#buffer-pool-缓存什么\n```\n\n### Undo 页是记录什么？\n\n```\n开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。\n```\n\n### undo log 是如何刷盘（持久化到磁盘）的\n\n```\nundo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。\n\nbuffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。\n```\n\n\n\n\n\n## redo log（重做日志）\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/16544916916576891691657689548nkulq9-wal.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n### 什么是 redo log？\n\n```\nredo log（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力。\nMySQL 实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性与完整性。\n\n为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了。\n```\n\n### 为什么需要redo log？\n\n```\nBuffer Pool提高了读写效率，但是是基于内存的，如果断电重启，还没来得及刷盘的脏页数据就会丢失。\n有了redolog，就会把「在某个数据页上做了什么修改」记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。\n```\n\n### 被修改 Undo 页面，需要记录对应 redo log 吗？\n\n```\n需要的。\n\n开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。\n\n不过，在内存修改该 Undo 页面后，需要记录对应的 redo log。\n```\n\n### redo log 和 undo log 区别在哪？\n\n```\n这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：\n\nredo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；\nundo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；\n\n事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，\n事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：\n```\n\n### redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？\n\n```\n（1）实现事务的持久性，让 MySQL 有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；\n（2）数据是随机写，先找到位置再写；redolog是顺序写，先记录在日志上，然后在合适的时间再更新到磁盘上 ，提升语句的执行性能\n```\n\n### 产生的 redo log 是直接写入磁盘的吗？\n\n```\n不是的。执行一个事务的过程中，产生的 redo log写到redo log buffer缓存中，后续在持久化到磁盘\n```\n\n### redo log 什么时候刷盘？\n\n```\n（1）MySQL 正常关闭时；\n（2）当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；\n（3）InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。\n（4）每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘\n```\n\n\n\n## binlog（归档日志）\n\n### 为什么需要 binlog ？\n\n```\nbinlog 是逻辑日志，记录内容是语句的原始逻辑，属于MySQL Server 层，不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。\n\n主要用于数据备份、主从复制等场景\n```\n\n### redo log 和 binlog 有什么区别？\n\n```\n（1）适用对象不同：\n\t- binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；\n\t- redo log 是 Innodb 存储引擎实现的日志；\n（2）写入方式不同：\n\t- binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。\n\t- redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。\n（3）用途不同：\n\t- binlog 用于备份恢复、主从复制；\n\t- redo log 用于掉电等故障恢复。\n\t\n\t在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。\n```\n\n### 如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？\n\n```\n不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。\n\n因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。\n\nbinlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。\n```\n\n### binlog 什么时候刷盘？\n\n```\n事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。\n\n一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。\n```\n\n\n\n\n\n## update 语句的执行过程（串联三个日志）\n\n```\n当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。\n具体更新一条记录 UPDATE t_user SET name = \'xiaolin\' WHERE id = 1; 的流程如下:\n（1）执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录\n\t- 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；\n\t- 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。\n（2）执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：\n\t- 如果一样的话就不进行后续更新流程；\n\t- 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；\n（3）开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。\n（4）InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。\n（5）至此，一条记录更新完了。\n（6）在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。\n（7）事务提交，剩下的就是「两阶段提交」的事情了，接下来就讲这个。\n\nhttps://xiaolincoding.com/mysql/log/how_update.html#binlog-什么时候刷盘\n```\n\n\n\n## 主从复制 TODO\n\n```\nhttps://xiaolincoding.com/mysql/log/how_update.html#主从复制是怎么实现\n```\n\n\n\n## 两阶段提交\n\n### 为什么需要\n\n```\n（1）在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。\n（2）事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。\n\n修改一条数据，redo log和binlog持久化时：\n（1）如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入：\n\t\tMySQL 重启后，通过 redo log 能将 Buffer Pool 中 该条数据恢复到新值，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行数据仍是旧值，与主库的值不一致性\n（2）如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入：\n\t\t由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这行数据的 还是旧值，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行数据就是是新值，与主库的值不一致性；\n\t\t\nMySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决\n```\n\n### 是什么\n\n```\n两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」\n在commit阶段之前先写入binlog\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/19461816916679781691667978566pPcs18-04-20220305234956774.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n### 写入binlog发生异常，会发生什么？\n\n```\nMySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/20044416916690841691669084070ZFx8ck-05-20220305234937243.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n### redo log的commit阶段发生异常，会发生什么？\n\n```\n不会回滚事务，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据\n```\n\n### 两阶段提交有什么问题？\n\n```\n（1）磁盘 I/O 次数高\n（2）锁竞争激烈\n\nhttps://xiaolincoding.com/mysql/log/how_update.html#异常重启会出现什么现象\n```\n\n\n\n\n\n## 组提交TODO\n\n```\nhttps://xiaolincoding.com/mysql/log/how_update.html#两阶段提交有什么问题\n```\n\n","timestamp":1691669630396}]