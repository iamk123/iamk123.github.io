# Java基础

## 基本数据类型

### Java 中的几种基本数据类型有哪些？

```
6 种数字类型：
  4 种整数型：byte、short、int、long
  2 种浮点型：float、double
1 种字符类型：char
1 种布尔型：boolean。
```

### 包装类型

```
包装类型：Byte，Short，Integer，Long，Float，Double，Character，Boolean
```

### 基本类型和包装类型的区别？[x]

```
（1）默认值：基本数据类型未初始化时有默认值，如int默认为0；包装类型未初始化时默认为null
（2）存储：基本数据类型基本上是存在栈中（未被static修饰的成员变量在堆中）；包装类型属于对象，存放在堆中
（3）比较方式：基本数据类型比较的是值，；包装类型比较的是对象的内存地址，使用equals（）方法来比较
（4）集合和泛型都只能用包装类，不能用基本数据类型
```

### 自动装箱与拆箱了解吗？原理是什么？[x]

```
（1）装箱：就是把基本类型转为包装类型。调用了包装类的valueOf()方法
（2）拆箱：把包装类型转为基本数据类型。调用了xxValue()方法。（int就是intValue()）

Integer i = 10 等价于 Integer i = Integer.valueOf(10)
int n = i 等价于 int n = i.intValue();
```

### 为什么要自动装箱和拆箱

```
代码简化，更加直观：ArrayList<Integer>只能添加包装类，如果没有自动装箱，就需要我们手动新建Integer对象，然后添加
```

### 装箱 拆箱 缓存 TODO

```

```

### 谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别

```
（1）方式1显示创建一个Integer对象实例
```



## 变量

### 字符型常量和字符串常量的区别?

```
（1）形式：字符型常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符
（2）含义：字符常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值
（3）内存：字符型常量只占2个字节；字符串常量占用若干字节
```



### 成员变量与局部变量的区别？[x]

```
（1）作用域：
		- 成员变量：属于类的一部分，在整个类中都可以访问。可以被public、private、protected、static修饰
		- 局部变量：定在方法、构造函数和代码块内部，只能在其定义的范围内使用。没有修饰符
（2）生命周期
		- 成员变量：随着对象的创建而创建，在对象销毁时销毁
		- 局部变量：在声明时被创建，并在其作用域结束后被销毁。
（3）默认值：
		- 成员变量: 如果没有显式初始化，会被赋予默认值，如数值类型为0，布尔类型为false，引用类型为null。
		- 局部变量：没有默认值，必须在使用之前进行显式初始化。

```

### 静态变量？[x]

```
（1）是什么
静态变量就是被static关键值修饰的变量。它可以被类的所有实例共享，无论创建多个个对象，都共享同一份静态变量。也就是说，静态变量只会分配一次内存，可以节省内存。

（2）访问方法
		- 通过类名直接访问。ClassName.staticVariable;
		- 通过对象引用访问。objectReference.staticVariable;
```

### 静态变量和实例变量的区别？

```java
public class A {

    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
	}

（1）实例变量是属于实例的，与实例变量同生共死
（2）访问方法不同
```

### 静态方法

```
使用static修饰的方法，静态方式也成类方法，是属于类的

特点
（1）无需实例化，通过类名调用
（2）不能访问非静态成员
（3）不能使用this关键值。静态方法中不能使用this关键字，因为this表示当前对象实例，而静态方法没有对象实例。
（4）具有全局性：类的所有实例共享
```

### 静态代码块

```java
static {
    // 静态代码块的代码逻辑
}

使用static修饰的一段代码块
  
特点
（1）在类加载时执行，只执行一次
（2）无需调用，自动执行
（3）用于初始化静态成员
（4）无法访问非静态变量
```

### 静态内部类 [x]

```
静态内部类是定义在另一个类中的内部类，被声明为静态的。

特点：
（1）可以直接访问外部类的静态方法和静态变量，无需创建外部类的对象。但不能直接访问外部类的非静态成员（包括实例变量和实例方法，需要通过创建外部类对象来访问）
（2）可以在没有外部类对象的情况下被实力化和访问
（3）生命周期独立于外部类，即使外部类被销毁，静态内部类仍然存在
（4）静态内部类可以拥有静态成员和实例成员，包括静态变量、静态方法和实例变量、实例方法
```

```java
// 静态内部类的声明方式如下：
public class OuterClass {
    // 外部类的成员和方法
    
    public static class StaticInnerClass {
        // 静态内部类的成员和方法
    }
}

// 静态内部类可以通过以下方式实例化和访问：
OuterClass.StaticInnerClass innerObject = new OuterClass.StaticInnerClass();
// 访问静态内部类的成员和方法
innerObject.staticMethod();
innerObject.staticVariable;
```

### 静态内部类与非静态内部类的区别 [x]

```
（1）声明方式：有无static
（2）实例化方式：静态内部类可以直接实例化；非静态内部类需要外部类的实例来创建
（3）访问范围：
		- 静态内部类：只能访问外部类的静态成员，要访问非静态成员可以通过创建外部类的实例
		- 非静态内部类：可以直接访问外部类的静态与非静态成员
（4）声明周期：
		- 静态内部类：独立于外部类，即使外部类被销毁，静态内部类的实例仍然存在
		- 非静态内部类：声明周期同外部类，共享一个实例
```

### 静态方法为什么不能调用非静态成员?

```
（1）静态方法是属于类的，在类加载时就会分配内存，可以通过类名直接访问；而非静态成员是属于实例对象的，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
（2）类中非静态成员不存在的时候，静态方法就已经存在了，此时调用内存中还不存在的非静态成员，属于非法操作
```

### 静态方法和实例方法有何不同？

```
（1）调用方式
		- 外部调用静态方法时，可以通过【类名.方法名】的方式，也可以通过【对象.方法名】的方式。
		- 实例方法只能通过【对象.方法名】
（2）访问类成员是否存在限制
		- 静态方法只能反问类的静态成员（静态变量和静态方法），不允许访问实例成员
```

### 为什么静态变量不能在方法中定义

```
静态变量属于类的成员，生命周期与类相同，在类加载时就被初始化，类销毁时才会被销毁。
定义在方法中的变量是局部变量，如果定义在方法中，那么只有方法被初始化，方法执行后就会销毁。
```

### 初始化顺序 [x]

```
静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

父类（静态变量、静态语句块）
子类（静态变量、静态语句块）
父类（实例变量、普通语句块）
父类（构造函数）
子类（实例变量、普通语句块）
子类（构造函数）
```



### 重载和重写有什么区别？[x]

```
（1）重载：同一个类中多个同名方法根据不同的参数执行不同的逻辑

（2）重写：运行期间，子类对父类的相同方法的重新改造
“两同两小一大”：
- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

javaguide
```

| 区别点     | 重载方法 | 重写方法                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |
| 发生阶段   | 编译期   | 运行期                                                       |



## 面向对象基础

### 面向对象和面向过程的区别

```
面向过程：将一个大问题分解为一个方法，通过一个个方法的执行解决问题
面向对象：会先抽象出对象，然后用对象执行方法的方式解决问题。为了能够更好的模块化、增加代码的重用性
```

### 创建一个对象用什么运算符?对象实体与对象引用有何不同?

```
new 运算符，new 创建对象实例（对象实例在 内存中），
对象引用指向对象实例（对象引用存放在栈内存中）。
- 一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；
- 一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。
```

### 对象的相等和引用相等的区别

```java
对象的相等一般比较的是内存中存放的内容是否相等。
引用相等一般比较的是他们指向的内存地址是否相等。

String str1 = "hello";
String str2 = new String("hello");
String str3 = "hello";
// 使用 == 比较字符串的引用相等
System.out.println(str1 == str2);
System.out.println(str1 == str3);
// 使用 equals 方法比较字符串的相等
System.out.println(str1.equals(str2));
System.out.println(str1.equals(str3));

false
true
true
true
```

### 构造方法有哪些特点？是否可被 override?

```
构造方法特点如下：
- 名字与类名相同。
- 没有返回值，但不能用 void 声明构造函数。
- 生成类的对象时自动执行，无需调用。

构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。
```

### 面向对象三大特征

封装

```
指把对象的属性封装在对象内部，不允许外部对象直接访问对象内部信息。可以提供一些被外界访问的方法来操作属性
```

继承

```
不同类型的对象，相互之间经常有一定数量的共同点, 可以将它们封装成一个类。
其他类继承这个类后，拥有父类对象所有的属性和方法（私有属性也拥有，但无法访问）
子类可以进行拓展，拥有自己的属性和方法，也可以对父类方法进行重写
```

多态

```
多态指同一个行为具有多个不同的表现形式或形态的能力

（1）编译时多态：主要是通过方法的重载实现的，编译时，java编译器会根据调用方法的参数类型、数量来决定使用哪个方法
（2）运行时多态：主要通过方法的重写和继承实现的。当子类继承父类并重写父类的方法时，父类引用指向子类对象，并调用子类对象的方法，这种方法调用解析是在运行时进行的。
```

### 抽象类和接口有什么区别

```
（1）主要目的
		- 抽象类是为了提供一个基类，这个基类包含子类共有的属性和方法实现，但可能包含一些没有实现的方法，子类继承后需要去实现这些抽象方法
		- 接口是为了定义一个规范，指定了类应该实现的方法。
（2）抽象类被子类继承，可以有构造方法，普通成员变量；接口被子类实现，不能有构造方法，也没有普通成员变量，只能有静态常量。
（3）一个类只能继承一个抽象类；一个类可以实现多个接口

如果希望为多个类提供共同的实现，则使用抽象类；
如果希望定义某个功能的规范而不关心具体实现，则使用接口。
```

### 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

```
（1）深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
（2）浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
（3）引用拷贝：引用拷贝就是两个不同的引用指向同一个对象。
```



## Object

### equals 与==的区别

```
==：
	- 如果是基本数据类型，==比较它们的值是否相等
	- 如果是引用对象，==会判断两个对象指向的内存地址是否相同，而不是比较内容
	
equals：
	- 如果没有重写equals()方法，则和==一样
	- 如果重写了，一般是比较两个对象中的属性是否相等
```

### hashCode() 有什么用？

```
（1）hashcode的作用是获取哈希码，也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。
（2）对象的快速比较：hashCode值不相等对象一定不等，hashCode值相等则进一步比较
```

### 为什么要有 hashCode？

```
【hashCode的作用】
以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？
把对象加入hashSet时，先计算对象的hashCode值，如果没有相等的直接加入；
如果有相等的，调用equals()进一步比较，如果不相等则把对象添加。

可以大大减少equals的次数，提高执行效率
```

### 为什么重写 equals() 时必须重写 hashCode() 方法？

```
两个对象相等，hashCode必须相等
如果重写equals()而没有重写hashCode()，会导致equals方法判断是两个相等的对象，但hashCode值却不相等
```



## String

### String，Stringbuffer，StringBuilder 的区别

```
（1）不可变性：
		- String是不可变的。
		- StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串char[] value，但没有用final修饰，且提供了修改字符串的方法如append(), 所以两种对象都是可变的。
（2）安全性：
		- String是不可变的，所以是线程安全的
		- StringBuffer是线程安全的，大多数方法都是同步的
		- StringBuilder是线程非安全的，没用同步方法
（3）性能：
		- String每次修改都会产生一个新对象，频繁的修改会导致性能下降，(增加垃圾回收的负担)
		- StringBuffer、StringBuilder：都是对对象本身进行操作，StringBuilder没有同步方法，性能比StringBuffer快。
（4）使用场景：
		- String：当字符串内容不需要修改或字符串操作不频繁时
		- StringBuffer：在多线程环境中，如果需要频繁修改字符串内容，使用 StringBuffer 是合适的。
		- StringBuilder：在单线程环境中，如果需要频繁修改字符串内容，使用 StringBuilder 通常会提供更好的性能。

```

### String 为什么是不可变的?

```
private final char value[];
(1) 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。
(2)String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。
```

### 字符串常量池的作用了解吗？

```java
字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true
```



### String s1 = new String("abc");这句话创建了几个字符串对象？

```
会创建 1 或 2 个字符串对象。
(1) 如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。
(2) 如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。
```



## 异常

### Exception 和 Error 有什么区别？

```
在 Java 中，所有的异常都有一个共同的祖先，java.lang.Throwable,它有两个重要的子类:
- Exception： 程序可以处理的异常。分为受检查异常、非受检查异常
- Error：程序无法处理的错误。
```

### Checked Exception 和 Unchecked Exception 有什么区别？

```
Checked Exception：Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。例如IOException

Unchecked Exception：Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。
- NullPointerException(空指针错误)
- IllegalArgumentException(参数错误比如方法入参类型错误)
- NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）
- ArrayIndexOutOfBoundsException（数组越界错误）
- ClassCastException（类型转换错误）
- ArithmeticException（算术错误）
- SecurityException （安全错误比如权限不够）
- UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)
```

### finally 中的代码一定会执行吗？

```
不一定的！在某些情况下，finally 中的代码不会被执行。

（1）finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。
（2）程序所在的线程死亡。
（3）关闭 CPU。
```

### final, finally, finalize 的区别

```
final：
	- 是一个关键字，用于声明某些事物不能被后续修改。
	- 用于修饰属性、方法和类。表示属性不能被重新赋值，方法不可被覆盖，类不可被继承
finally：
	是异常处理语句结构的一部分，一般以try-catch-finally出现，无论发生什么异常，finally都会被执行
finalize：
	是Object类中的一个方法，它会在垃圾回收器决定收回对象之前被调用。我们可以重写此方法以确保对象被后手前执行一些特定的清理任务
```



## 反射

### 是什么？

```
反射是一种机制，指的是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。
本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。

https://blog.csdn.net/a745233700/article/details/82893076
```

