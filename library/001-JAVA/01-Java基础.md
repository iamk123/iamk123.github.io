# Java基础

## 基本数据类型

### Java 中的几种基本数据类型有哪些？

```
6 种数字类型：
  4 种整数型：byte、short、int、long
  2 种浮点型：float、double
1 种字符类型：char
1 种布尔型：boolean。
```

### 包装类型

```
包装类型：Byte，Short，Integer，Long，Float，Double，Character，Boolean
```

### 基本类型和包装类型的区别？[x]

```
（1）默认值：基本数据类型未初始化时有默认值，如int默认为0；包装类型未初始化时默认为null
（2）存储：基本数据类型基本上是存在栈中（未被static修饰的成员变量在堆中）；包装类型属于对象，存放在堆中
（3）比较方式：基本数据类型比较的是值，；包装类型比较的是对象的内存地址，使用equals（）方法来比较
（4）集合和泛型都只能用包装类，不能用基本数据类型
```

### 自动装箱与拆箱了解吗？原理是什么？[x]

```
（1）装箱：就是把基本类型转为包装类型。调用了包装类的valueOf()方法
（2）拆箱：把包装类型转为基本数据类型。调用了xxValue()方法。（int就是intValue()）

Integer i = 10 等价于 Integer i = Integer.valueOf(10)
int n = i 等价于 int n = i.intValue();
```



## 变量

### 字符型常量和字符串常量的区别?

```
（1）形式：字符型常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符
（2）含义：字符常量相当于一个整型值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值
（3）内存：字符型常量只占2个字节；字符串常量占用若干字节
```



### 成员变量与局部变量的区别？[x]

```
（1）作用域：
		- 成员变量：属于类的一部分，在整个类中都可以访问。可以被public、private、protected、static修饰
		- 局部变量：定在方法、构造函数和代码块内部，只能在其定义的范围内使用。没有修饰符
（2）生命周期
		- 成员变量：随着对象的创建而创建，在对象销毁时销毁
		- 局部变量：在声明时被创建，并在其作用域结束后被销毁。
（3）默认值：
		- 成员变量: 如果没有显式初始化，会被赋予默认值，如数值类型为0，布尔类型为false，引用类型为null。
		- 局部变量：没有默认值，必须在使用之前进行显式初始化。

```

### 静态变量？[x]

```
（1）是什么
静态变量就是被static关键值修饰的变量。它可以被类的所有实例共享，无论创建多个个对象，都共享同一份静态变量。也就是说，静态变量只会分配一次内存，可以节省内存。

（2）访问方法
		- 通过类名直接访问。ClassName.staticVariable;
		- 通过对象引用访问。objectReference.staticVariable;
```

### 静态变量和实例变量的区别？

```java
public class A {

    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
	}

（1）实例变量是属于实例的，与实例变量同生共死
（2）访问方法不同
```

### 静态方法

```
使用static修饰的方法，静态方式也成类方法，是属于类的

特点
（1）无需实例化，通过类名调用
（2）不能访问非静态成员
（3）不能使用this关键值。静态方法中不能使用this关键字，因为this表示当前对象实例，而静态方法没有对象实例。
（4）具有全局性：类的所有实例共享
```

### 静态代码块

```java
static {
    // 静态代码块的代码逻辑
}

使用static修饰的一段代码块
  
特点
（1）在类加载时执行，只执行一次
（2）无需调用，自动执行
（3）用于初始化静态成员
（4）无法访问非静态变量
```

### 静态内部类 [x]

```
静态内部类是定义在另一个类中的内部类，被声明为静态的。

特点：
（1）可以直接访问外部类的静态方法和静态变量，无需创建外部类的对象。但不能直接访问外部类的非静态成员（包括实例变量和实例方法，需要通过创建外部类对象来访问）
（2）可以在没有外部类对象的情况下被实力化和访问
（3）生命周期独立于外部类，即使外部类被销毁，静态内部类仍然存在
（4）静态内部类可以拥有静态成员和实例成员，包括静态变量、静态方法和实例变量、实例方法
```

```java
// 静态内部类的声明方式如下：
public class OuterClass {
    // 外部类的成员和方法
    
    public static class StaticInnerClass {
        // 静态内部类的成员和方法
    }
}

// 静态内部类可以通过以下方式实例化和访问：
OuterClass.StaticInnerClass innerObject = new OuterClass.StaticInnerClass();
// 访问静态内部类的成员和方法
innerObject.staticMethod();
innerObject.staticVariable;
```

### 静态内部类与非静态内部类的区别 [x]

```
（1）声明方式：有无static
（2）实例化方式：静态内部类可以直接实例化；非静态内部类需要外部类的实例来创建
（3）访问范围：
		- 静态内部类：只能访问外部类的静态成员，要访问非静态成员可以通过创建外部类的实例
		- 非静态内部类：可以直接访问外部类的静态与非静态成员
（4）声明周期：
		- 静态内部类：独立于外部类，即使外部类被销毁，静态内部类的实例仍然存在
		- 非静态内部类：声明周期同外部类，共享一个实例
```

### 静态方法为什么不能调用非静态成员?

```
（1）静态方法是属于类的，在类加载时就会分配内存，可以通过类名直接访问；而非静态成员是属于实例对象的，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
（2）类中非静态成员不存在的时候，静态方法就已经存在了，此时调用内存中还不存在的非静态成员，属于非法操作
```

### 静态方法和实例方法有何不同？

```
（1）调用方式
		- 外部调用静态方法时，可以通过【类名.方法名】的方式，也可以通过【对象.方法名】的方式。
		- 实例方法只能通过【对象.方法名】
（2）访问类成员是否存在限制
		- 静态方法只能反问类的静态成员（静态变量和静态方法），不允许访问实例成员
```

### 为什么静态变量不能在方法中定义

```
静态变量属于类的成员，生命周期与类相同，在类加载时就被初始化，类销毁时才会被销毁。
定义在方法中的变量是局部变量，如果定义在方法中，那么只有方法被初始化，方法执行后就会销毁。
```

### 初始化顺序 [x]

```
静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

父类（静态变量、静态语句块）
子类（静态变量、静态语句块）
父类（实例变量、普通语句块）
父类（构造函数）
子类（实例变量、普通语句块）
子类（构造函数）
```



### 重载和重写有什么区别？[x]

```
（1）重载：同一个类中多个同名方法根据不同的参数执行不同的逻辑

（2）重写：运行期间，子类对父类的相同方法的重新改造
“两同两小一大”：
- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

javaguide
```

| 区别点     | 重载方法 | 重写方法                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |
| 发生阶段   | 编译期   | 运行期                                                       |



