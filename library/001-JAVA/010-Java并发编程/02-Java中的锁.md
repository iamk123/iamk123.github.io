

# Java中的锁

## 1 Lock接口

### 什么是Lock接口

```java
public interface Lock {
    void lock(); 
    void lockInterruptibly() throws InterruptedException; 
    boolean tryLock(); 
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException; 
    void unlock(); Condition newCondition();
}
```

```
Lock是Java中提供的一个接口，用于实现【线程同步机制】，它可以替代Synchronized关键字。
Lock接口提供了比Synchronized更灵活、更强大的线程同步功能，可以用于解决多线程中的资源竞争和死锁等问题。
Lock接口的实现类有很多种，其中最常用的是ReentrantLock。

Lock接口提供了以下主要方法：
- lock()：获取锁，如果锁已经被其他线程获取，则当前线程进入等待状态。
- unlock()：释放锁，如果当前线程持有锁，则释放锁并唤醒等待的线程。
- tryLock()：尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true，否则立即返回false。
- tryLock(long time, TimeUnit unit)：尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true，否则等待指定时间后返回false。
- newCondition()：创建一个Condition对象，用于实现等待/通知机制。

需要注意的是，在使用Lock接口时，需要在finally代码块中释放锁，以确保锁一定会被释放，避免死锁的发生。
```

### 什么是线程同步机制？

```
- 是什么？
线程同步机制是多线程编程中常用的一种机制，用于控制多个线程对共享资源的访问。

- 为什么？
在多线程环境中，多个线程同时访问共享资源可能会导致竞争条件和数据不一致等问题，因此需要使用线程同步机制来避免这些问题的发生

- 怎么样？
1.synchronized
2.Lock接口

- 基本原理
线程同步机制的基本原理是在共享资源的访问前获取锁，只有获取锁的线程才能访问共享资源，其他线程需要等待锁的释放。
在共享资源访问完成后，释放锁，让其他线程可以继续访问共享资源。这样就保证了共享资源在任何时刻只能被一个线程访问，避免了竞争条件和数据不一致等问题的发生。

- 使用时注意的问题
1.使用线程同步机制时，应该避免死锁、饥饿等问题的发生，以确保程序的正常运行
2.同时，在使用synchronized关键字时，应该尽量减小同步块的范围，以提高程序的性能。
3.在使用Lock接口时，需要在finally代码块中释放锁，以确保锁一定会被释放，避免死锁的发生。
```

### 在使用synchronized关键字时，为什么要减小同步块的范围？

```
1.提高性能
范围越大，需要等待获取锁的线程越多，导致在获取锁的过程中需要等待其他线程释放锁，而其他线程释放锁的时间也会比较长，这就会造成线程的等待时间过长，降低程序的运行效率。
2.避免死锁
不同的线程可能会竞争多个锁，释放锁的时间也会比较长，导致相互等待，形成死锁。

因此，为了避免以上问题的发生，应该尽量减小同步块的范围，只在必要的地方进行同步，这样可以提高程序的性能，同时也可以降低出现死锁等问题的概率。
```

### 为什么使用lock接口需要在finally代码块中释放锁

```
- 为什么？
在使用Lock接口进行线程同步时，需要手动获取和释放锁，这是两个独立的操作，如果在获取锁之后发生异常，就有可能导致锁没有被释放，从而导致死锁等问题的发生。
- 怎么样？
因此，将释放锁的操作放在finally代码块中，这样可以确保在任何情况下都会释放锁，避免死锁等问题的发生。
```

### Lock和Synchronized的区别？

```
- 是什么 & 作用
Lock和Synchronized都是Java中用于实现线程同步的机制，它们的目的是为了避免线程间的竞争条件和数据不一致等问题。它们的区别如下：

- 区别
1.锁的获取方式：
	Synchronized是在进入同步代码块或同步方法时，自动获取锁，退出同步代码块或方法时自动释放锁；而Lock需要手动获取锁，并且必须手动释放锁。
2.锁的粒度：
	Synchronized只能对整个方法或代码块进行加锁，而Lock可以对代码块进行更细粒度的控制。
3.可中断性：
	在获取锁时，Synchronized是不可中断的，即使该线程在等待锁的过程中被中断，也不会释放锁；而Lock可以根据需要设置锁的可中断性。
4.公平锁：
	Synchronized是非公平锁，不保证等待时间最长的线程最先获取锁；而Lock可以通过参数指定为公平锁或非公平锁。
5.性能：
	相比较而言，Lock的性能比Synchronized好，在高并发的情况下，Lock的吞吐量比Synchronized更高。

需要注意的是，Lock是在JDK 5中引入的，而Synchronized是Java早期就提供的同步机制。由于Lock相比Synchronized更灵活和高效，因此在实际开发中，使用Lock的场景会更多。
```

## 2 Lock的使用方式

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
  ...
} finally {
  lock.unlock();
}
```

