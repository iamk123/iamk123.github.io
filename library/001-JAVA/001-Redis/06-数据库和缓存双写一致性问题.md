

## 问题背景

使用缓存的常见方式

```
用户请求过来之后，先查缓存有没有数据，如果有则直接返回。
如果缓存没数据，再继续查数据库。
如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。
如果数据库也没数据，则直接返回空。
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/10015016860169101686016910255xZYvGL-640.png" alt="图片" style="zoom:50%;" />

存在的问题：

```
如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？

不更新缓存行不行？
答：当然不行，如果不更新缓存，在很长的一段时间内（决定于缓存的过期时间），用户请求从缓存中获取到的都可能是旧值，而非数据库的最新值。这不是有数据不一致的问题？
```

更新缓存的4种方案

```
先写缓存，再写数据库
先写数据库，再写缓存
先删缓存，再写数据库
先写数据库，再删缓存
```

## 更新缓存方式

### 1 先写缓存，再写数据库

#### 问题1：写数据库失败

```
某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了，缓存就变成脏数据了
```

### 2 先写数据库，再写缓存

#### 问题1：写缓存失败

```
在写缓存过程中，出现网络异常导致写缓存失败
数据库数据已更新，但缓存中还是旧值
```

#### 问题2：高并发下的问题

假设在高并发的场景中，针对同一个用户的同一条数据，有两个写数据请求：a和b，它们同时请求到业务系统。

其中请求a获取的是旧数据，而请求b获取的是新数据，如下图所示：

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/101057168601745716860174573311V2LXi-640-20230606101057189.png" alt="图片" style="zoom:50%;" />

1.  请求a先过来，刚写完了数据库。但由于网络原因，卡顿了一下，还没来得及写缓存。
2.  这时候请求b过来了，先写了数据库。
3.  接下来，请求b顺利写了缓存。
4.  此时，请求a卡顿结束，也写了缓存。

很显然，在这个过程当中，请求b在缓存中的`新数据`，被请求a的`旧数据`覆盖了。

也就是说：在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。

#### 问题3：浪费系统资源

```
对于写多读少的业务，每次写操作都需要写缓存，比较浪费系统资源。
```

### 3 先删缓存，再写数据库

#### 问题1：高并发下的问题

假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求c，还有另一个写数据请求d（一个更新操作），同时请求到业务系统。如下图所示：

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/10193316860179731686017973114G7KgaY-image-20230606101932996.png" alt="image-20230606101932996" style="zoom:50%;" />

```
请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。
这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。
请求c将数据库中的旧值，更新到缓存中。
此时，请求d卡顿结束，把新值写入数据库。

总结：d删完缓存没写完数据库c就已经读数据了，读的就是mysql的旧值并存到缓存中
```



#### 改进：延迟双删

```
写数据库之前删除一次，写完数据库后，延迟再删除一次。

流程：
请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。
这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。
请求c将数据库中的旧值，更新到缓存中。
此时，请求d卡顿结束，把新值写入数据库。
一段时间之后，比如：500ms，请求d将缓存删除。
```

为什么一定要间隔一段时间之后，才能删除缓存呢？

```
请求d卡顿结束，把新值写入数据库后，请求c将数据库中的旧值，更新到缓存中。
此时，如果请求d删除太快，在请求c将数据库中的旧值更新到缓存之前，就已经把缓存删除了，这次删除就没任何意义。必须要在请求c更新缓存之后，再删除缓存，才能把旧值及时删除了。
所以需要在请求d中加一个时间间隔，确保请求c，或者类似于请求c的其他请求，如果在缓存中设置了旧值，最终都能够被请求d删除掉。
```

#### 问题2: 第二次删除缓存失败

```

```



### 4 先写数据库，再删缓存

在高并发的场景中，有一个读数据请求，有一个写数据请求，更新过程如下：

1.  请求e先写数据库，由于网络原因卡顿了一下，没有来得及删除缓存。
2.  请求f查询缓存，发现缓存中有数据，直接返回该数据。
3.  请求e删除缓存。

在这个过程中，只有请求f读了一次旧数据，后来旧数据被请求e及时删除了，看起来问题不大。

但如果是读数据请求先过来呢？

1.  请求f查询缓存，发现缓存中有数据，直接返回该数据。
2.  请求e先写数据库。
3.  请求e删除缓存。

这种情况看起来也没问题呀？

#### 问题1: 缓存到期

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/10274616860184661686018466845Io7rgq-640-20230606102746713.png" alt="图片" style="zoom:50%;" />

1.  缓存过期时间到了，自动失效。
2.  请求f查询缓存，发缓存中没有数据，查询数据库的旧值，但由于网络原因卡顿了，没有来得及更新缓存。
3.  请求e先写数据库，接着删除了缓存。
4.  请求f更新旧值到缓存中。



这时，缓存和数据库的数据同样出现不一致的情况了。

但这种情况还是比较少的，需要同时满足以下条件才可以：

1.  缓存刚好自动失效。
2.  请求f从数据库查出旧值，更新缓存的耗时，比请求e写数据库，并且删除缓存的还长。

我们都知道查询数据库的速度，一般比写数据库要快，更何况写完数据库，还要删除缓存。所以绝大多数情况下，写数据请求比读数据情况耗时更长。

由此可见，系统同时满足上述两个条件的概率非常小。

#### 问题2: 缓存删除失败

```

```



### 缓存删除失败

增加重试机制

```
在接口中如果更新了数据库成功了，但更新缓存失败了，可以立刻重试3次。如果其中有任何一次成功，则直接返回成功。如果3次都失败了，则写入数据库，准备后续再处理。
当然，如果你在接口中直接同步重试，该接口并发量比较高的时候，可能有点影响接口性能。
```

改进：异步重试

```
每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统OOM问题，不太建议使用。
将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。
将重试数据写表，然后使用elastic-job等定时任务进行重试。
将重试的请求写入mq等消息中间件中，在mq的consumer中处理。
订阅mysql的binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。
```

### 参考

-   [如何保证数据库和缓存双写一致性？](https://mp.weixin.qq.com/s/DsZgnwIqW3jrE5KxShGKeg)
-   [江南一点雨：如何保证缓存和数据库的一致性？](https://mp.weixin.qq.com/s/7-vUDQGj8mZIeryZA3gEiw)