https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html

https://www.yuque.com/snailclimb/mf2z3k/vqe4gz 密码 cnk4

https://www.yuque.com/snailclimb/gepg7u/go0n51 密码：ihvn

##  Spring IoC

### 谈谈自己对于 Spring IoC 的了解

是什么

```
IoC（Inversion of Control:控制反转） 是一种设计思想。
控制：指的是对象创建（实例化、管理）的权力
反转：控制权交给外部环境（Spring 框架、IoC 容器）

IoC 的思想就是将原本在程序中手动创建对象的控制权交由 Spring 框架来管理，应用程序只需要定义好对象的依赖关系，容器负责在运行时创建和注入这些对象。

Spring IoC 的核心是 Spring 容器，它是一个管理和维护对象的容器。Spring 容器负责创建、初始化、配置和销毁对象，同时它也管理对象之间的依赖关系。容器通过读取配置文件或者注解来了解对象之间的关系，并根据这些配置在需要的时候创建和注入对象。

IoC 的另一个重要概念是依赖注入（DI），它是指容器将对象所需的依赖关系注入到对象中，而不是由对象自己去创建或查找依赖对象。这样可以减少对象之间的耦合，使得代码更加清晰和可维护。
```

### 什么是 Spring Bean？

```
在Spring框架中，Bean就是一个由Spring容器管理的对象实例，这些对象实例 被spring容器创建、配置和管理，可以在应用程序中被重复使用。
```

### 将一个类声明为 Bean 的注解有哪些?

```
（1）@Component：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。
（2）@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。
（3）@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
（4）@Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。
```

### Bean 是线程安全的吗？

```
Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。
默认情况下，Spring Bean 是单例的，即在整个应用程序的生命周期内只会创建一个实例，所有线程共享这个实例。
然而，单例 Bean 并不保证线程安全，因为如果在单例 Bean 内部存在共享的可变状态，多个线程同时访问可能会导致线程安全问题。
```

### 如何保证Spring Bean 的线程安全性

```
（1）作用域使用非单例的prototype，每次获取都创建一个新实例，不会共享状态。

（2）避免共享可变状态：尽量避免在单例 Bean 中使用共享的可变状态。如果需要在多线程环境中处理共享状态，可以使用线程安全的数据结构或者同步机制来保证线程安全。
（3）synchronized：如果确实需要在单例 Bean 内部进行多线程访问，可以在方法级别使用同步（synchronization）机制，例如使用 synchronized 关键字来保护临界区。
（4）在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。
```



## Spring AOP

### 是什么

```
是一种面向切面编程的技术，能够将那些与业务逻辑无关的，但却为业务模块共同调用的逻辑从业务代码中分离出来，减少重复代码，降低模块间的耦合度，有利于拓展和维护。
```

### 通知类型有哪些？

```
（1）前置通知（@Before）：在目标方法调用之前调用通知
（2）后置通知（@After）：在目标方法完成之后调用通知
（3）环绕通知（@Around）：在被通知的方法调用之前和调用之后执行自定义的方法
（4）返回通知（@AfterReturning）：在目标方法成功执行之后调用通知
（5）异常通知（@AfterThrowing）：在目标方法抛出异常之后调用通知
```

### 多个切面的执行顺序如何控制？

（1）通常使用@Order 注解直接定义切面顺序，值越小优先级越高

```java
@Order(3)
@Component
@Aspect
public class LoggingAspect implements Ordered {
```

（2）**实现`Ordered` 接口重写 `getOrder` 方法。**

```java
@Component
@Aspect
public class LoggingAspect implements Ordered {
    @Override
    public int getOrder() {
        // 返回值越小优先级越高
        return 1;
    }
}
```

### Spring AOP术语

```
（1）连接点（Jointpoint）：表示在程序中可以插入切面的点。【在哪里干】
（2）切点（Pointcut）：定义了哪些连接点应该被切面的通知所织入。【连接点的集合】
（3）通知（Advice）：在连接点上执行的行为。【干什么】
（4）切面（Aspect）：是一组「通知」和「切点」的组合，用于在目标对象的方法执行过程中插入横切逻辑
（5）织入（Weaving）：将切面的逻辑插入到目标对象代码的执行过程中
```

### 实现原理

```
Spring AOP 就是基于动态代理的，
（1）JDK动态代理：
		- 如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK动态代理，去创建代理对象。
		- 实现原理：JDK的动态代理是基于「反射」实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。
（2）Cglib动态代理：
		- 没有实现接口的对象，使用 Cglib 
		- 实现原理：在运行时通过生成字节码的方式创建一个目标对象的子类，然后在子类中织入切面中的通知代码
		
springboot中的aop， 2.0之前和spring一样，2.0之后首选cglib动态代理，如果要用jdk动态代理需要手动配置
		
https://www.cnblogs.com/tuyang1129/p/12878549.html
https://mp.weixin.qq.com/s/mEmXaboXu48O96Yi_Kn9pw
```

### JDK动态代理 和 Cglib动态代理优缺点

```
JDK动态代理 
（1）优点：
		- JDK动态代理是JDK原生的，不需要任何依赖即可使用
		- 通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；
（2）缺点：
		- 如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；
		- JDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；
		
Cglib动态代理
（1）优点：
		- 使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；
		- CGLib执行代理方法的效率要高于JDK的动态代理。CGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致
（2）缺点：
		- 由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；
		- 由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；
		- CGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；
			
https://www.cnblogs.com/tuyang1129/p/12878549.html
```



### 什么是代理？

```
代理是一种设计模式，它充当了其他对象的接口，以控制对这些对象的访问。
代理对象可以在客户端和实际目标对象之间充当中介，通过代理来进行访问对象，从而增加一些额外的功能

【分为静态代理和动态代理】
```

### 静态代理 vs 动态代理

```
（1）静态代理：代理类在编译阶段就已经存在，通过手动写代理类来实现对目标对象的包装和控制
（2）动态代理：在运行时创建代理对象，不需要手动编写代理类，而是通过一些工具库或者语言特性来实现。在java中，常用的动态代理技术有JDK动态代理、Cglib代理
```



## 负载均衡

### nginx负载均衡策略

```
默认的策略是轮询

（1）轮询（Round Robin）
	- 描述：默认的负载均衡方法，按顺序将请求分配到后端服务器列表中。
	- 特点：简单易实现，但不考虑后端服务器的负载情况。
	
（2）加权轮询（Weighted Round Robin）
	- 描述：和轮询类似，但可以指定每个服务器的权重，权重越高的服务器将接收更多的请求。
	- 特点：可以根据服务器的性能和负载来分配权重，实现更合理的负载分配。
	
（3）最少连接（Least Connections）
	- 描述：将新的请求分配给当前连接数最少的服务器。
	- 特点：能够更好地处理不均匀的负载情况。

（4）IP哈希（IP Hash）
	- 描述：根据客户端的 IP 地址进行哈希计算，将来自同一IP的请求分配给同一台服务器。
	- 特点：可以保持客户端会话的持久性。

（5）URL哈希（URL Hash）
	- 描述：根据请求的URL进行哈希计算，相同URL的请求将被路由到同一台服务器。
	- 特点：可以用于缓存优化，因为相同URL的请求可以被路由到缓存了该URL内容的服务器。

（6）最快响应时间（Least Time）
	- 描述：将请求路由到响应时间最短的服务器。
	- 特点：可以提供较好的用户体验，因为它总是尝试将请求路由到性能最好的服务器。
```

