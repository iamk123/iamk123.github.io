## TCP基本认识

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/01/14301816908714181690871418304qhbr63-format,png-20230309230534096.png" alt="TCP 头格式" style="zoom:50%;" />



### 什么是TCP？[x]

```
TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。

（1）面向连接：在传输数前，TCP会建立一个连接，然后在连接上传输数据，传输完后关闭连接。
（2）可靠的：通过序列号、确认、重传、流量控制、拥塞控制和校验和等机制，确保TCP的可靠传输。无论网络链路出现了怎么样变化，TCP都可以保证一个报文，一定能够到达接收端。
（3）字节流：如何理解TCP是面向字节流协议的？
```

### 如何理解TCP是面向字节流协议的？[x]

```
TCP 协议在传输数据时是以字节为单位进行传输的。这意味着，当用户通过应用程序发送数据时，TCP 协议会将用户消息拆分成若干个字节，并在传输时保证这些字节的顺序，以便接收端能够正确地重组原始数据。
```

### 如何唯一确定一个 TCP 连接呢？

```
源地址-源端口-目标地址-目标端口
源地址-源端口 = 套接字
```



## TCP和UDP

### TCP 与 UDP 的区别？[x]

```
（1）连接性
		- TCP是面向连接的协议，传输数据之前需要建立连接，结束后需要释放连接
		- UDP是无连接协议，连接前不需要建立连接
（2）可靠性：
		- TCP保证数据的可靠传输。通过序列号、确认、重传、流量控制、拥塞控制、校验和等机制来保证数据的完整性和顺序性。如果数据包丢失或损坏，TCP会自动重传数据。
		- UDP不保证数据的可靠传输。远程主机接受报文不需要确认，并不关心数据是否到达目的地
（3）传输效率
		- TCP需要连接、确认、重传等机制，所以TCP比UDP慢很多
（4）传输形式
		- TCP是面向字节流的，首部开销20-60字节
		- UDP是面向报文的，首部开销8字节
（5）广播、多播
		- TCP只支持点对点通信
		- UDP支持一对一、一对多、多对一、多对多
		
https://javaguide.cn/cs-basics/network/other-network-questions2.html#tcp-与-udp-的区别-重要
```

### 什么时候选择 TCP，什么时候选 UDP?

```
（1）TCP用于对传输准确性要求特别高的场景，如文件传输、发送和接收邮件、远程登录等
（2）UDP一般用于即时通信，比如语音、视频、直播，对传输数据的准确性要求不是特别高
```

###  HTTP 基于 TCP 还是 UDP？TODO

```
HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。

https://javaguide.cn/cs-basics/network/other-network-questions2.html#什么时候选择-tcp-什么时候选-udp
```

### 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?

```
tcp:
（1）HTTP：超文本传输协议
（2）https
（3）ftp
（4）SMTP
（5）ssh

udp
（1）dhcp
（2）dns
```

## 三次握手 & 四次挥手

https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html

https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-三次握手过程是怎样的

### TCP 三次握手

#### 三次握手流程 [x]

 <img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/28/201503169054650316905465032715kjBPy-tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解" style="zoom:50%;" />

```
（1）一次握手：客户端发送带有SYN（seq=x）标志的数据包->服务端，然后客户端进入SYN_SEND状态，等待服务器确认；
（2）二次握手：服务端发送带有SYN+ACK(seq=y, ack=x+1)标志的数据包->客户端，然后服务端进入SYN_RECV状态
（3）三次握手：客户端发送带有ACK（seq=y+1）标志的数据包->服务端，然后客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

SYN+ACK报文指的是SYN和ACK字段置为1
seq=y表示序列号为y
ack=x+1表示确认应答号为x+1
```

#### 为什么要三次握手？不是两次、四次？

```
最基本的原因：三次握手的目的是为了建立可靠的通信信道，让双方确认确认自己与对方的发送和接收都是正常的。
（1）第一次握手：client什么也不能确认；server确认了自己接收正常，对方发送正常
（2）第二次握手：client确认自己发送和接收正常，对方发送接收正常；server不能确认自己发送是否正常、对方接收是否正常
（3）第三次握手：让server确认自己发送和接收正常，对方发送和接收正常

分析三次握手的原因：
（1）避免历史连接，浪费资源（主要原因）
（2）三次握手才可以同步双方的初始序列号
```

避免历史连接，浪费资源

```
三次握手如何阻止历史连接：
（1）先发送一个连接请求（seq=90）阻塞在网络中，超时后发送新的连接请求（seq=100）
（2）「旧的SYN报文」比「新的SYN」报文到达服务端。此时服务器就会回复一个SYN+ACK报文（ack=91）
（3）客户端收到后发现期望的ack是100+1，于是就会回复一个RST报文终止连接
（4）客户端收到后序新的SYN报文后正常完成三次握手

两次握手的问题：
（1）收到旧的SYN报文后，就建立连接，回复一个ack=91
（2）客户端收到消息后发现不是自己期望的确认号，就回复一个RST报文终止连接。但是服务端已经初始化连接了，就会白白浪费资源
（3）收到新的SYN则正常建立连接
```

同步双方的初始序列号

```
序列号的作用：
（1）接收方可以去重
（2）排序
（3）告诉发送方哪些已经被接收

两次握手的问题：
只能保证发送方的初始序列号被服务端接收

四次握手：
可以保证双方同步初始序列号，但是第二第三步可以合并优化
```

#### 第 2 次握手传回了 ACK，为什么还要传回 SYN？

```
（1）回传ACK，是为了告诉客户端，接收到的信息就是客户端发送的信号，表明客户端到服务端的通信是正常的。
（2）回传SYN是为了建立并确认服务端到客户端的通信。
```

#### 第一次握手丢失了，会发生什么？[x]

```
第一次握手，客户端发送一个SYN报文，然后进入SYN_SEND状态
如果丢失，一直收不到服务端的SYN+ACK（第二次握手），就会触发「超时重传」机制，重传SYN报文，重传的SYN报文序列号都是一样的。
每次超时的时间都是上一次的2倍，超过「最大重传次数」后，如果还是没有回应，就会断开TCP连接，不再发生SYN报文
```

#### 第二次握手丢失了，会发生什么？

```
（1）第二次握手是什么？
（2）第二次握手的ACK是对第一次握手的确认，由于第二次丢失后，客户端迟迟收不到，就会认为自己发送的SYN丢失，客户端就会触发超时重传机制，重传SYN报文
（3）第二次握手的SYN需要客户端回复ACK确认，由于第二次丢失，客户端收不到也就不会回传，所以服务端会触发超时重传机制，重传SYN-ACK报文
（4）超过最大重传次数后就不再发送，断开连接
```

#### 第三次握手丢失了，会发生什么？

```
（1）什么次第三次握手
（2）第三次丢失，服务端迟迟收不到ACK报文，就会触发超时重传机制，重发SYN-ACK报文
（3）超过最大重传次数后就不再发送，断开连接
```

#### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

```
（1）为了防止历史报文被下一个相同四元组的连接接收（主要方面）；
假设客户端和服务端的初始序列号都为0
- 建立连接后，客户端发送第一个报文被网络阻塞，随后进行超时重传。此时服务器宕机重启了，连接已经断开，所以服务器收到重传的报文后回复一个RST报文
- 接着，客户端又与服务器建立与上一个连接相同四元组的连接
- 新连接建立后，被阻塞的数据包刚好到达服务器，此时的序列号刚好在接收窗口内，就会被正常接收，造成数据错乱

（2）为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；
```





### TCP四次挥手

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/03/16164516910506051691050605249Z7due6-format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:50%;" />

```
（1）第一次挥手：客户端发送一个FIN（seq=x）标志的数据包到服务器，用来关闭客户端到服务器的数据传输。然后客户端进入FIN-WAIT-1状态
（2）第二次挥手：服务端接收后发送一个ACK（ACK=x+1）标志的数据包到客户端。服务器进入CLOSE-WAIT状态，客户端收到后进入FIN-WAIT-2状态
（3）第三次挥手：服务端发送一个FIN（seq=y）标志的数据包到客户端，请求关闭连接，然后服务端进入LAST-ACK状态。
（4）第四次挥手：客户端发送ACK（ACK=y+1）标志的数据包到服务器，然后客户端进入TIME-WAIT状态。服务器接收到后进入CLOSE状态。
如果客户端等待2MSL后依旧没有收到回复，证明服务端已经正常关闭，随后客户端也可以关闭连接。

MSL（Maximum Segment Lifetime）是指TCP数据报文在网络中的最长生存时间，通常为2分钟
```

#### 为什么要四次挥手？[x]

```
TCP连接是全双工的，客户端和服务器可以同时发送和接收数据。所以在关闭TCP连接时，一般需要四次挥手来确保双方都能完成数据的传输后在关闭连接

第一次挥手，只能表示客户端不在发送数据但还可以接受数据
服务端在收到FIN报文后，回复一个ACK应答报文，表示已经接受到FIN报文，这是第二次挥手。
但是服务端可能还存在未发送完的数据，所以需要等待发送完后再发送FIN报文，这是第三次挥手
客户端收到FIN报文后，还需要回复一个ACK报文表示收到，这是第四次挥手

【但是在特定情况下，四次挥手是可以变成三次挥手的】
```

#### 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？

```
因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。

【但是在特定情况下，四次挥手是可以变成三次挥手的】
```

#### TCP 四次挥手，可以变成三次吗？[x]

```
关闭过程中，服务端「没有数据要发送」且「开启了TCP延迟确认机制」，那么第二和第三次就会合并传输，这样就会出现三次握手。

https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html#什么情况会出现三次挥手
```

#### 什么是TCP延迟确认机制？[x]

```
当发送没有携带数据的ACK时，它的网络效率是很低的，因为它也有40个字节的IP头和TCP头，但没有携带数据报文。
为了解决ACK传输效率低的问题，所以就衍生出了「TCP延迟确认」

TCP延迟确认策略：
- 当有响应数据要发送时，ACK会随着响应数据一起立刻发送给对方
- 当没有响应数据发送时，ACK会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，这时会立刻发送ACK
```

#### 第一次挥手丢失了，会发生什么？

```
（1）第一次挥手是什么？
（2）会触发超时重传机制重发，每次超时时间是上次的两倍。
（3）如果超过最大重传次数，再等待一段时间仍未收到，则直接进入close状态
```

#### 第二次挥手丢失了，会发生什么？

```
（1）第二次挥手是什么？
（2）ACK是不会触发超时重传的，所以客户端没有收到 ACK 确认，会重新发送 FIN 报文。
（3）如果超过最大重传次数，再等待一段时间仍未收到，就会断开连接
```

#### 第三次挥手丢失了，会发生什么？

```
（1）第三次挥手是什么？
（2）第三次丢失，则服务端收不到ACK报文，就会超时重传FIN报文
（3）如果超过最大重传次数，再等待一段时间仍未收到，服务端就会断开连接
（4）客户端是通过close函数来关闭连接的，处于FIN_WAIT_2状态是有时常限制的，超过指定时间未收到第三次握手，则客户端会断开连接
```

#### 第四次挥手丢失了，会发生什么？

```
（1）第四次挥手是什么？
（2）服务端会重传FIN，超过最大重传次数，再等待一段时间后仍未收到ACK，服务端就会断开连接
（3）客户端在收到第三次挥手时，进入TIME_WAIT状态，开启时常2MSL的定时器。如果中途收到FIN，则重置定时器。超时2MSL后客户端就会断开连接
```

####  为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？[x]

```
【回答下面为什么要有timewait】
MSL是报文最大生存时间。

第四次挥手时，客户端发送的ACK有可能丢失，如果服务端因为某些原因没有收到ACK，服务端就会重发FIN。
如果客户端在2MSL的事件内收到FIN，就会重新发送ACK并再次等待2MSL，防止server没有收到ack而不断重发fin

MSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。
```



### TIME_WAIT

#### 为什么需要 TIME_WAIT 状态？[x]

```
主动发起关闭连接的一方才会有TIME_WAIT状态

主要原因：
（1）防止历史连接中的数据，被后面相同四元组的连接错误的接收
（2）保证「被动关闭连接」的一方，能被正确关闭

四元组：原地址、源端口、目标地址、目标端口
```

防止历史连接中的数据，被后面相同四元组的连接错误的接收

```
（1）序列号和初始序列号并不是无限递增的，会发生会绕为初值的情况，所以无法根据序列号来判断新老数据。
（2）假如在数据传输过程中有数据阻塞在网络中，此时通过四次挥手，不等待2msl就结束连接。
（3）接着，服务端又以相同的四元组重建打开的新的连接，而前面被延迟的报文到达客户端，恰好又在接收窗口范围，那么客户端就会接收，就会产生数据错乱蹬严重问题。
```

保证「被动关闭连接」的一方，能被正确关闭

```
第四次握手的ACK丢失，服务端会重传FIN，假如没有TIME_WAIT状态，那么服务端就无法收到ACK，无法正常关闭连接
```

#### TIME_WAIT 过短有什么危害？

```
同【为什么需要 TIME_WAIT 状态？】
```

#### TIME_WAIT 过多有什么危害？[x]

```
（1）客户端TIME_WAIT过多：占满了所有端口资源，就无法对【目标ip + 目标端口】一样的服务器发起连接，但可以想其他服务器发起连接（端口是可以复用的）
（2）服务端TIME_WAIT过多：并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等

```

#### 服务器出现大量 TIME_WAIT 状态的原因有哪些？[x]

```
首先要知道 TIME_WAIT 状态是「主动关闭连接方才会出现的状态」，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。

什么场景下服务端会主动断开连接呢？
第一个场景：HTTP 没有使用长连接
第二个场景：HTTP 长连接超时
第三个场景：HTTP 长连接的请求数量达到上限
```



#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？[x]

```
发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 ESTABLISH 状态，占用着系统资源。

为了避免这种情况，TCP 搞了个「保活机制」。这个机制的原理是这样的：
定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，服务端发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。
```

#### 如果已经建立了连接，但是服务端的进程崩溃会发生什么？[x]

```
TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。
```



#### 保活计时器的作用

```
同【如果已经建立了连接，但是客户端突然出现故障了怎么办？】

如果tcp三次握手后，客户端出现故障。服务器一直无法接收到数据，也无法知道客户端故障了，就会浪费资源一直等待。

服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两 个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。
```







##  TCP 如何保证传输的可靠性？

```
（1）连接控制：建立连接时通过三次握手建立可靠的传输信道；关闭连接时四次挥手，确保双方完成数据传输和连接关闭。
（2）序列号：TCP将数据分割成小的数据块进行传输，每个数据包中包含序列号，接收方可以根据序列号进行排序以及去重。
（3）确认和超时重传：TCP使用确认机制来保证数据的可靠传输。发送方在发送数据后会等待接收方的确认，如果一段时间内没有收到确认，则认为数据丢失，进行超时重传。
（4）流量控制和拥塞控制：TCP通过流量控制和拥塞控制等机制控制数据的发送速率，避免数据丢失和网络拥塞。
（5）校验和：TCP每个数据包的头部会包含一个校验和，接收方在接收后会再次计算校验和，如果两者不匹配，则说明数据在传输过程中发生了错误，接收方会要求发送发重新发送数据。
```

## 重传机制

### 超时重传

##### 是什么？

```
在发送数据时，设定一个定时器，当超过指定时间后，没有收到对方的ACK确认应答报文，就会重发该数据

+ 「什么时候会超时重传？」
```

##### 什么情况下会超时重传

```
（1）数据包丢失
（2）确认应答丢失

+ 【需要设置合理的超时重传时间】
```

##### 超时时间应该设置为多少？

```
RTT：数据发送时刻 到 接收到确认的时刻 的差值，即包的往返时间
超时重传时间 RTO 的值应该略大于报文往返 RTT 的值，是一个动态变化的值。

+ 「过长/过短的问题？」
```

##### 超时重传时间RT0，较长/较短会有什么问题？

```
（1）RT0较长：重发慢，丢包很丢才重发，没有效率，性能差
（2）RT0较小：会导致并没有丢就重发，于是重发的就很快，会增加网络的拥塞，导致更多的超时，更多的超时就会导致更多的重发
```

### 快速重传

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/30/114645169068880516906888051215oteeh-10.jpg" alt="快速重传机制" style="zoom:50%;" />

```
连续收到三个相同的ack就重传

快速重传解决了超时时间的问题，但是引入了另一个问题：就是重传时重传一个，还是重传所有
（1）重传一个：重传效率低。假如发送seq1-seq6，seq2和seq3都丢失了，收到三个ack2时重传seq2，然后需要再收到三个ack3才会重传seq3
（2）重传所有：传输过的数据需要再重传，浪费资源。发送seq1-seq6，seq2和seq3丢失，seq4-seq6都成功，如果收到三个ack2，重传seq2和后面所有的报文，那么之前传输成功的seq4-seq6就白浪费资源。
```

### 选择重传 SACK [x]

```
需要再头部【选项】字段里添加SACK，它可以将已经接收到的数据的信息发送给发送发，这样发送方就可以知道哪些数据收到了，哪些数据没收到，通过这些信息，就可以只重传丢失的数据。
```

### 冗余ACK重传

```
https://www.xiaolincoding.com/network/3_tcp/tcp_feature.html#duplicate-sack
```



##  TCP 如何实现流量控制？[x]

```
主要是通过滑动窗口来控制发送方的发送速率，确保接收方来得及接收。

（1）发送方和接收方在建立连接时会协商窗口大小（Window Size），即允许接收方缓冲的数据量。这个窗口大小是根据接收方的接收能力和发送方的发送能力进行调整的。
（2）接收方收到数据后，会发送确认（ACK）给发送方，并通知发送方当前的接收窗口大小，表示接收方的缓冲区还有多少可用空间。发送方根据接收方的窗口大小调整发送窗口的大小。
（3）如果发送窗口大小为0，表示接收方的缓冲区已满，发送方会暂停发送数据，等待接收方释放缓冲区空间。

```

## 为什么要流量控制？

```
（1）防止数据丢失：在双方通信时，发送发的速率和接收方的速率不一定相等。
如果发送方发送的太快，会导致接收方处理不过来，从而造成数据丢失
（2）防止网络拥塞：如果发送方过度发送数据，可能会造成网络拥塞，通过控制发送方的速率，来避免这种情况。让发送方和 接收方处于一种动态平衡
```

## 滑动窗口

#### 窗口大小由哪一方决定？[x]

```
通常窗口的大小由接收方的窗口大小来决定。发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

TCP头里有一个字段叫window，也就是窗口大小。
这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送方就根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。
```

### 发送窗口 [x]

```
包含四个部分
（1）发送已确认。已发送并收到 ACK确认的数据
（2）发送未确认。已发送但未收到 ACK确认的数据
（3）可发送。未发送但总大小在接收方处理范围内（接收方还有空间）
（4）不可发送。未发送但总大小超过接收方处理范围（接收方没有空间）
```

### 接收窗口

```
（1）接收已确认
（2）可接收
（3）不可接收
```

### 接收窗口和发送窗口的大小是相等的吗？

```
并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。

滑动窗口大小是动态变化的。会根据接收方的读取数据的速度进行调整，通过TCP报文告诉发送方，这个传输过程是存在延迟的，所以接收窗口和发送窗口是约等于的关系。

```

### 窗口关闭

```
指发送方的窗口为0，发送方不能在给接收方发送数据
```

### 窗口关闭潜在的危险

```
接收方处理完数据后，向发送发通告窗口大小，假如ACK报文丢失，那么发送方窗口将一直为0，无法发送数据，双方进入死锁
```

### TCP 是如何解决窗口关闭时，潜在的死锁现象呢？[x]

```
TCP为每个连接设定一个持续计时器，只要收到零窗口通知，就会启动这个定时器。
如果定时器超时，就会发送窗口探测报文，接收方会在确认报文中给出接收窗口的大小。
如果为0就重启计时器
如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。
```



## 拥塞控制

### 是什么？

```
是为了保护整个网络，控制整个网络的数据流量，避免网络拥塞。主要是由发送方根据网络状态来调整发送速率，以控制整个网络中的数据流量。
```

### 为什么要有拥塞控制呀，不是有流量控制了吗？

```
拥塞控制和流量控制都涉及调整数据传输的速率，但它们的目标和作用是不同的。

流量控制：是为了保护接收方，控制发送方的发送速率，防止发送方发送过多数据，接收方来不及处理而丢失数据。通常由接收方来控制，通过确认消息来告诉发送方自己有多少缓冲区可以接收数据，发送方由此动态调整窗口大小

拥塞控制：是为了保护整个网络，控制整个网络的数据流量，避免网络拥塞。主要是由发送方根据网络状态来调整发送速率，以控制整个网络中的数据流量。
```

### 什么是拥塞窗口？和发送窗口有什么关系呢？[x]

```
拥塞窗口是发送方维护的一个状态变量，是根据网络的拥塞程度动态变化的。
发送方窗口大小 约等于 接收窗口
有了拥塞窗口，发送方的发送窗口大小就是【接收】 和 【拥塞窗口】的最小值

拥塞窗口 cwnd 变化的规则：
- 只要网络中没有出现拥塞，cwnd 就会增大；
- 但网络中出现了拥塞，cwnd 就减少；
```

### 那么怎么知道当前网络是否出现了拥塞呢？

```
发送方在规定时间内没有收到ACK应答报文，发生了超时重传，就认为网络出现了拥塞
```

### 拥塞控制有哪些控制算法？[x]

```
慢启动
拥塞避免
拥塞发生
快速恢复
```

### 慢启动

```
TCP在刚建立完成后，首先有个慢启动的过程，慢启动就是当发送方每收到一个ACK，拥塞窗口cwnd的大小就会+1（翻倍，1 2 4 8...）。

cwnd = 慢启动门限ssthresh，慢启动 或者 拥塞避免
当cwnd > 慢启动门限ssthresh（（slow start threshold））时，就会使用「拥塞避免算法」

指数增长
```

### 拥塞避免算法

```
拥塞窗口超过慢启动门限，就会进入拥塞避免算法。
他的规则是：每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1
随着持续增长，会导致网络拥塞，出现丢包触发重传机制，进入【拥塞发生】阶段

线性增加
```

### 拥塞发生

```
网络拥塞时的重传机制有两种：
（1）超时重传
（2）快速重传
```

#### 超时重传

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/01/112348169086022816908602289542JKWSB-29.jpg" alt="拥塞发送 —— 超时重传" style="zoom:50%;" />

```
发生超时重传时，
慢启动阈值ssthresh = cwnd/2
cwnd重制为初始值
进入慢启动


问题：
偶然的丢包，网络不一定发生拥塞，这时慢启动没有必要。
```

#### 快速重传

```
收到三个相同的ACK就会触发快速重传

拥塞窗口大小cwnd = cwnd/2
慢启动阈值ssthresh = cwnd
进入快速恢复算法
```

教材上的图：[参考](https://fasionchan.com/network/tcp/congestion-control/)

![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/27/17142816931276681693127668404G0Ac21-14133816908704181690870418577PSZWX9-8690627fbee083b1be2cb88eee249f36ee2a9b21.png)



### 快速恢复

小林coding图：（12直接变成了12/2 + 3，跟教材上有区别）

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/01/11291116908605511690860551213fDbe8a-%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png" alt="快速重传和快速恢复" style="zoom:50%;" />

```
快速恢复和快速重传一般同时使用。快速恢复算法任务，还有三个重复ACK收到，说明网络没那么糟糕，所以没必要像超时重传那样直接将拥塞窗口置为初始值

进入快速恢复之前，
cwnd和sshthresh已经被更新

然后真正的快速恢复算法如下：
- cwnd = sshthresh + 3
- 重传丢失的包
- 如果再收到重复的ACK，那么cwnd = cwnd + 1，而不是进一步减小cwnd。能够更快地从网络拥塞中恢复
- 如果收到新数据的ACK后，cwnd = sshthresh。因为收到新数据的ACK，表明恢复过程已经结束，可以再次进入拥塞避免的算法了
```





