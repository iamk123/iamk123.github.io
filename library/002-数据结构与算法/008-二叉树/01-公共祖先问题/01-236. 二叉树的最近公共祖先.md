### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

[参考1:代码随想录](https://programmercarl.com/0236.二叉树的最近公共祖先.html)

[参考2:Labuladong](https://mp.weixin.qq.com/s/njl6nuid0aalZdH5tuDpqQ)



情况1：左子树为p，右子树为q

判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。

![image-20221018135134765](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/18/13513416660722941666072294867gKQGEF-image-20221018135134765.png)

情况2：

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/10/18/135357166607243716660724375217VWQOU-image-20221018135357442.png" alt="image-20221018135357442" style="zoom: 33%;" />



<img src="/Users/kuan/Library/Application%20Support/typora-user-images/image-20221018140701731.png" alt="image-20221018140701731" style="zoom: 33%;" />

<img src="https://img-blog.csdnimg.cn/202102041512582.png" alt="236.二叉树的最近公共祖先2" style="zoom:50%;" />

#### 方法一：后序遍历

通过返回的是不是null来判断，是否找到p 或 q

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
       	return find(root, p, q);
    }
  
  	public TreeNode find(TreeNode root, TreeNode p, TreeNode q) {
      if(root == null) {
            return null;
        }

        if(root == p || root == q) { // 情况二，根节点为p或q
            return root;
        }

        TreeNode left = lowestCommonAncestor(root.left, p, q);      // 左
        TreeNode right = lowestCommonAncestor(root.right, p, q);    // 右

        // 根
        if(left != null && right != null ) {    // 情况一
            return root;
        }
        if(left != null && right == null) {
            return left;
        }
        if(left == null && right != null) {
            return right;
        }

        return null;
    }
}
```

[参考](https://programmercarl.com/0236.二叉树的最近公共祖先.html#java)

写法2

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return traversal(root, p.val, q.val);
    }

    public TreeNode traversal(TreeNode root, int val1, int val2) {
        if(root == null) return null;

        if(root.val == val1 || root.val == val2)  {		// 放在后序位置也行
            return root;
        }

        TreeNode left = traversal(root.left, val1, val2);
        TreeNode right = traversal(root.right, val1, val2);

        if(left != null && right != null) return root;

        return left != null ? left : right;
    }
}
```



###  [1676 题「二叉树的最近公共祖先 IV」](https://mp.weixin.qq.com/s/njl6nuid0aalZdH5tuDpqQ)

多个节点的最近公共祖先，且nodes一定存在二叉树中

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode[] nodes) { 
		HashSet<Integer> hs = new HashSet<>();
  	for(TreeNode node : nodes) {
    		hs.add(node.val);
    }
  
  	return find(root, hs);
}

TreeNode find(TreeNode root, HashSet<Integer> values) {
  	if(root == null) return null;
  	if(values.contains(root.val)) returnn root;
  	TreeNode left = find(root.left, values);
  	TreeNode right = find(root.right, values);
  	
  	// 同上一题
  	if(left != null && right != null) return root;
  	
  	return left != null ? left, right;
}
```



### 1644 题「二叉树的最近公共祖先 II」

找p和q的公共祖先，如果p或q不存在，返回null

```java
boolean findP = false, findQ = false;

TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { 
		TreeNode res = find(root, p.val, q.val);
    if (!foundP || !foundQ) {
        return null;
    }
    // p 和 q 都存在二叉树中，才有公共祖先
    return res;
}

TreeNode find(TreeNode root, int val1, int val2) {
	if(root == null) return null;
  
  TreeNode left = find(root.left, val1, val2);
  TreeNode right = find(root.right, val1, val2);
  
  if(left ！= null && right != null) return root;
  
  // 后序位置，判断当前节点是不是目标值
    if (root.val == val1 || root.val == val2) {
        // 找到了，记录一下
        if (root.val == val1) foundP = true;
        if (root.val == val2) foundQ = true;
        return root;
    }

    return left != null ? left : right;
}
```



### 235 二叉搜索树的最近公共祖先

见7-b28



```

```





### 1650 二叉树的最近公共祖先 III

带父节点的二叉树

将root看成next，就是相交链表的问题

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/02/27/111705167746782516774678255115BRRu5-640.png" alt="图片" style="zoom:50%;" />

```java
Node lowestCommonAncestor(Node p, Node q) {
    // 施展链表双指针技巧
    Node a = p, b = q;
    while (a != b) {
        // a 走一步，如果走到根节点，转到 q 节点
        if (a == null) a = q;
        else           a = a.parent;
        // b 走一步，如果走到根节点，转到 p 节点
        if (b == null) b = p;
        else           b = b.parent;
    }
    return a;
}
```

方式二

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null) {
            return null;
        }
        ListNode a = headA;
        ListNode b = headB;

        while(a != b) {
            a = a == null ? headB : a.next;
            b = b == null ? headA : b.next;
        }
        return a;
    }
}
```

