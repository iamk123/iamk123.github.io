### 方法一： 虚拟头节点+尾指针+头插

思路：采用虚拟头节点dummyHead，尾指针tail记录反转好的尾节点，每次将tail的下一个节点前插到head之前（即dummyHead之后），直到tail的下一个节点为null

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null) return head;
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode tail = head; // 反转后的尾部
        // 每次将cur插到ç
        ListNode cur = tail.next;
        while(cur != null) {
            // 处理cur的next节点
            tail.next = cur.next;

            // cur插到dummyHead后
            cur.next = dummyHead.next;
            dummyHead.next = cur;

            // 更新head 和 tail
            head = cur;
            cur = tail.next;
        }
        return dummyHead.next;
    }
}
```



### 方法二：双指针

```java
public ListNode reverseList(ListNode head) {
    if(head == null) return head;
    ListNode pre = null;
    ListNode cur = head;
    ListNode tmp;
  	while(cur != null) {	
				tmp = cur.next;

        // 翻转	
        cur.next = pre;

        // 前移
        pre = cur;
        cur = tmp;
    }
  	return pre;
}
```

递归

```java
    public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }

    public ListNode reverse(ListNode pre, ListNode cur) {
        if(cur==null) {
            return pre;
        }
        ListNode tmp = cur.next;
        cur.next = pre;

        // 更新pre，cur位置
        // pre = cur;
        // cur = tmp;
        // return reverse(pre, cur);

        // 等效
        return reverse(cur, tmp);
    }
	
	
```

