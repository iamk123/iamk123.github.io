#### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

##### 解法一：双指针

```java
    public int removeElement(int[] nums, int val) {
        int low = 0;
        int high = nums.length - 1;
        while(low <= high) {
            if(nums[low] == val) {
                int tmp = nums[low];
                nums[low] = nums[high];
                nums[high] = tmp;
                high--;
            } else {
                low ++;
            }
        }
        return low;
    }
```

优化：不需要保存=val的nums[low]

```java
    public int removeElement(int[] nums, int val) {
        int low = 0;
        int high = nums.length - 1;
        while(low <= high) {
            if(nums[low] == val) {
                nums[low] = nums[high];
                high--;
            } else {
                low ++;
            }
        }
        return low;
    }
```

##### 解法二：快慢指针

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 快慢指针
        int fastIndex = 0;
        int slowIndex;
        for (slowIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }
}
```

[题解](https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#_27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0)



#### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

**解题思路 - 双指针**：

数组有序，重复元素一定相邻。

删除重复元素 => 将不重复元素移到数组左侧。

考虑双指针：慢指针low 快指针fast

比较low 和 fast位置上的元素

- 如果相等 fast++ （即找到第一个不重复的元素）
- 如果不等，low++，将fast位置的元素复制到low上，fast++

重复，直到q等于数组长度

返回low + 1，即为新数组长度

```java
public int removeDuplicates(int[] nums) {
  if(nums == null || nums.length == 0) return 0;
  int low  = 0;
  int fast = 1;
  while(fast < nums.length) {
    if(nums[low] != nums[fast]) {
      nums[++low] = nums[fast];
    }
    fast++;
  }
  return low + 1;
}
```

**优化**

如果没有重复元素，每次都需要原地替换

```java
public int removeDuplicates(int[] nums) {
  if(nums == null || nums.length == 0) return 0;
  int low  = 0;
  int fast = 1;
  while(fast < nums.length) {
    if(nums[low] != nums[fast]) {
      low++;
      if(low != fast) {
        nums[low] = nums[fast];
      }
    }
    fast++;
  }
  return low + 1;
}
```

[题解](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/)



#### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

**解题思路**

双指针

low指向首个0元素下标，fast找到第1个非0元素，与low交换，low++。

```java
public void moveZeroes(int[] nums) {
        if(nums == null && nums.length == 0) return;
        int low = 0, fast = 0;
        while(fast < nums.length) {
            if(nums[fast] != 0) {
                int tmp = nums[low];
                nums[low] = nums[fast];
                nums[fast] = tmp;
                low++;
            }
            fast++;
        }
    } 
```





#### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

##### **错解**

双指针，p1=0， p2=0，依次比较字符是否相等，如果不相等看下一位是否为‘#’

没有考虑存在s = "ab##", t = "c#d#"

也没考虑s，t不是等长的情况

```java
    public boolean backspaceCompare(String s, String t) {
        int p1 = 0;
        int p2 = 0;
        while(p1 < s.length() && p2 < t.length()) {
            if(s.charAt(p1) != t.charAt(p2)) {
                if(p1 + 1 >= s.length() || p2 + 1 >= t.length()) {
                    return false;
                } 
                if(s.charAt(p1+1) != '#' || t.charAt(p2+1) != '#') {
                    return false;
                }
            }
            p1++;
            p2++;
        }
        return true;
    }
```

##### 解法一：双指针

一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。

从前往后遍历，不太好确定有多少个字符需要被删掉。

从后往前遍历，分别找到第一个需要比较的字符

- 若是#， 则skip++
- 若不是#
  - 若skip > 0, skip--；
  - 若skip = 0, 则找到要比较的字符；

```java
 public boolean backspaceCompare(String s, String t) {
        int i = s.length() - 1;
        int j = t.length() - 1;
        int skip1 = 0;
        int skip2 = 0;
        while(i >= 0 || j >= 0) {
            // 找到s要比较的字符串
            while(i >= 0) {
                if(s.charAt(i) == '#') {
                    skip1++;
                    i--;
                } else if(skip1 > 0) {
                    skip1--;
                    i--;
                } else {
                    break;
                }
            }

            // 找到t要比较的字符串
            while(j >= 0) {
                if(t.charAt(j) == '#') {
                     skip2++;
                     j--;
                } else if(skip2 > 0) {
                    skip2--;
                    j--;
                } else {
                    break;
                }
            }
            if(i >= 0 && j >= 0) {
                if(s.charAt(i) != t.charAt(j)) {
                    return false;
                }
            } else {
                if(i >=0 || j >= 0) {
                    return false;
                }
            }
            i--;
            j--;
        }
        return true;
    }
```

[参考](https://leetcode.cn/problems/backspace-string-compare/solution/shuang-zhi-zhen-bi-jiao-han-tui-ge-de-zi-8fn8/)

##### 解法二：重构字符串

```java
class Solution {
    public boolean backspaceCompare(String S, String T) {
        return build(S).equals(build(T));
    }

    public String build(String str) {
        StringBuffer ret = new StringBuffer();
        int length = str.length();
        for (int i = 0; i < length; ++i) {
            char ch = str.charAt(i);
            if (ch != '#') {
                ret.append(ch);
            } else {
                if (ret.length() > 0) {
                    ret.deleteCharAt(ret.length() - 1);
                }
            }
        }
        return ret.toString();
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

##### 错解

双指针，最大值一定在两端，

仅考虑了[负数 0 正数]的情况，当数组全为负数的时候，错误

```java
    public int[] sortedSquares(int[] nums) {
        int len = nums.length;
        if(nums == null || len == 0) return nums;
        // 平方
        for(int i = 0; i < len; i++) {
            nums[i] = (int)Math.pow(nums[i], 2);
        }
        // 双指针排序
        int low = 0, high = len - 1;
        while(low < high) {
            if(nums[high] >= nums[low]) {
                high--;
                continue;
            } else {
                swap(nums, low, high);
                high--;
            }
        }
        return nums;
    }
```

##### 解法一：双指针

空间复杂度O(n)

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        for (int i = 0, j = n - 1, pos = n - 1; i <= j;) {
            if (nums[i] * nums[i] > nums[j] * nums[j]) {
                ans[pos] = nums[i] * nums[i];
                ++i;
            } else {
                ans[pos] = nums[j] * nums[j];
                --j;
            }
            --pos;
        }
        return ans;
    }
}
```

[参考](https://programmercarl.com/0977.有序数组的平方.html#双指针法)

错解

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int l = 0;
        int r = nums.length - 1;
        while(l <= r) {
            if(nums[r]*nums[r] < nums[l]*nums[l]) {
                swap(nums, l, r);
            }
            nums[r] = nums[r] * nums[r];
            System.out.println(nums[r]);
            r--;
        }

        return nums;
    }

    void swap(int[] nums, int a, int b) {
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}

// [-5,-3,-2,-1]
Output： [1,9,4,25]
Expected： [1,4,9,25]
```



#### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

##### 方法一：暴力解法

从头开始遍历，以每个元素为起点，寻找符合条件的子序列

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int minLen = Integer.MAX_VALUE;  // 结果
        for(int i = 0; i < nums.length; i++) {
            int sum = 0;	// 子序列之和
            for(int j = i; j < nums.length; j++) {
                sum += nums[j];
                if(sum >= target) {
                    minLen = Math.min(minLen, j - i + 1);
                    break;
                }
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```

问题：数组长度很大时超时

[参考](https://programmercarl.com/0209.长度最小的子数组.html#暴力解法)

##### 方法二：双指针-滑动窗口

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int minLen = Integer.MAX_VALUE;
        int i = 0, j = 0;	// 滑动窗口左、右指针
        int sum = 0;  // i ~ j 之间的和
        while(j < nums.length) {
            sum += nums[j];
            while(sum >= target) {	// 尽可能右移左指针
                minLen = Math.min(minLen, j - i + 1);
                sum -= nums[i];
                i++;
            }
            j++;
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```

[参考](https://programmercarl.com/0209.长度最小的子数组.html#相关题目推荐)



#### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

从左至右，从上到下，从右到左，从下到上，每次以左闭右开的原则赋值，循环。

![螺旋矩阵](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2022/07/09/105224165733514416573351443552eUM3g-2020121623550681.png)

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int loop = 0;    // 循环次数
        int start = 0;   // 每次循环的开始点(start, start)
        int count = 1;   // 定义填充数字
        int i, j;

        while(loop++ < n / 2) {  // 判断边界后，loop从1开始
            // 上侧 左=>右 y轴start不变
            for(i = start; i < n - loop; i++) {
                res[start][i] = count++;
            }
            // 右侧 上=>下 x轴j不变
            for(j = start; j < n - loop; j++) {
                res[j][i] = count++;
            }
            // 下侧 右=>左 y轴j不变
            for(; i >= loop; i--) {
                res[j][i] = count++;
            }
            // 左侧 下=>上 x轴i不变
            for(; j >= loop; j--) {
                res[j][i] = count++;
            }
            start++;
        }
        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if(n % 2 == 1) {
            res[start][start] = count;
        }
        return res;
    }
}
```

[题解](https://programmercarl.com/0059.螺旋矩阵II.html#_59-螺旋矩阵ii)