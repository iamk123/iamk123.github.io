### [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)

### [剑指 Offer 49. 丑数](https://leetcode.cn/problems/chou-shu-lcof/)

我们可以把丑数分为三类：2 的倍数、3 的倍数、5 的倍数。这三类丑数就好像三条有序链表，如下：

(注意是没有7x2、7x3、7x5的，7不是丑数，所以每条链上并不是简单的每次都乘2、3、5，丑数 III才是)

```
能被 2 整除的丑数：
1*2 -> 2*2 -> 3*2 -> 4*2 -> 5*2 -> 6*2 -> 8*2 ->...
能被 3 整除的丑数：
1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 8*3 ->...
能被 5 整除的丑数：
1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 8*5 ->...
```

我们如果把这三条「有序链表」合并在一起并去重，得到的就是丑数的序列，其中第`n`个元素就是题目想要的答案：

```
1 -> 1*2 -> 1*3 -> 2*2 -> 1*5 -> 3*2 -> 4*2 ->...
```



```java
class Solution {
    // 理解为三个有序链表合并
    public int nthUglyNumber(int n) {
        int p2 = 1, p3 = 1, p5 = 1;     // 理解为三个链表头指针
        int v2 = 1, v3 = 1, v5 = 1;     // 三个链表对应值

        int[] ugly = new int[n + 1];    // 理解为合并的链表
        int p = 1;                      // 合并链表指针

        // 合并链表
        while(p <= n) {
            int min = Math.min(v2, Math.min(v3, v5));
            ugly[p] = min;
            p++;

            // 前进对应有序链表上的指针
            if(min == v2) {             // 链表2的节点为1 2 4 8 ...
                v2 = 2 * ugly[p2];
                p2++;
            }

            if(min == v3) {             // 链表3的节点为1 3 6 9 ...
                v3 = 3 * ugly[p3];
                p3++;
            }

            if(min == v5) {             // 链表5的节点为1 5 10 15 ...
                v5 = 5 * ugly[p5];
                p5++;
            }
        }

        return ugly[n];
    }
}
```