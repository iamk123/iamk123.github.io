## 事物有哪些特性 ACID

```
（1）原子性（Atomicity）：事务是最小的执行单位。一个事务中的所有操作，要么都执行，要么都不执行。发生错误时会进行回滚
（2）一致性（Consistency：执行事务前后，数据保持一致。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
（3）隔离性（Isolation）：并发访问数据库时，一个用户的事务不会被其他事物所干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。
（4）持久性（Durability）：事务处理结束后，对数据的修改是永久的，即使系统故障也不会丢失。
```

## InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？[x]

```
原子性是通过 「undo log（回滚日志）」 来保证的；
持久性是通过 「redo log （重做日志）」来保证的；
隔离性是通过 「MVCC（多版本并发控制）」 或「锁机制」来保证的；
一致性则是通过「持久性」+「原子性」+「隔离性」来保证；
```

## 并发事务会引发什么问题？

```
脏读、不可重复读、幻读
```

### 脏读

```
一个事务读到其他事务未提交的数据
```

出现场景

```
事务A对数据进行修改还未提交，事务B读取这条数据，此时事务A进行了回滚,
```

### 不可重复读

```
在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。
```

出现场景

```
事务A读取某条数据，此时事务B更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。
```

### 幻读

```
一个事务，查询条件相同，先后读取数据的数量不一致
```

出现场景

```
事务A读取某个范围内的数据，事务B在这个范围内添加/删除数据，事务A再次读取时，查询的数量会不一致
```

### 丢失修改

```
事务A修改某条数据未提交前，事务B也对这条数据进行了修改并提交，此时事务A进行提交，事务A的修改就会丢失。
```

### 不可重复读和幻读有什么区别？

```
不可重复读是对某一条数据 多次读取不一致
幻读是对某一个范围内的数据 多次读取不一致

幻读是不可重复读的一种特殊情况，单独区分是因为解决方法不同。
```

## 并发事务的控制方式有哪些？ TODO

```
锁和mvcc
https://javaguide.cn/database/mysql/mysql-questions-01.html#并发事务的控制方式有哪些
```



## 事务的隔离级别

### 有哪些？

```
（1）读未提交：可以读取未提交事务。可能导致脏读、幻读、不可重复读
（2）读提交：指一个事务提交之后，它做的变更才能被其他事务看到；可能导致幻读、不可重复读
（3）可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；可能导致幻读 【具体原因见方法】
（4）串行化：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/100133169154649316915464935760bAug5-4e98ea2e60923b969790898565b4d643.png" alt="图片" style="zoom:50%;" />

### 可重复读很大程度上解决了幻读问题，是怎么解决的？[x]

```
（1）针对「快照读」（普通select语句），通过「mvcc」方式解决：
    事务启动后，会创建一个读取视图（read view），该视图包含了事务开始时数据库中的所有数据。在事务执行期间，其他事务对数据的修改
是查询不出来的。

（2）针对「当前读」（select...for update等语句），通过「next-key lock(记录锁+间隙锁)」方式解决。
		因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

【SELECT ... FOR UPDATE 是一种用于在事务中对数据行进行加锁的语句】
```

#### 快照读是如何避免幻读的？

```
实现方式：undo log + mvcc

可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，该视图包含了事务开始时数据库中的所有数据。在事务执行期间，每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。
```

#### 当前读是如何避免幻读的？

```
什么是当前读？
MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。
这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。

通过添加next-key lock解决
```

### MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？

```
在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。

https://xiaolincoding.com/mysql/lock/lock_phantom.html#加锁分析
```



### 可重复读中幻读被完全解决了吗？

```
可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读。

https://www.xiaolincoding.com/mysql/transaction/phantom.html
```

场景1:

```
事务A查询某个范围内的数据，事务B在这个范围内添加一条数据，此时事务A是看不到的。
如果事务A去更新这个记录，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/10402916915488291691548829458XOS6lA-%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img" style="zoom: 67%;" />

场景2

```
T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。
T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；
T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。

要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。
```

### MySQL 的隔离级别是怎么实现的？

```
MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。

（1）「串行化」 隔离级别是通过锁来实现的，
（2）「提交读」和 「可重复读」隔离级别是基于 MVCC 实现的。不过， 「串行化」 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。

https://javaguide.cn/database/mysql/mysql-questions-01.html#sql-标准定义了哪些事务隔离级别
```

### 这四种隔离级别具体是如何实现的呢？？？[x]

```
（1）对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
（2）对于「串行化」隔离级别的事务来说，通过加「读写锁」的方式来避免并行访问；
（3）对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同；
		- 读提交：在「每个语句执行前」都会重新生成一个 Read View。也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
		- 可重复读： 是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。这样就保证了在事务期间读到的数据都是事务启动前的记录。
```

### 启动事务的方式

```
两种方式：
第一种：begin/start transaction 命令：执行后并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；
第二种：start transaction with consistent snapshot 命令：就会马上启动事务。
```

## MVCC？*

```
https://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-在-mvcc-里如何工作的
```
### 是什么

```
Mvcc是多版本并发控制，保证了事务之间的隔离性，事务只能看到自己已经提交的数据版本，从而保证了数据的一致性，并且避免了事务读写并发问题
```

### 原理

```
read view有四个重要的字段：
（1）creator_trx_id: 创建该readview的的事务的事务id
（2）m_ids: 创建readView时，数据库中「活跃事务」的事务id列表（活跃事务指启动但未提交的事务）
（3）min_trx_id: m_ids的最小值
（4）max_trx_id: 创建readView时当前数据库中应该给下一个事务的id值，即m_ids的最大值+1
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/13493616915601761691560176829NlsMaT-readview%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom:50%;" />

```
聚簇索引中的两个隐藏列
（1）trx_id: 当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；
（2）roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。
```

```
可重复读隔离级别下，执行第一个select查询时会创建Read View，整个事务期间都在使用这个Read View。
读提交隔离级别下，每次select查询，都会创建一个新的Read View

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：
（1）trx_id < min_trx_id, 则该条记录对当前事务「可见」。表示这个版本的记录是在创建 Read View 前已经提交的事务生成的
（2）trx_id >= max_trx_id, 则该条记录对当前事务「不可见」。表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。
（3）处于之间，则判断trx_id是否在m_ids里：	？？？（应该是可重复读 和 读提交会有区别，不在列表中只会在读提交中出现，每次都会创建新的readview）
		- 在列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务「不可见」。
		- 不在列表中，表示生成该版本记录的活跃事务已经被提交，则对当前事务「可见」。
		
这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。
```



## 可重复读是如何工作的？

```
https://xiaolincoding.com/mysql/transaction/mvcc.html#可重复读是如何工作的
```

```
例子：事务A启动，接着B也跟着启动
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/14125216915615721691561572562VsQsN0-%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png" alt="img" style="zoom:50%;" />

```
操作流程 & 现象：
事务 B 读取小林的账户余额记录，读到余额是 100 万；
事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；
事务 B 读取小林的账户余额记录，读到余额还是 100 万；
事务 A 提交事务；
事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；
```
流程分析
```
分析，B三次读取时为什么都能读到100:
（1）第一次：该条记录的trx_id = 50, 小于事务B的活跃事务m_ids，表示在事务启动前就提交，所以该版本记录对B可见
（2）第二次：
		- A修改但未提交，mysql会记录相应的undolog，并以链表的形式串联起来，形成「版本链」，然后修改该条记录的trx_id=51。
		- B此时去读，发现trx_id=51，在自己的活跃事务m_ids里。说明这条记录被修改但未提交。所以不会读取该记录，而是沿着undolog链条找旧版本的记录，找到第一条小于事务B的min_trx_id(即在活跃事务m_ids左侧)，即trx_id=50的记录
（3）第三次：事务A已经提交，但是事务B用的启动事务时创建的readview，所以修改依旧不可见。
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/14171816915618381691561838130jD2AHR-image-20230809141717983.png" alt="image-20230809141717983" style="zoom:50%;" />

## 读提交是如何工作的？

```
https://xiaolincoding.com/mysql/transaction/mvcc.html#读提交是如何工作的
```

```
操作流程 & 现象：
事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；
事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；
事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；
事务 A 提交事务；
事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；
```

流程分析

```
与「可重复读事务」的区别在第三次：
「读提交」每次创建时，都会创建一个新的readview，所以事务A提交后，B再去读，会新建一个视图，提交后的数据对B来说是可见的
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/09/14431816915633981691563398800novU0H-%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A12.drawio.png" alt="img" style="zoom:50%;" />



## 更新是如何保证一致的？

```
更新属于当前读，会加X型的行级锁，是通过锁来保证一致性的。

比如，事务 A 执行对一条 id = 1 的记录进行了更新，其他事务如果想更新或者删除这条记录的话，会发生阻塞，只有当事务 a 提交了事务才会释放锁。
```

