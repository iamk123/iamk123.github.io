## MySQL 有哪些锁？

```
根据加锁的范围, 分为：
- 全局锁、
- 表级锁: 意向锁、自增锁、共享锁/排他锁
- 行级锁：记录锁、间隙锁、临键锁、共享锁/排他锁
```

### 全局锁

#### 如何使用？

```
flush tables with read lock		// 整个数据库就处于只读状态了。
unlock tables		// 解锁，当会话断开了，全局锁也会被自动释放。
```

#### 全局锁应用场景是什么？

```
全库逻辑备份
```

#### 加全局锁又会带来什么缺点呢？

```
数据库都是只读状态，如果数据库里有很多数据，备份就会花费很多的时间。
关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。
```

#### 使用全局锁会影响业务，那有什么其他方式可以避免？[x]

```
如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。

MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法
```

### 表级锁

#### MySQL 表级锁有哪些？具体怎么用的

```
表锁；
元数据锁（MDL）;
意向锁；
AUTO-INC 锁；
```

#### 表锁

```
共享锁（读锁）：一个客户加了读锁，其他可以加读锁，不可以加写锁
排他锁（写锁）：加了写锁，就不能加读锁 或 写锁
```

#### 元数据锁（MDL）

```

```

#### 意向锁

```
意向锁快速判断是否可以对某个表使用表锁，而不用逐行遍历

意向锁是表级锁，共有两种
（1）意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。
（2）意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。
```

意向锁之间是互相兼容的。

|       | IS 锁 | IX 锁 |
| ----- | ----- | ----- |
| IS 锁 | 兼容  | 兼容  |
| IX 锁 | 兼容  | 兼容  |

「意向锁」和「共享锁、排它锁」互斥（这里指的是表级别的共享锁和排他锁，不会与行级的共享锁和排他锁互斥）。

|      | IS 锁 | IX 锁 |
| ---- | ----- | ----- |
| S 锁 | 兼容  | 互斥  |
| X 锁 | 互斥  | 互斥  |

####  自增锁（AUTO-INC锁）

```
一个事务插入的数据中有自增列表时，就会获取自增锁，获取不到就阻塞，等待插入语句执行完后才释放锁，以保证插入数据时是连续递增的。
大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

优化：
MySQL 5.1.22，InnoDB 存储引擎提供了一种「轻量级的锁」来实现自增。
插入的数据中有自增列表时，就会获取轻量级的锁，给该字段赋值完后就会释放
```

### 行级锁

#### 行级锁有哪些种类？

```
不同隔离级别下，行级锁的种类是不同的。
（1）读提交：记录锁
（2）可重复读：
		- 记录锁 Record Lock：
		- 间隙锁 Gap Lock：
		- 临键锁 Next-Key Lock：
	
```

#### Record Lock

```
记录锁，锁住的是一条记录。

记录锁是有 S 锁和 X 锁之分的：
- 一个事务对一条记录加了S锁，其他事务可以加S锁，但不能加X锁
- 一个事务对一条记录加了X锁, 其他事务既不能加S锁，也不能加X锁

事务commit后，锁释放
```

#### Gap Lock

```
间隙锁，锁定一个范围，不包括记录本身。
只存在于「可重复读隔离级别」，目的是为了解决可重复读隔离级别下幻读的现象。

如表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。

间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。
```

#### Next-Key Lock

```
临键锁，是「记录锁」+「间隙锁」的组合，锁定一个范围，并且锁定记录本身。

表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。

如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。
```

#### 插入意向锁

```

```

## 表级锁和行级锁了解吗？有什么区别？

```
（1）表级锁：
		粒度比较大的锁，它锁定整个表，当一个事务获得了某个表的锁后，其他事务就不能对该表进行任务操作。所以，并发效率极低，锁冲突概率也很高
（2）行级锁：
		粒度较小，只会锁定特定行（一行或多行），其他事务可以操作其他行。所以并发性相对较高，可能会出现死锁
```

## 共享锁和排他锁

```
不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）

（1）共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
（2）排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）

```

## 当前读和快照读有什么区别？

当前读：

```
读取最新版本数据，并对读取的记录加锁，阻塞其他事务同时改动相同记录，避免出现安全问题。

select...lock in share mode (共享读锁)
select...for update
update , delete , insert
```

快照读

```

```

## MySQL 是怎么加锁的？

### 什么 SQL 语句会加行级锁？

```
InnoDB 引擎是支持行级锁的， MyISAM 引擎并不支持行级锁

（1）普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。
（2）可以用「锁定读」在查询时对记录加行级锁

  // 对读取的记录加共享锁(S型锁)
  select ... lock in share mode;
  //对读取的记录加独占锁(X型锁)
  select ... for update;
  
（3）update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/10231716916341971691634197297eYLxWQ-x%E9%94%81%E5%92%8Cs%E9%94%81.png" alt="img" style="zoom: 67%;" />

## MySQL 是怎么加行级锁的？TODO

```
不同的场景，加锁的形式是不同的
加锁的对象是索引，加锁的基本单位是 next-key lock，在能使用「记录锁」或者「间隙锁」就能避免幻读现象的场景下， next-key lock 就会退化成「记录锁」或「间隙锁」。

https://xiaolincoding.com/mysql/lock/how_to_lock.html#mysql-是怎么加行级锁的
```

### 唯一索引等值查询

```
（1）当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。
（2）当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」
```

### 唯一索引范围查询

```

```

## update 没加索引会锁全表？

```
(不带索引就是全表扫扫描，也就是表里的索引项都加锁，相当于锁了整张表，并不是表锁)

在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁

比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁（锁是加在索引上）。
update socre = 100 where id = 1

但是，在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。只能用select ... from
update socre = 100 where name = "xxx"
```





## MySQL 死锁了，怎么办？TODO

```
https://xiaolincoding.com/mysql/lock/deadlock.html#死锁的发生
```

### 死锁的发生

```
事务A，需要插入订单1007
事务B，需要插入订单1008
插入前两个事务都进行了「当前读」操作，判断订单是否存在
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/14032516916474051691647405423hZW5el-90c1e01d0345de639e3426cea0390e80.png" alt="img" style="zoom:67%;" />

## 加了什么锁，导致死锁的？TODO

```
https://xiaolincoding.com/mysql/lock/show_lock.html
```

## MySQL死锁怎么避免？（或者说怎么处理MySQL死锁）[*]

```
死锁的四个必要条件：互斥、占有且等待、不可强占用、循环等待。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。

在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：
（1）设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。

（2）开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。
```







## [乐观锁 & 悲观锁](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487996&idx=1&sn=cafae3423e5ffa903a0c0a94a355f981&source=41#wechat_redirect) [*]

### 乐观锁

是什么

```
它假设冲突很少发生，所以它不会阻止其他线程进行读写操作。而是在数据更新时，检查数据是否被其他线程更改
```

实现方式

```
乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用。

（1）版本号：为数据库表添加一个版本号字段。当读取数据时，将版本号一起读出，数据每更新一次，对应的版本号就加一。当提交事务时检查版本号是否改变，如果版本号发生了变化，说明数据已经被其他事务更新，当前事务会回滚。

（2）时间戳：与版本号类似，但是使用数据的时间戳来判断数据是否有变化。
```

使用场景

```
读多写少
```



### 悲观锁

是什么

```
每次读取数据时，都认为其他线程会修改数据，因此在数据被读取出来的整个过程中，都将数据锁定，其他线程不能对其进行修改。
```

实现方式

```
数据库层面的行锁、表锁等，例如：SELECT ... FOR UPDATE。
在程序中使用synchronized或ReentrantLock等锁机制。
```

使用场景

```
写多读少
```



## select for update 有什么含义，会锁表还是锁行还是其他

```
select 查询语句是不会加锁的，但是 select for update 除了有查询的作用外，会加锁，而且它是悲观锁哦。
至于加了是行锁还是表锁，这就要看是不是用了索引/主键。 没用索引/主键的话就是表锁，否则就是是行锁。
```





## 一条SQL是如何加锁的呢？

[参考](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247499275&idx=1&sn=ca72f48a290e4fd2a2ded6ef6fd045be&chksm=cf222122f855a8347b911352cebdd722b17ea45733b91ff169353c0805d9f31cea5261ef01b9&token=1712314640&lang=zh_CN#rd)



RC（读已提交）隔离级别

```
（1）查询条件是主键 
delete from t1 where id = 6
只需要将主键上id = 6的记录，加上X锁即可。

（2）查询条件是唯一索引
delete from t2 where id = 6;
该SQL需要加两个X锁，一个对应于id 唯一索引上的id = 6的记录，另一把锁对应于聚簇索引上的[name=’b’,id=6]的记录。

（3）查询条件是普通索引 
若id列是普通索引，那么对应的所有满足SQL查询条件的记录，都会加上锁。同时，这些记录对应主键索引，也会上锁。

（4）查询条件列无索引
若id列上没有索引，MySQL会走聚簇索引进行全表扫描过滤。每条记录都会加上X锁。
但是，为了效率考虑，MySQL在这方面进行了改进，在扫描过程中，若记录不满足过滤条件，会进行解锁操作。
```

RR（可重复读）隔离级别

```
（1）查询条件是主键
delete from t1 where id = 6;，
在id = 6这条记录上加上X锁。

（2）查询条件是唯一索引
delete from t1 where id = 6;，
唯一索引满足条件的加X锁
对应的主键索引上加X锁

（3）查询条件是普通索引
update t5 set d=d+1 where c = 10
对普通索引上加X锁，间隙锁
对主键索引上加X锁

（4） 查询条件列无索引
update t5 set d=d+1 where c = 10
主键索引的所有记录，都将加上X锁，每条记录间也都加上间隙Gap锁
但是为了效率考虑，MySQL做了一些优化，对于不满足条件的记录，MySQL提前释放锁，同时Gap锁也会释放
```

普通索引

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/20/11271616951804361695180436761aHCBsA-640-20230920112716678.png" alt="图片" style="zoom:50%;" />

无索引

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/20/11265616951804161695180416278f2y4fO-640.png" alt="图片" style="zoom:50%;" />



## 加锁的规则

[参考](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247499275&idx=1&sn=ca72f48a290e4fd2a2ded6ef6fd045be&chksm=cf222122f855a8347b911352cebdd722b17ea45733b91ff169353c0805d9f31cea5261ef01b9&token=1712314640&lang=zh_CN#rd)



**RC隔离级别**

```
加的排他锁（X锁），是比较好理解的，哪里更新就锁哪里
```

**RR隔离级别**

```
首先MySQL的版本，是5.x 系列 <=5.7.24，8.0 系列 <=8.0.13。
加锁规则一共包括：两个原则、两个优化和一个bug（原则3）。

（1）原则1：加锁的基本单位都是next-key lock。next-key lock（临键锁）是前开后闭区间。
（2）原则2：查找过程中访问到的对象才会加锁。
（3）优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁
（4）优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁（Gap lock）。
（5）原则3：唯一索引上的范围查询会访问到不满足条件的第一个值为止。
```

例子

```sql
CREATE TABLE t5 ( 
  id int(11) NOT NULL, 			// 主键索引
  c int(11) DEFAULT NULL, 	// 普通索引
  d int(11) DEFAULT NULL,		// 无索引
  PRIMARY KEY (id), 
  KEY c (c)
) ENGINE=InnoDB;
insert into t5 values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);


（1）等值查询间隙锁
update t5 set d = d+1 where id = 6
- 原则1:（5，10]加 临键锁
- 优化2: 退化为间隙锁，对（5，10）加锁

（2）非唯一索引等值锁
select id from t5 where c = 5 lock in share mode;
- 原则1: 对（0，5]加 临键锁
- c 只是普通索引，访问5后会继续向右遍历，查找10才结束。根据原则2，对(5,10]加 临键锁
- 优化2: (5,10]退化为 间隙锁
- 索引覆盖，所以不会对主键索引加锁
        
（3）主键索引范围锁
select * from t5 where id>=10 and id<11 for update;
- 先找到10，原则1，对(5, 10]加临键锁
- id是唯一索引，所以退化成记录锁，只对id=10加锁
- 范围查找找到id=15停下，因此需要对（10. 15]加临键锁
              
（4）非唯一索引范围锁
select * from t5 where c >= 10 and c < 11 for update;
- 先找到10，原则1，对(5, 10]加临键锁
- 因为等值查询但不是唯一索引，所以不会退化为记录锁，还是对(5, 10]加临键锁
- 范围查找找到id=15停下，因此需要对（10. 15]加临键锁
                               
（5）唯一索引范围锁bug
select * from t5 where id > 10 and id <= 15 for update;
- 等值查询先找到id=15，对（10， 15]加临键锁
- 唯一索引上的范围查询会访问到不满足条件的第一个值为止。所以会找到id=20，就会对（15，20]加临键锁
  
（6）普通索引上存在"等值"的例子
添加数据insert into t5 values(0,0,0),(5,5,5),(10,10,10),(28,10,66),(15,15,15),(20,20,20);
执行select * from t5 where c=10 for update;
- 先找到第一个c=10, 所以对（5,10]加临键锁
- 再向后找，直到找到c=15不满足时停下,所以会对(id=10,c=10)~(id=15,c=15)加临键锁，退化为间隙锁
- 所以整个锁的范围是（5，15），如图1
     
（7）limit 语句减少加锁范围
 Select * from t5 where c=10 limit 2 for update; 
- 先找到第一个c=10, 所以对（5,10]加临键锁
- 再向后找，找到id=28,c=10这条记录已经满足limit2，停下
- 整个锁的范围（5，28），如图2                         
```

图1:<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/20/15322416951951441695195144766Oy3fC5-640-20230920153224680.png" alt="图片" style="zoom:50%;" />

图2：<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/20/15315816951951181695195118872jft0OP-640-20230920153158771.png" alt="图片" style="zoom:50%;" />
