## MySQL 有哪些锁？

```
根据加锁的范围, 分为：
- 全局锁、
- 表级锁: 表锁、意向锁、自增锁
- 行级锁：记录锁、间隙锁、临键锁
```

### 全局锁

#### 如何使用？

```
flush tables with read lock		// 整个数据库就处于只读状态了。
unlock tables		// 解锁，当会话断开了，全局锁也会被自动释放。
```

#### 全局锁应用场景是什么？

```
全库逻辑备份
```

#### 加全局锁又会带来什么缺点呢？

```
数据库都是只读状态，如果数据库里有很多数据，备份就会花费很多的时间。
关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。
```

#### 使用全局锁会影响业务，那有什么其他方式可以避免？[x]

```
如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。

MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法
```

### 表级锁

#### MySQL 表级锁有哪些？具体怎么用的

```
表锁；
元数据锁（MDL）;
意向锁；
AUTO-INC 锁；
```

#### 表锁

```
共享锁（读锁）：一个客户加了读锁，其他可以加读锁，不可以加写锁
排他锁（写锁）：加了写锁，就不能加读锁 或 写锁
```

#### 元数据锁（MDL）

```

```

#### 意向锁

```
意向锁快速判断是否可以对某个表使用表锁，而不用逐行遍历

意向锁是表级锁，共有两种
（1）意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。
（2）意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。
```

意向锁之间是互相兼容的。

|       | IS 锁 | IX 锁 |
| ----- | ----- | ----- |
| IS 锁 | 兼容  | 兼容  |
| IX 锁 | 兼容  | 兼容  |

「意向锁」和「共享锁、排它锁」互斥（这里指的是表级别的共享锁和排他锁，不会与行级的共享锁和排他锁互斥）。

|      | IS 锁 | IX 锁 |
| ---- | ----- | ----- |
| S 锁 | 兼容  | 互斥  |
| X 锁 | 互斥  | 互斥  |

####  自增锁（AUTO-INC锁）

```
一个事务插入的数据中有自增列表时，就会获取自增锁，获取不到就阻塞，等待插入语句执行完后才释放锁，以保证插入数据时是连续递增的。
大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

优化：
MySQL 5.1.22，InnoDB 存储引擎提供了一种「轻量级的锁」来实现自增。
插入的数据中有自增列表时，就会获取轻量级的锁，给该字段赋值完后就会释放
```

### 行级锁

#### 行级锁有哪些种类？

```
不同隔离级别下，行级锁的种类是不同的。
（1）读提交：记录锁
（2）可重复读：
		- 记录锁 Record Lock：
		- 间隙锁 Gap Lock：
		- 临键锁 Next-Key Lock：
	
```



#### Record Lock

```
记录锁，锁住的是一条记录。

记录锁是有 S 锁和 X 锁之分的：
- 一个事务对一条记录加了S锁，其他事务可以加S锁，但不能加X锁
- 一个事务对一条记录加了X锁, 其他事务既不能加S锁，也不能加X锁

事务commit后，锁释放
```

#### Gap Lock

```
间隙锁，锁定一个范围，不包括记录本身。
只存在于「可重复读隔离级别」，目的是为了解决可重复读隔离级别下幻读的现象。

如表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。

间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。
```

#### Next-Key Lock

```
临键锁，是「记录锁」+「间隙锁」的组合，锁定一个范围，并且锁定记录本身。

表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。

如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。
```

#### 插入意向锁

```

```

## 表级锁和行级锁了解吗？有什么区别？

```
（1）表级锁：
		粒度比较大的锁，它锁定整个表，当一个事务获得了某个表的锁后，其他事务就不能对该表进行任务操作。所以，并发效率极低，锁冲突概率也很高
（2）行级锁：
		粒度较小，只会锁定特定行（一行或多行），其他事务可以操作其他行。所以并发性相对较高，可能会出现死锁
```

## 共享锁和排他锁

```
不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）

（1）共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
（2）排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）

```

## 当前读和快照读有什么区别？

当前读：

```
读取最新版本数据，并对读取的记录加锁，阻塞其他事务同时改动相同记录，避免出现安全问题。

select...lock in share mode (共享读锁)
select...for update
update , delete , insert
```

快照读

```

```

## MySQL 是怎么加锁的？

### 什么 SQL 语句会加行级锁？

```
InnoDB 引擎是支持行级锁的， MyISAM 引擎并不支持行级锁

（1）普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。
（2）可以用「锁定读」在查询时对记录加行级锁

  // 对读取的记录加共享锁(S型锁)
  select ... lock in share mode;
  //对读取的记录加独占锁(X型锁)
  select ... for update;
  
（3）update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/10231716916341971691634197297eYLxWQ-x%E9%94%81%E5%92%8Cs%E9%94%81.png" alt="img" style="zoom: 67%;" />

## MySQL 是怎么加行级锁的？TODO

```
不同的场景，加锁的形式是不同的
加锁的对象是索引，加锁的基本单位是 next-key lock，在能使用「记录锁」或者「间隙锁」就能避免幻读现象的场景下， next-key lock 就会退化成「记录锁」或「间隙锁」。

https://xiaolincoding.com/mysql/lock/how_to_lock.html#mysql-是怎么加行级锁的
```

### 唯一索引等值查询

```
（1）当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。
（2）当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」
```

### 唯一索引范围查询

```

```

## update 没加索引会锁全表？

```
(不带索引就是全表扫扫描，也就是表里的索引项都加锁，相当于锁了整张表，并不是表锁)

在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁

比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁（锁是加在索引上）。
update socre = 100 where id = 1

但是，在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。只能用select ... from
update socre = 100 where name = "xxx"
```





## MySQL 死锁了，怎么办？TODO

```
https://xiaolincoding.com/mysql/lock/deadlock.html#死锁的发生
```

### 死锁的发生

```
事务A，需要插入订单1007
事务B，需要插入订单1008
插入前两个事务都进行了「当前读」操作，判断订单是否存在
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/10/14032516916474051691647405423hZW5el-90c1e01d0345de639e3426cea0390e80.png" alt="img" style="zoom:67%;" />

## 加了什么锁，导致死锁的？TODO

```
https://xiaolincoding.com/mysql/lock/show_lock.html
```

