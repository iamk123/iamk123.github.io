## 什么是索引？

```
（1）索引是一种用于快速查询和检索数据的数据结构，形象的说就是索引是数据的目录。
（2）一般存储在磁盘的文件中，会占用物理空间
（3）适当的索引可以提高查询效率，过多的索引会导致效率下降，增加内存使用。

索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。
在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。
```

## 索引的优缺点

```
优点：
（1）主要原因：可以大大加快数据的检索速度
（2）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性

缺点：
（1）耗费时间：创建索引和维护索引需要耗费时间。当对表中数据进行增删改时，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率
（2）耗费空间：索引需要使用物理文件存储，会耗费一定的空间
```

## 创建索引的原则

```
（1）最左前缀匹配原则
（2）频繁作为查询条件的字段才去创建索引
（3）频繁更新的字段不适合创建索引
（4）索引列不能参与计算，不能有函数操作
（5）优先考虑扩展索引，而不是新建索引，避免不必要的索引
（6）区分度低的数据列不适合做索引列(如性别）
（7）定义有外键的数据列一定要建立索引。
（8）对于定义为 text、image 数据类型的列不要建立索引。 
（9）删除不再使用或者很少使用的索引
```

## 如何创建索引

```sql
（1）创建表时建索引
crete table 'employee'(
 `id` int(11) not null,
 `name` varchar(255) default null
 key 'idx_name' ('name') using BTREE
) Engine=InnoDB default charset=utf8;

（2）使用 ALTER TABLE 命令添加索引
ALTER TABLE table_name ADD INDEX index_name (column);

（3）使用 CREATE INDEX 命令创建
CREATE INDEX index_name ON table_name (column);
```



## 索引底层数据结构选型

### Hash表

```
哈希表是键值对集合，检索的速度很快。
但是Hash可能会存在hash冲突，需要链地址等方法来解决
不选择hash表作为索引的主要原因是：hash索引不支持顺序和范围查询
```

### 二叉查找树(BST)

```
（1）是一种基于二叉树的数据结构，它的左子树 < 根 < 右子树，
（2）当二叉查找树平衡时，查找效率比较高，为log2（N），但特殊情况下会退化成链表，时间复杂度就是O（n）
```

### AVL树

```
（1）是一种自平衡二叉查找树，特点是保证任何节点的左右子树高度之差不超过 1，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。
（2）AVL树需要通过旋转来保持平衡，会有较大的计算开销而降低查找性能。
（3）每个树节点只存一个数据，而每次磁盘IO只能读取一个节点的数据，如果要查询的数据分布在多个节点，那么就需要进行多次磁盘IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。
```

### 红黑树 

```
（1）是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态
（2）红黑树不要求严格的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因


是一种自平衡二叉查找树，它通过引入额外的颜色属性（红或黑）来保持树的平衡，从而确保查找、插入和删除操作的高效性
特点：
（1）（颜色属性）节点非黑即红
（2）（根属性）根节点一定是黑色
（3）（叶子属性）叶子节点（NIL）一定是黑色
（4）（红色属性）每个红色节点的两个子节点，都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
（5）（黑色属性）从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。

https://javaguide.cn/database/mysql/mysql-index.html#红黑树
```

### B 树& B+树

```
（1）数据存放：
	- B 树的所有节点既存放键(key) 也存放数据(data)
	- B+树只有叶子节点存放 key 和 data，其他节点只存放 key。
	
（2）叶子结点
	- B 树的叶子节点都是独立的;
	- B+树的叶子节点有一条引用链指向与它相邻的叶子节点。

（3）范围查找：
	- 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；
	- B+树的范围查询，只需要对链表进行遍历即可。
	
（4）磁盘IO次数更少
	- B树的非叶子结点也存放数据，和B+树相比，相同的页大小（16kb）B+树就能存储更多的键值，树就会更矮更胖，这样一来，查找数据进行的磁盘IO次数也就会减少，效率更快。

https://javaguide.cn/database/mysql/mysql-index.html#b-树-b-树
```



## 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？ 

可以从这几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数等等。

为什么不是哈希结构？为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？

```
Hash
（1）Hash等值查询效率很高，但无法范围查询

 二叉树
 （1）极端情况下会退化为链表
 （2）数据量多时，磁盘IO多
 
 平衡二叉树
 （1）插入、更新时，需要左旋右旋维持平衡，维护代价大
 （2）数据量大，树的高度高，磁盘IO多
 
 B树
 （1）B+树只在在叶子节点存放数据，B树在非叶子节点也存放数据，存储相同数据量级别的情况下，B+树比B树低，磁盘IO次数更少。（innoDB页大小默认16kb，不存数据就能存更多键值）
 （2）B+树叶子结点用双向链表连接，适合范围查询、排序查找；B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。
```



参考：

-   [阿里一面](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247488130&idx=1&sn=2f225ba5100c882089eec8a2666fee54&chksm=cf21cdabf85644bd91c8f0bc223d883a53896f3bd71e06a4167e050155fe64f55872c7ad97d8&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)
-   [为什么 MySQL 喜欢 B+ 树？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247502168&idx=1&sn=ff63afcea1e8835fca3fe7a97e6922b4&scene=21#wechat_redirect)



## 索引的分类

```
按「数据结构」分类：B+tree索引、Hash索引、全文索引。
按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
按「字段个数」分类：单列索引、联合索引。
```



## 主键索引

```
主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。
```

##  二级索引

```
二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。

唯一索引，普通索引，前缀索引等索引属于二级索引。
```



## 聚簇索引与非聚簇索引

### 聚簇索引（聚集索引）

#### 是什么

```
索引结构和数据一起存放的索引，并不是一种单独的索引类型。（在B+树中就是非叶子节点存放索引，叶子节点存放索引 + 数据）

有哪些？
- 主键索引
```

#### 优缺点

```
优点：
（1）查询速度快：由于聚簇索引中的数据行与索引行存储在相同的位置，因此可以加快数据的检索速度。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。
（2）对排序查找和范围查找，由于数据行在物理上是相邻的，所以效率较高。

缺点：
（1）依赖性有序的数据。主键最好是整型，如果是字符串，需要在插入时排序，影响插入和查找的效率。
（2）增删改带索引代价大：聚簇索引的叶子节点存放着数据，索引列修改时，可能需要重新调整整个索引结构。
```

###  非聚簇索引（非聚集索引）

#### 是什么

```
索引结构和数据分开存放的索引，并不是一种单独的索引类型

有哪些？
- 二级索引(辅助索引)
```

#### 优缺点：

```
优点：
- 更新代价比聚簇索引小

缺点
- 依赖于有序的数据：跟聚簇索引一样，非聚簇索引也依赖于有序的数据
- 可能会二次查询(回表)： 当查到索引对应的指针或主键后，如果查询的数据不只是索引列，还需要根据指针或主键再到数据文件或表中查询。
```

### 非聚簇索引一定回表查询吗(覆盖索引)?

```
如果索引列包含要查询的内容，就不需要回表进行查询数据
```

### 聚集索引与非聚集索引的区别

```
（1）存储结构
		- 聚簇索引：数据表的记录和索引结构是一起存储的。表中的数据行是按照索引的顺序物理存储的
		- 非聚簇索引：索引结构和数据表记录是分开存储的。非聚集索引只包含索引字段和一个指针到实际记录或聚集索引的指针。
（2）数量：
		- 聚簇索引：每个数据表只能有一个聚集索引，因为数据的物理存储顺序只能有一种。
		- 非聚集索引：在大多数数据库中，一个数据表可以有多个非聚集索引。
```



## 覆盖索引和联合索引

### 索引覆盖

```
如果索引包含要查找的字段的值，就称为索引覆盖
```

### 联合索引

```
多个字段创建的索引叫联合索引，也叫 组合索引 或 复合索引。
```

#### 有这样一个sql，where a > 1 and b = 1 and c > 1怎么创建索引

```
创建联合索引：bca或者bac

需要考虑哪一列是最具选择性的，即能最有效地缩小结果集的范围。通常，等于操作(=)比范围操作(>, <)更具选择性。
```



### 最左前缀匹配原则

```
（1）在使用联合索引时，会根据索引中的字段顺序，从左至右依次到查询条件中去匹配。
（2）如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 >、<）才会停止匹配。
（3）对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

比如，如果创建了一个 (a, b, c) 联合索引，就相当于建了a, ab, abc三个索引。
（因为有优化器，a、b、c的顺序可以不固定）

可以利用联合索引：
where a=1；
where a=1 and b=2 and c=3；
where a=1 and b=2；

无法用联合索引：
where b=2；
where c=3；
where b=2 and c=3；

https://javaguide.cn/database/mysql/mysql-index.html#联合索引
https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ
```

如下语句需要执行多少次树的搜索

```
name,age字段加上联合索引索引
select * from employee where name like '小%' order by age desc;
```
![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/18/15225316923433731692343373583J1CqFv-640.png)

```
联合索引项是先按姓名name从小到大排序，如果名字name相同，则按年龄age从小到大排序。面试官要求查所有名字第一个字是“小”的人，SQL的like '小%'是可以用上idx_name_age联合索引的。

该查询会沿着idx_name_age索引树，找到第一个字是小的索引值，因此依次找到小军、小伦、小燕、，分别拿到Id=600、100、700，然后回三次表，去找对应的记录。
```

[参考](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247488130&idx=1&sn=2f225ba5100c882089eec8a2666fee54&chksm=cf21cdabf85644bd91c8f0bc223d883a53896f3bd71e06a4167e050155fe64f55872c7ad97d8&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)

## 索引下推

```
是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。

如select * from employee where name like '小%' and age=28 and sex='0';

查找到“小”字开头的数据id后就回表找出数据行，再去对比age、sex字段
索引下推就是会先做判断，直接过滤
```

## 千万级数据量的表添加索引，如何做？

```
给表添加索引的时候，是会对表加锁的。如果不谨慎操作，有可能出现生产事故的。可以参考以下方法：
1.先创建一张跟原表A数据结构相同的新表B。
2.在新表B添加需要加上的新索引。
3.把原表A数据导到新表B
4.rename新表B为原表的表名A，原表A换别的表名；
```

[参考](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247488130&idx=1&sn=2f225ba5100c882089eec8a2666fee54&chksm=cf21cdabf85644bd91c8f0bc223d883a53896f3bd71e06a4167e050155fe64f55872c7ad97d8&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)

## 正确使用索引的一些建议

### 选择合适的字段创建索引

```
（1）不为 NULL 的字段： 索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
（2）被频繁查询的字段： 我们创建索引的字段应该是查询操作非常频繁的字段。被作为条件查询的字段：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
（3）频繁需要排序的字段： 索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
（4）被经常频繁用于连接的字段：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。
```

### 被频繁更新的字段应该慎重建立索引

```
虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。
```

### 限制每张表上的索引数量

```
（1）索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。
（2）索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。
（3）因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。
```

### 尽可能的考虑建立联合索引而不是单列索引

```
（1）索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树
（2）如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。
（3）如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。
```

### 注意避免冗余索引

```
冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。
如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。
```

### 字符串类型的字段使用前缀索引代替普通索引

```
前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。
```

### 避免索引失效 x

```
索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：
（1）创建了联合索引，但查询条件未遵守最左匹配原则;（查询时的条件列不是联合索引中的第一个列，索引失效）
（2）在索引列上进行计算、函数、类型转换等操作;
（3）查询条件导致
    - 以 % 开头的 LIKE 查询比如 like '%abc';
    - 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;
		- 索引字段上使用 is not null，可能导致索引失效。（表中null较多就用索引）		
		- 索引字段上使用（!= 或者 < >，not in）时，可能会导致索引失效。	 
（4）发生隐式转换; 
		- 字符串和数字比较：select * from t_user where varchar类型 = 1300000001;
		- 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
		
https://xiaolincoding.com/mysql/index/index_lose.html#索引存储结构长什么样

```

[田螺：后端程序员必备：索引失效的十大杂症](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487958&idx=1&sn=ac9137cfed0b9383d87cd77a0f417487&chksm=cf21cefff85647e947e072765dea74f388c37d44d920e7f148e113a06ea42f7721058b14bb5b&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)



为什么索引字段上使用（!= 或者 < >，not in）时，可能会导致索引失效（ is not null 同理）

```
当你使用!=或<>时，你实际上是在查找除某个值之外的所有其他值。在许多情况下，MySQL认为最有效的方法是进行全表扫描而不是使用索引，特别是当这个值在表中不是很常见时。

当你使用IN操作符时，MySQL可能会选择使用索引进行范围扫描。但当你使用NOT IN时，它可能不会这样做，因为你正在查找的是一个值列表之外的所有值，这种情况下，全表扫描可能更加高效。
```



### 删除长期未使用的索引

```
删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。
MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用。
```

## 隐式转换 x

```
（1）当操作符左右两边的数据类型不一致时，会发生隐式转换。
（2）当 where 查询操作符左边为数值类型时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。
（3）当 where 查询操作符左边为字符类型时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。
（4）字符串转换为数值类型时，非数字开头的字符串会转化为0，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。
```



```
不转换：
（1）都是字符串，按字符串比，不做类型转换
（2）都是整数，按整数比，不做类型转换

转换：
（1）十六进制的值和非数字做比较时，会被当做二进制串
（2）有一个参数是timestamp或DATETIME，并且另外一个参数是常量，常量会被转换为timestamp
（3）有一个参数是decimal类型，如果另外一个参数是decimal或者整数，会将整数转换为decimal后进行比较；如果另外一个参数是浮点数，则会把decimal转换为浮点数进行比较
（4）所有其他情况下，两个参数都会被转换为浮点数再进行比较

转换规则：
（1）不以数字开头的字符串都将转换为0。如'abc'、'a123bc'、'abc123'都会转化为0；
（2）以数字开头的字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如'123abc'会转换为123，'012abc'会转换为012也就是12，'5.3a66b78c'会转换为5.3，其他同理。
```





## MySQL 使用 like “%x“，索引一定会失效吗？（最左匹配类似）

```
如：select * from s where name like "%xxx";
如果数据库里表s只有id字段和name字段，id为主键索引，name为二级索引
select * 就相当于 select id，name, 这个查询的数据都在二级索引的B+树上，所以直接在索引树上查找就行。
（因为二级索引的 B+ 树的叶子节点包含「索引值（name）+主键值」，所以查二级索引的 B+ 树就能查到全部结果了，这个就是覆盖索引。）

https://xiaolincoding.com/mysql/index/index_issue.html
```

为什么选择全扫描二级索引树，而不扫描聚簇索引树呢？

```
因为二级索引树的记录东西很少，就只有「索引列+主键值」，而聚簇索引记录的东西会更多，比如聚簇索引中的叶子节点则记录了主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列。

再加上，这个 select * 不用执行回表操作。

所以， MySQL 优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多，因此 MySQL 选择了「全扫描二级索引树」的方式查询数据。
```

为什么这个数据表加了非索引字段，执行同样的查询语句后，怎么变成走的是全表扫描呢？

```
加了其他字段后，select * from t_user where name like "%xx"; 要查询的数据就不能只在二级索引树里找了，得需要回表操作才能完成查询的工作，再加上是左模糊匹配，无法利用索引树的有序性来快速定位数据，所以得在二级索引树逐一遍历，获取主键值后，再到聚簇索引树检索到对应的数据行，这样实在太累了。

所以，优化器认为上面这样的查询过程的成本实在太高了，所以直接选择全表扫描的方式来查询数据。
```



## count(*)  &  count(1)  & count（id）& count(字段)

```
https://xiaolincoding.com/mysql/index/count.html
```

### count() 是什么？

```
统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。
```

### 哪种 count 性能最好？

```
count(*) = count(1) > count(主键字段) > count(字段)
```

### count(id) 执行过程是怎样的？

```
（1）在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。
（2）server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。
（3）最后将 count 变量的值发送给客户端。

读取数据时
如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，
然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。 【比count(1)多的一步，count(1)不需要读取id来判断】
但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。
```

为什么优先选二级索引？

```
这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。
```

### count(1) 执行过程是怎样的？

Count(1)是什么

```
统计「某表中，1 这个表达式不为 NULL 的记录」有多少个
1 这个表达式就是单纯数字，它永远都不是 NULL，所以其实是在统计表中有多少个记录。
count（id）需要读取id值后，判断id是不是null
```

流程

```
（1）如果表里只有主键索引，没有二级索引时。InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，「但是不会读取记录中的任何字段的值」。
因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。
```

### count（1）比count（id）效率高的原因

```
count(1) 相比 count(主键字段) 少一个步骤，不需要读取记录中的字段值来判断主键是否为null，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。
```

### count(*) 执行过程是怎样的？

```
当你使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理。
count(*) 执行过程跟 count(1) 执行过程基本一样的，性能没有什么差异
 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。
 只有当没有二级索引的时候，才会采用主键索引来进行统计。
```

### count(字段) 执行过程是怎样的？

```
如果字段没有索引，则会采用全表扫描
```

### cout为什么要通过遍历的方式来计数？

```
 MyISAM ：
 数据表都有一个 meta 信息有存储了row_count值，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果
 
 innodb：
 InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的
 所以需要扫描表来统计具体的记录。
```

### 如何优化 count(*)？

```
一张大表经常用 count(*) 来做统计，其实是很不好

（1）近似值：
如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，使用explain给出的搜索结果条数是一个大概值，explain并不会真正的去查询。
explain select count(*) from table_namel

（2）额外表保存计数值
如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。
当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。
```





## Explain执行计划

```
一般来说，我们需要重点关注type、rows、filtered、extra、key。

type
type表示连接类型，查看索引执行情况的一个重要指标。以下性能从好到坏依次：system  > const > eq_ref > ref  > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

（1）system：这种类型要求数据库表中只有一条数据，是const类型的一个特例，一般情况下是不会出现的。
（3）const：通过一次索引就能找到数据，一般用于主键或唯一索引作为条件，这类扫描效率极高，，速度非常快。
（3）eq_ref：常用于主键或唯一索引扫描，一般指使用主键的关联查询
（4）ref : 常用于非主键和唯一索引扫描。
（5）ref_or_null：这种连接类型类似于ref，区别在于MySQL会额外搜索包含NULL值的行
（6）index_merge：使用了索引合并优化方法，查询使用了两个以上的索引。
（7）unique_subquery：类似于eq_ref，条件用了in子查询
（8）index_subquery：区别于unique_subquery，用于非唯一索引，可以返回重复值。
（9）range：常用于范围查询，比如：between ... and 或 In 等操作
（10）index：全索引扫描
（11）ALL：全表扫描

 
rows
该列表示MySQL估算要找到我们所需的记录，需要读取的行数。对于InnoDB表，此数字是估计值，并非一定是个准确值。

key
该列表示实际用到的索引。一般配合possible_keys列一起看。

filtered
该列是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。
```

[参考](https://juejin.cn/post/7208571916154847288)
