## 执行一条查询语句流程

![查询语句执行流程](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/08/13522416914739441691473944041VX9yWt-mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

```
（1）连接器：简历连接，管理连接、校验用户身份
（2）查询缓存：如果命中，直接返回（mysql8.0后移除）
（3）解析器：
		- 词法分析：提取关键字、表名、字段名、查询条件
		- 语法分析：判断sql是否正确
（4）优化器：选择最优的方案执行：如何选择索引？如何关联表的顺序？
（5）执行器：调用引擎接口，返回结果
```



## update执行过程

```
走一遍查询流程
（1）先查询到张三这一条数据，如果有缓存，也是会用到缓存。
（2）然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。
（3）执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。
（4）更新完成。
```

```
当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。
具体更新一条记录 UPDATE t_user SET name = 'xiaolin' WHERE id = 1; 的流程如下:
（1）执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录
	- 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；
	- 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。
（2）执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：
	- 如果一样的话就不进行后续更新流程；
	- 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；
（3）开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。
（4）InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。
（5）至此，一条记录更新完了。
（6）在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。
（7）事务提交，「两阶段提交」
	- prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；
	- commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；

https://xiaolincoding.com/mysql/log/how_update.html#binlog-什么时候刷盘
```

## 一条sql语句的执行过程

<img src="/Users/kuan/Library/Application%20Support/typora-user-images/image-20230919230026533.png" alt="image-20230919230026533" style="zoom:50%;" />

https://mp.weixin.qq.com/s/JDGGcarGHkAVey9Ur0j9Rw



## InnoDB 与 MyISAM 的区别 x *

```
（1）事务：InnoDB 支持事务，拥有错误回滚的能力；MyISAM 不支持事务 
（2）锁：InnoDB 支持表、行级锁，拥有更好的并发性能；而 MyISAM 支持表级锁，锁的粒度较大。 
（3）崩溃恢复：InnoDB引引擎通过 redolog 日志实现了崩溃恢复，可以在数据库发生异常情况（如断电）时，通过日志文件进行恢复，保证数据的持久性和一致性。Myisam是不支持崩溃恢复的。
（4）MVCC：InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持 

InnoDB 支持外键，MyISAM 不支持外键 
select count(*) from table 时，MyISAM 更快，因为它有一个变量保存了整个 表的总行数，可以直接读取，InnoDB 就需要全表扫描。 
Innodb 不支持全文索引，而 MyISAM 支持全文索引（5.7 以后的 InnoDB 也支持 全文索引） 
InnoDB 表必须有主键，而 MyISAM 可以没有主键 Innodb 表需要更多的内存和存储，而 MyISAM 可被压缩，存储空间较小，。 
Innodb 按主键大小有序插入，MyISAM 记录插入顺序是，按记录插入顺序保存。 
```

[一条sql语句的执行过程](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd)



## in和exits的区别 TODO

```
in
是一个条件表达式，用于检查某个值是否存在于子查询或列表中返回的一组值中。
通常用于比较单个列的值。

EXISTS 
是一个布尔表达式，只用于检查子查询是否返回任何行，而不关心子查询返回的具体内容。
通常用于更复杂的条件或多列比较。
```

## 数据库自增主键可能遇到什么问题。

```
（1）使用自增主键对数据库做分库分表，可能出现诸如主键重复等的问题。解决方案的 话，简单点的话可以考虑使用 UUID 
（2）自增主键会产生表锁，从而引发问题 
（3）自增主键可能用完问题。
```

### mysql 的内连接、左连接、右连接有什么区别？

```
（1）Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集 
（2）left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配 的记录。 
（3）right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹 配的记录。
```

## 说一下数据库的三大范式

```
（1）第一范式：数据表中的每一列（每个字段）都不可以再拆分。 
（2）第二范式：在第一范式的基础上，分主键列完全依赖于主键，而不能是依赖于主键 的一部分。 
（3）第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其 他非主键。
```





## [MySQL事务的12连问，你顶得了嘛](https://juejin.cn/post/7204010536765194277) TODO

## [SQL优化13连问，收藏好](https://juejin.cn/post/7208571916154847288) TODO

https://juejin.cn/post/7199666255884009532

https://juejin.cn/post/7193682380077400122