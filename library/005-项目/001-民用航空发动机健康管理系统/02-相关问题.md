## 基本概念

### 数据源

```
是什么？
数据的来源，mysql、hbase、mongodb、minio桶

为什么？
数据采集时，和数据处理时需要从指定数据源中获取数据进行分析、存储或其他操作。
```

### 数据集模型

```

```

### 数据集

```

```

### 实体模型

```

```

### 实体

```

```

## 工作流引擎

### 节点

#### 任务节点

```
设置任务的标题、执行类型、算法分组、算法名称、处理节点
需要配置算法模型中定义的参数配置
```

#### 数据对象节点

```
任务节点的输入、输出配置
类型：实体、数据集、minio_file
```

#### 事件类节点

```
（1）定时事件：
（2）周期事件：
```

#### 逻辑类节点

```
（1）IF节点
（2）分支节点
（3）合并节点
```

#### 连线&线上条件

```

```

### 节点状态池

```
节点状态池包含了整个工作流中所有节点信息 & 一些api，包括基本信息，以及它的执行状态。
解析器解析json时会向状态池中初始化各节点的信息以及初始状态。

底层通过concurrentMap来实现
```

### 解析器

```
前端绘制完后返回一个json数据，解析器的作用就是去解析这个json文件，根据不同类型的节点，调用不同的解析器来解析并创建对应的类对象，并初始化到状态池中。

解析器采用了「工厂模式」+「策略模式」进行了优化，通过节点的type属性，来找到对应的解析器
```

### 监视器

```
在流程启动时会去开启，通过mqtt来实现，去监听指定的话题，包含三部分：
（1）控制台指令：在前端界面点击按钮传输的指令。比如暂停、恢复、停止
（2）节点状态更新：celery worker执行完某一个算法后，会发送状态更新指令，监视器接收到后去更新对应节点的状态。
（3）状态上报：前端是要实时监控引擎的执行过程，节点状态更新、引擎发送异常等需要往前端推送状态。
```



## 为什么用celery？

```
Celery 是一个分布式任务队列系统，它可以用于执行长时间运行或定期任务

（1）异步处理：当应用需要执行一个可能会耗时的操作时，如发送电子邮件或处理大量数据，可以使用 Celery 将这些操作作为一个后台任务进行，从而不会阻塞用户的请求。
（2）分布式执行：Celery 允许在多个机器、虚拟机或容器中分布式地执行任务。这对于需要大量计算资源或并行处理的应用程序非常有用。
（3）可靠性：如果一个工作者（worker）或任务失败，Celery 可以配置为重试任务，从而提供更高的可靠性。
（4）监控和管理：通过工具如 Flower，开发者和运维人员可以实时监控和管理 Celery 的任务和工作者状态。可以通过taskId终止任务
```



## 为什么选择Mqtt？

```
（1）轻量级协议：MQTT是一个轻量级的发布/订阅协议，特别适合于低带宽、高延迟或不稳定的网络环境。这使其成为物联网(IoT)设备间通讯的理想选择，在我们的系统中，需要对实验过程中产生的数据进行采集（快速存取记录器 QAR 和 ACARS），所以mqtt比较适合。
（2）MQTT支持三个不同的消息交付级别：0 (至多一次)，1 (至少一次)，2 (只有一次)。这为不同的应用场景提供了灵活性。
（3）持久会话：MQTT可以配置为持久会话，即当客户端掉线后，它可以再次上线并接收它错过的所有消息。
（4）集成和兼容性：许多IoT平台和设备已经内置了对MQTT的支持，这意味着在整合时可能会更加容易。

为什么不选kafka？
（1）Kafka的用途：虽然Kafka也是一个消息传递系统，但它主要用于大数据流处理和实时数据处理。它的设计目标是高吞吐量、持久性和分布式数据流。而MQTT更注重设备到设备或设备到服务器的通讯。
```

mqtt

```
MQTT（Message Queuing Telemetry Transport，消 是一种基于发布/订阅（publish/subscribe）模式的“轻量级”通讯协议。
最 大优点在于，用极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。
作为一种低开销、低带宽占用的即时通讯协议，使其在 物联网、小型设备、移动应用等方面有较广泛的应用。
```

kafka

```
Kafka 是一种高吞吐量的分布式发布订阅消息系统，
优势包括：
（1）高 吞吐量、低延迟：每秒可以处理几十万条消息，它的延迟最低只有几毫 秒；
（2）可扩展性：集群支持热扩展；
（3）持久性、可靠性：消息被 持久化到本地磁盘，并且支持数据备份防止数据丢失；
（4）容错性：允 许集群中节点故障（若副本数量为 n，允许 n-1 个节点故障）；
（5）高并发：支持数千个客户端同时读写。
```



## 什么选minio？不用fastDFS

### 什么是minio？

```
（1）MinIO是专门为海量数据存储、人工智能、大数据分析而设计的对象存储系统
（2）单个对象最大可达5TB。非常适合储海量图片、视频、日志文件、备份数据和容器/虚拟机镜像等
（3）MinIO主要采用Golang语言实现，整个系统都运行在操作系统的用户态空间，客户端与存储服务器之间采用HTTP/HTTPs通信协议。
```

### 为什么要用？

```
（1）安装部署简单，支持云容器化部署
（2）操作简单，自带ui管理界面。fastDFS默认没有
（3）性能优秀，可以达到每秒GB级别的读写速度
（4）提供了多语言SDK的支持，参考文档非常全面
（5）兼容亚马逊S3 API
		- 亚马逊云的 S3 API（接口协议） 是在全球范围内达到共识的对象存储的协议，是全世界认可的对象存储标准。而MinIO是第一个采用S3兼容协议的产品之一
		- 兼容S3 API有什么好处呢？相当于目前为了节约服务器成本，选择用MinIO自主开发对象存储系统，等企业壮大之后，不想再运维基础设施，可以直接将程序平移到云厂商，不需要重新开发。
```

[参考](https://juejin.cn/post/7115313166703132709)

hbase

```
HBase 是基于 Apache Hadoop 的面向列的 NoSQL 数据库，是 Google 的 BigTable 的开源实现。 HBase 是一个针对半结构化数据的开源的、 多版本的、可伸缩的、高可靠的、高性能的、分布式的和面向列的动态 模式数据库。支持存储并处理大型的数据，是仅用普通的硬件配置，就 能够处理上千亿的行和几百万的列所组成的超大型数据库。HBase 是可 以提供实时计算（占用大量的内存）的分布式数据库， 数据被保存在 HDFS 上，由 HDFS 保证其高容错性。
```



## 有什么难点

#### 难点1: 可拓展性

```
我们的系统需要集成很多算法，如果对于每个算法，我们都从头开始写编写，添加新的接口，写死在系统中，
那么我们就会和甲方一直的绑定在一起，很被动，无法脱身，只有他们有算法需求，我们就需要派人去给他们集成。
我们的想法是“能让他们自己玩，但又不能让他们脱离我们自己玩”，所以设计了这套分布式任务执行过程

我们运用了python的模块动态加载功能，结合celery写了一个统一的入口，叫run操作，
每一个算法都需要编写一个run方法，在执行过程中，通过文件名找到对应的算法，然后执行run方法，然后发布到worker中执行
每个算法的输入、输出有一套统一的规范，大家都遵循这个规范来开发，这样就能保证整个流程正常的运转
```

#### 难点2: 大文件的处理

```
实验过程中，会产生一些大文件非结构化数据，我们需要导入到系统中，来进行后面的处理分析流程
大文件上传就会存在很多问题，如果上传过程中因为网络等原因中断，那么我们就得重新来过，前面的操作就白费了

所以在文件的上传过程中进行了优化，通过文件分片上传、断点续传、文件秒传来优化上传过程
```

#### 难点3: 结构化数据的维度很多，难以复用

```
实验过程中产生的一些结构化数据维度很多，可能会有几百上千列，我们需要设计一种机制来管理好这些维度定义，并且能够复用、衍生、及溯源

我们就设计了实体模型（数据模型）这个概念，实体模型就是对数据列维度的定义，包括名称、类型等信息
多次实验列维度可能有所不同，就可以新建一个实体模型，集成原来的实体模型，然后进行修改
```

