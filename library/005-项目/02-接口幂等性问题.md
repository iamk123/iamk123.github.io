参考

-   [面试：如何保证接口的幂等性？常见的实现方案有哪些？](https://cloud.tencent.com/developer/article/1809887)
-   [如何保证接口的幂等性？](https://juejin.cn/post/7001667579991293989)
-   [高并发下如何保证接口的幂等性？](https://segmentfault.com/a/1190000039737646)



## 什么是幂等？

```
幂等表示一次和多次请求某一个资源应该具有同样的结果
```

## 幂等性问题

```
（1）如何防止接口的重复无效请求。
（2）每次请求的结果一样
```

## 为什么会产生接口幂等性问题

```
对于业务中需要考虑幂等性的地方一般都是接口的重复请求，重复请求是指同一个请求因为某些原因被多次提交。导致这种情况的发生有以下几种常见的场景：

（1）前端重复提交：
		用户在提交表单的时候，可能会因网络波动没有及时做出提交成功响应，致使用户认为没有成功提交，然后一直点提交按钮，这时就会发生重复提交表单请求。
		
（2）接口超时重试：
		第三方调用接口时候，为了超时等异常情况造成的请求失败，都会添加重试机制，导致一个请求提交多次。
		
（3）消息重复消费：
		当使用 MQ 消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。
```

### 防重设计 vs 幂等设计？

```
防重设计 和 幂等设计，其实是有区别的。
防重设计主要为了避免产生重复数据，对接口返回没有太多要求。
而幂等设计除了避免产生重复数据之外，还要求每次请求都返回一样的结果。
```



## 幂等性解决方案

```
前端
（1）前端控制
（2）token机制

数据库
（1）唯一索引
（2）悲观锁 
（3）乐观锁
（4）状态机

其他
（1）分布式锁
```



### 1 前端

#### 方案一：前端控制

在前端做拦截，比如按钮点击一次之后就置灰或者隐藏。但是往往前端并不可靠，还是得后端处理才更放心。

#### 方案二：Token机制

```
（1）客户端请求申请获取`token`：用户进入表单页面首先调用后台接口获取 token 并存入 redis
（2）提交表单时带上 token ，后端先删除 redis 中的 token，删除成功则保存表单数据，失败则提示用户重复提交。
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/03/14/23523816788091581678809158980IWA1pN-cc03edc216354a1b8b9923f47b51fc80~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" style="zoom: 67%;" />

为什么不先判断 redis 是否存在这个 token 再删除？

```
是因为要保证操作的原子性，极端情况下，第一个请求查询到 redis 中存在这个 token，还没来得及删除，第二个请求进来，也查询到 redis 中存在这个 token，那么还是会造成重复提交的问题。
```

存在的问题

```
token 机制需要先请求获取 token 的接口，在有些情况下很明显并不合适。我们大部分请求都是要落到数据库的，所以我们可以从数据库着手。
```

能不能改为“判断token是否存在来判断是不是第一次请求”？

```
https://segmentfault.com/a/1190000039737646
```



### 2 数据库

#### **方案一、唯一索引**

这种方案就比较好理解了，使用唯一索引可以避免脏数据的添加，当插入重复数据时数据库会抛异常，保证了数据的唯一性。唯一索引可以支持插入、更新、删除业务操作。

```
交易请求过来，我会先根据请求的唯一流水号 bizSeq字段，先select一下数据库的流水表
（1）如果数据已经存在，就拦截是重复请求，直接返回成功；
（2）如果数据不存在，就执行insert插入，如果insert成功，则直接返回成功，如果insert产生主键冲突异常，则捕获异常，接着直接返回成功。

如果重复请求的概率比较低的话，我们可以直接插入请求，利用主键/唯一索引冲突，去判断是重复请求。
```



#### **方案二、悲观锁**

这里所说的悲观锁是基于数据库层面的，在获取数据时进行加锁，当同时有多个重复请求时，其他请求都无法进行操作。悲观锁只适用于更新操作。

```mysql
// 例如
select name from t_goods where id=1 for update;

注意： id 字段一定要是主键或者唯一索引，不然会锁住整张表，这是会死人的。悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用。
```

问： 悲观锁怎么能防止重复数据提交，多个请求只有一个请求能进行操作，其他请求在等待，那么这个请求结束后，其他请求不还是进行了更新操作吗？

```
begin transaction
1.select * from order_info where id = "20201020" for update 加record lock
2.Java代码判断status == '初始' 执行3，否则返回
3.update order_info set status = '成功' where id = '20201020'并且发货
commit
```

[参考：**重复支付问题如何解决（悲观锁和乐观锁）**](https://blog.51cto.com/u_15127700/4540810)

-   https://mp.weixin.qq.com/s/UN0T80ygxnyCgnmrkpwtPg

**问题**

-   不适合高并发
-   只适用于更新操作

#### **方案三、乐观锁**

可以通过**版本号**实现，为表增加一个 version 字段，当数据需要更新时，先去数据库里获取此时的version版本号。

```mysql
select version from t_goods where id=1
复制代码
```

更新数据时首先要对比版本号，如果不相等说明已经有其他的请求去更新数据了，提示更新失败。

```mysql
update t_goods set count=count+1,version=version+1 where version=#{version}
```

问题

```
只适用于更新
```





#### 方案四 状态机

其实也是乐观锁的原理。这种方法适合在有状态流转的情况下，比如订单的创建和付款，订单的创建肯定是在付款之前，这时我们可以通过在设计状态字段时，使用 int 类型，并且通过值类型的大小来实现幂等性。

```mysql
update t_goods set status=#{status} where id=1 and status<#{status}
```

[更具体参考](https://segmentfault.com/a/1190000039737646)

为什么版本号建议自增的呢？

```
因为乐观锁存在ABA的问题，如果version版本一直是自增的就不会出现ABA的情况啦。
```







###  3 分布式锁

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/07/14161016940673701694067370830r5acTU-640.png" alt="图片" style="zoom:50%;" />

有时候我们的业务不仅仅是操作数据库，也可能是发送短信、消息等等，那数据库层面的锁就不适合了。这种情况下就要考虑代码层面的锁了，而 java 的自带的锁在分布式集群部署的场景下并不适用，那么就可以采用分布式锁来实现（Redis 或 Zookeeper）。

拿 Redis 分布式锁举例，比如一个订单发起支付请求，支付系统会去 Redis 缓存中查询是否存在该订单号的 Key，如果不存在，则以 Key 为订单号向 Redis 插入。查询订单是否已经支付，如果没有则进行支付，支付完成后删除该订单号的Key。通过 Redis 做到了分布式锁，只有这次订单支付请求完成，下次请求才能进来。当然这里需要设置一个Key 的过期时间，在发生异常的时候还要注意删除 Redis 的 Key。

https://juejin.cn/post/7127667756693979173

```
Redisson提供了一套功能丰富的分布式对象和服务，包括分布式锁、分布式集合、分布式队列等，可以更方便地实现分布式锁的功能。
```



参考

-   [高并发下如何保证接口的幂等性？](https://segmentfault.com/a/1190000039737646)
-   [田螺：聊聊幂等设计](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247497427&idx=1&sn=2ed160c9917ad989eee1ac60d6122855&chksm=cf2229faf855a0ecf5eb34c7335acdf6420426490ee99fc2b602d54ff4ffcecfdab24eeab0a3&token=2044040586&lang=zh_CN#rd)

