

## 主从模式

```
（1） 就是部署多台 Redis 服务器，有主库和从库，它们之间通过主从复制，以保证数据副本的一致。
（2） 主从库之间采用的是读写分离的方式，其中主库负责读操作和写操作，从库则负责 读操作。
（3） 如果 Redis 主库挂了，切换其中的从库成为主库。
```

### 什么是主从复制

```
主从复制是一种数据同步机制，用于将一台redis主节点的数据，复制到其他redis从节点中，尽可能保证数据的一致性。
```

### 作用

```
（1）性能：读写分离，性能拓展。Master以写为主，Slave以读为主
（2）容灾快速恢复：主服务器故障时，可以快速切换到从服务器继续提供服务，提高了系统的容灾能力。
（3）拓展性。通过添加更多的从服务器，可以水平拓展系统的读取性能和容量。
```

### 主从复制工作原理 TODO

```
（1）一个redis作为主服务器Master，负责处理所有的写操作和部分读操作
（2）其他多个redis服务器作为从服务器Slave，只负责读操作，并通过连接与主服务器建立连接，定期从主服务器同步数据，保持与主服务器数据的一致性。
```

### 复制原理 x *

https://developer.baidu.com/article/detail.html?id=294748

[小林coding](https://xiaolincoding.com/redis/cluster/master_slave_replication.html#第一次同步)

```
（1）建立连接：slave向master发生一个psync命令来建立与主服务器的连接。
		- 主服务器的 runID 和复制进度 offset
（2）快照传输：master收到命令后，会将当前的数据状态创建为一个rdb快照，并将快照发送给从服务器。在传输过程中，主服务器继续处理写入操作，但会将写入操作的数据缓存到内存缓冲区中
		- 用bgsave产生一个子进程生成rdb，不阻塞主进程
（3）命令传播：当快照传输完成后，主服务器会将内存缓冲区中缓存的写操作的数据（命令）发送给从服务器。从服务器接收到命令后，会按照接收到的顺序逐个执行，使得自己的数据状态与主服务器的数据状态一致
（4）增量同步：建立连接后，双方之间就维护了一个TCP链接，从服务器会持续接收主服务器的增量数据，并执行相应的操作，保证与主服务器数据的一致性。
```

```
分为全量同步、增量同步

（1）从服务器会定时发送同步数据的指令给主服务器，会携带主服务器的runID和上一次同步的数据偏移量。
（2）主收到后会判断实例id跟自己的实例id是否一致。
	- 如果不一致，说明没有同步过数据
	- 如果一致，说明同步过数据
（3）全量同步：不一致时，主会通过bgsave命令异步生成一个rdb快照给从服务器，从会基于rdb文件去加载新的数据。期间主服务器继续处理写入操作，但会将写入操作的数据缓存到内存缓冲区中，当快照传输完成后，主服务器会将内存缓冲区中缓存的写操作的数据（命令）发送给从服务器。从服务器接收到命令后，会按照接收到的顺序逐个执行，使得自己的数据状态与主服务器的数据状态一致。
（4）增量同步：如果一致，则通过偏移量去找相差的数据去同步。找相差的数据不是去所有的数据里找，而是在一个积压缓存的内存空间里面去找（这个积压缓存的大小也是可以设置的），里面保存的是最新的指令。如果积压缓存满了会覆盖之前。如果在积压缓存里面能找到相差的数据，则直接将相差的数据同步给从；如果找不到，则触发全量同步
```



### 读取从节点会读取到过期的数据吗

```
有可能
（1）情况1: 主节点的写操作（设置为过期），还没来得及通知从节点，此时读取从节点的数据就可能读取到过期数据。
（2）采用EXPIRE或者PEXPIRE设置过期时间到话，表示的是从执行这个命令开始往后TTL时间过期。所以从节点的过期时间会比主节点稍晚一些，在这期间读取从节点数据，则可能读到过期数据。（T3 - T4之间是过期）
可以使用ExpireAt 或者 PExpireAt, 注意主从节点的时钟要保持一致
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/06/15121216939843321693984332273ThVzGr-15223816902697581690269758998zYU9bf-image-20230725152238667.png" alt="image-20230725152238667" style="zoom:50%;" />

### 为什么全量复制用RDB而不用AOF？

```
本质在对比RDB和AOF
```

### 主从复制方案有什么痛点？

```
主从复制方案下，master发生宕机，需要手动将一台slave升级为master，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。人工干预会大大增加问题的处理时间以及出错的可能性。

可以使用redis哨兵来解决

https://www.yuque.com/snailclimb/mf2z3k/ks9olb19hc9wse5k#4193d6d4
```

### Redis主从节点是长连接还是短连接？

```
长连接
主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。
```

### 怎么判断 Redis 某个节点是否正常工作？

```
通过相互ping-pong心跳检测机制，如果一半以上的节点去ping一个节点时没有pong回应，集群就会认为这个节点挂掉了，就会断开连接

有两种心跳间隔：
（1）主节点默认每10s发一次ping，判断从节点的存活性和连接状态
（2）从节点每1s发送replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量，目的是为了：
	- 实时监测主从节点网络状态；
	- 上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。
```

### 主从复制架构中，过期key如何处理？

```
主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作。
```

### Redis 是同步复制还是异步复制？

```
Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点。
```

### 为什么会出现主从数据不一致？

```
主从数据不一致，就是指客户端从从节点中读取到的值和主节点中的最新值并不一致。
因为主从节点间的命令复制是异步进行的

具体来说：
主节点在收到新的写命令后，就会返回结果，并不是等从节点执行完之后再返回。
如果从节点还没有执行主节点同步过来的命令，主从节点间的数据就不一致了
```

### 如何应对主从数据不一致？

```
（1）可以换更好的硬件配置，保证网络畅通。
（2）可以开发一个外部程序来监控主从节点间的复制进度。
Redis 的 INFO replication 命令可以查看「主节点接收写命令的进度信息」和「从节点复制写命令的进度信息」，所以，我们就可以开发一个监控程序，先用 INFO replication 命令查到主、从节点的进度。
进度差值大于设定的阈值，就不让客户端从这个从节点读取数据
```

### 主从切换如何减少数据丢失？TODO

```

```

### 主从如何做到故障自动切换？

```
哨兵模式
```







## 哨兵模式 Sentinel

### 是什么

```
是redis的一种运行模式，这种模式下，提供一个或多个哨兵运行在独立的服务器上，它会定期监控redis主从节点的状态。当主节点发生故障时，哨兵会通过【选举机制】自动从从节点中选出一个新的主节点，并将其他节点切换为新主节点的从节点，从而实现自动故障转移。
```

### 为什么要有哨兵机制？

```
主从架构中，是读写分离的，如果主节点挂掉，那么就没法响应写操作，也就没法给从节点同步数据。
如果要恢复服务的话，需要人工介入，选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点
哨兵机制的作用就是实现「主从节点故障转移」
```

### 有什么用

```
（1）高可用性：监控redis实例状态，主节点宕机自动故障
（2）配置管理：可以对redis实例的配置进行管理，包括增删改实例的配置，无需手动修改配置文件。
（3）统一的访问地址：哨兵会提供一个统一的访问地址，客户端可以通过这个地址访问redis实例，而不用关心实际的主节点地址，主从切换时，客户端无需重新配置。
```

### 哨兵如何检测节点是否下线？

```
主观下线（SDOWN）: sentinel节点认为某个redis下线，但不确定，需要其他哨兵节点的投票
客观下线（ODOWN）：法定数量（通过为过半）的哨兵节点认为redis主节点已经下线，那就是真的下线。【只适用于主节点】

检测流程：
每个哨兵节点以每秒一次的频率向整个集群中的master、slave以及其他sentinel节点发送一个PING命令，规定时间没有进行有效回复则认为主观下线。

如果是slave节点下线，则无操作，因为对集群影响不大；如果是master，则会向其他哨兵发起命令，其他哨兵进一步确认。通常为半数的哨兵认定master下线，才判定为客观下线。
```

### 哨兵如何选出新的master？

```
slave必须是在线状态才能参加新的master选举

筛选规则（优先级依次降低）：
（1）slave优先级。数值越小优先级越大，0表示没有参选资格
（2）复制进度。数据完整度与旧master越接近的
（3）runid。选runid最小的
```

### 如何从哨兵集群中选出leader，进行主从故障转移？

```
哨兵集群确认有master客观下线之后，会开始故障转移流程，流程的第一步就是要在哨兵集群中选择一个leader，让leader来负责完成故障转移。
```

那谁来作为候选者呢？

```
leader的候选人就是那些判断主节点「客观下线」的哨兵
```

候选者如何选举成为 Leader？

```
候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。
每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。
那么在投票过程中，任何一个「候选者」，要满足两个条件：
（1）拿到「半数以上」的赞成票
（2）票数 > 哨兵配置文件中的quorum值
```

如果有多个候选者，怎么选？

```
如果某个时间点，刚好有两个哨兵节点判断到主节点为客观下线，那这时就有两个候选者

每位候选者都会先给自己投一票，然后向其他哨兵发起投票请求。
如果投票者先收到「候选者 A」的投票请求，就会先投票给它，如果投票者用完投票机会后，收到「候选者 B」的投票请求后，就会拒绝投票。这时，候选者 A 先满足了上面的那两个条件，所以「候选者 A」就会被选举为 Leader。
```

### 如何选择哨兵个数？

```
配置成单数，且大于等于3
quorum 的值建议设置为哨兵个数的二分之一加1

如果两个哨兵，拿不到半数以上的票，即两票，选不出leader
避免平票
```

### 主从故障转移的过程是怎样的？

```
第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。
第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；
第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；
第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；
```







## Redis集群（Cluster模式） TODO

https://www.yuque.com/snailclimb/mf2z3k/ikf0l2

### 是什么？

```
是一种去中心集群的集群，至少由三个master，每个master至少一个slave节点，它将数据分散存储在多个节点上，每个节点负责管理一部分数据，从而实现数据的水平分片和负载均衡。

slave不对外提供服务，主要是用来保障master的高可用，当master故障时替代它
```

### 为什么需要redis cluster？

```
现有方式存在的问题：
（1）高并发下，缓存数量可能很大，并发量要求很大
（2）主从复制和哨兵模式两种方案本质上都是通过增加master的副本slave数量来提高redis服务的整体可用性和读吞吐量（即每个服务器上的数据都是一样的），都不支持横向拓展来缓解压力以及解决缓存数据量过大的问题。
```

### 什么是slots？

```
一个redis集群包含16384个插槽，数据库中每个键都属于一个插槽。
要计算某个key应该分布到哪个哈希槽中，需要先对key计算CRC-16校验码，然后对16384取模
```

### 为什么是16384个插槽？ TODO

```
crc16算法产生的校验码有16位，理论上可以产生65536个值，
（1）哈希槽太大会导致心跳包太大，消耗太多带宽
（2）哈希槽总数越少，对存储哈希槽信息的bitmap压缩效果越好
（3）redis cluster的主节点通常不会拓展太多，16384个查希槽已经足够用了
```

### redis cluster是如何分片的？ TODO

```

```

