[Redis6视频笔记](https://zhangc233.github.io/2021/05/02/Redis/#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB)

[javaguide](https://javaguide.cn/database/redis/redis-questions-01.html#redis-除了做缓存-还能做什么)

https://www.yuque.com/snailclimb/mf2z3k/ikf0l2

c语言中文网http://c.biancheng.net/redis/slaveof.html

小林coding：https://xiaolincoding.com/redis/

## Redis基础

### 什么是 Redis？[x]

```
是一个开源的高性能键值存储数据库。

特点：
（1）高性能：Redis数据存储在内存中，因此具有非常快速的读写性能。
（2）数据结构丰富：Redis支持多种数据结构，可以满足不同类型的应用需求。
（3）支持持久化：Redis提供了持久化机制，可以将数据持久化到磁盘上，以便在重启后恢复数据。
（4）集群：Redis可以通过主从复制和分片等机制进行数据分布和高可用性的部署。
（5）支持事务：Redis支持简单的事务功能，可以保证一系列操作的原子性。
（6）支持发布订阅：Redis支持发布订阅模式，可以实现消息的发布和订阅机制。

Redis常被用作缓存、消息队列、分布式锁等场景下的数据存储和处理。它被广泛应用于各种Web应用、移动应用和分布式系统中，以提供高性能的数据存储和访问能力。

chatgpt
```

### 优缺点

```
（1）优点：同特点
（2）缺点：
		- 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
		- 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
```

### Redis 为什么这么快？ TODO

```
（1）内存存储：数据存储在内存中，读写速度快
（2）IO多路复用： Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用
（3）Redis 内置了多种优化过后的数据结构实现，性能非常高。

https://javaguide.cn/database/redis/redis-questions-01.html#redis-为什么这么快
Redis 为什么这么快，你知道 I/O 多路复用吗？：https://learnku.com/articles/73927
```

### 为什么要用 Redis/为什么要用缓存？

```
缓存的基本思想：
空间换时间，常见的还有索引、数据库表的冗余字段、CDN

（1）高性能。
	直接访问数据库，从磁盘中读取，速度较慢。redis基于内存，读写速度快。将高频且不经常改变的数据直接缓存，下次就可以直接从内存中读取，速度快
（2）高并发
	redis能够承受的请求远大于直接访问mysql。单台设备的redis的QPS是mysql的10倍，redis单机的qps能轻松破10w，而mysql单机的qps很难破1w

QPS（Query Per Second）：每秒钟处理完请求的次数
https://javaguide.cn/database/redis/redis-questions-01.html#为什么要用-redis-为什么要用缓存
```

### 既然Redis那么快，为什么不用它做主数据库，只用它做缓存？

```
虽然Redis非常快，但它也有一些局限性，不能完全替代主数据库。有以下原因：
（1）基于内存：内存昂贵，不适合做海量数据的存取
（2）事务处理：Redis只支持简单的事务处理，对于复杂的事务无能为力，比如跨多个键的事务处理。
（3）数据持久化：Redis是内存数据库，数据存储在内存中，如果服务器崩溃或断电，数据可能丢失。虽然Redis提供了数据持久化机制，但有一些限制。
（4）数据处理：Redis只支持一些简单的数据结构，比如字符串、列表、哈希表等。如果需要处理复杂的数据结构，比如关系型数据库中的表，那么Redis可能不是一个好的选择。
（5）数据安全：Redis没有提供像主数据库那样的安全机制，比如用户认证、访问控制等等。

因此，虽然Redis非常快，但它还有一些限制，不能完全替代主数据库。所以，使用Redis作为缓存是一种很好的方式，可以提高应用程序的性能，并减少数据库的负载。
```

### Memcached和Redis的区别？

```
（1）速度：Redis 的速度比 Memcached 快很多。
（2）数据结构：MemCached 数据结构单一，仅用来缓存数据，而 Redis 支持多种数据类型。
（3）持久化：MemCached 不支持数据持久化，重启后数据会消失。Redis 支持数据持久化。
（4）事务：Memcached不支持事务
（4）集群：Redis 提供主从同步机制和 cluster 集群部署能力，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。
（5）Redis 使用单线程的多路 IO 复用模型，Memcached使用多线程的非阻塞 IO 模型。（Redis6.0引入了多线程IO，用来处理网络数据的读写和协议解析，但是命令的执行仍然是单线程）
（6）value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。

https://mp.weixin.qq.com/s/CiFSsOx_g9g-0PUGXDuvcQ
```





### 缓存的分类

```
（1）本地缓存
（2）分布式缓存
```

#### 什么是本地缓存

```
本地缓存就是将数据暂时存在应用程序的本地内存中，
最大的优点就是速度非常快，不需要额外的网络开销
缺点就是消耗一定的内存空间、可能会导致数据一致性问题
```

#### 本地缓存实现方案

```
（1）JDK自带的HashMap、ConcurrentHashMap：只提供了缓存功能，没有过期时间、淘汰机制等
（2）Ehcache、Guava cache、spring cache。
		- Ehcache可以嵌入到hibernate和mybatis作为多级缓存，并且可以将缓存的数据持久化到本地磁盘
		- Guava cache提供api方便使用
		- spring cache：提供注解方式，代码干净，但容易出现缓存穿透、内存溢出等问题
（3）Caffeine。比Guava更方面性能更优秀
```

#### 本地缓存优劣？

```
优势：低依赖、轻量、简单、成本低
劣势：
	（1）与应用耦合，对分布式架构不友好。如同一个服务部署在多台机器，各服务之间的缓存无法共享。
	（2）内存受限：缓存容量受服务部署所在机器限制明显。当前系统服务所耗费的内存多，那本地缓存使用的容量就少
```

#### 什么是分布式缓存

```
是一种在分布式系统中使用的缓存技术，它将缓存数据分布在多个节点上，整体对外提供统一的访问接口，可以提高系统的性能、拓展性和可用性。
```

#### 分布式缓存优势

```
（1）高性能：分布式缓存通常使用高速的内存存储，能够快速响应数据请求，提供低延迟的数据访问。
（2）可拓展性：数据分布在多个节点上，可以通过添加节点的方式实现水平拓展
（3）高可用：通过复制和备份，即使某个节点发生故障，仍然可以从其他节点获取数据
```

#### 分布式缓存存在的问题

```
（1）系统复杂性增加：需要维护数据一致性、保证缓存服务的高可用
（2）成本增加：内存成本贵
```

#### 分布式缓存方案

```
（1）Memcached
（2）Redis
```

#### 多级缓存

```
本地缓存（第一级） + 分布式缓存（第二级），是最常用的多级缓存方式
读取缓存时先到本地缓存中读，读不到再二级缓存。这样可以降低二级缓存的压力，如果二级缓存也没有，则去查数据库，
查询成功后将数据写入一级、二级缓存中
```

#### 用了分布式缓存，为什么还要本地缓存？

```
本地缓存和分布式缓存都属于缓存，但本地缓存的速度远大于分布式缓存，因为不需要额外的网络开销
一般情况下不建议使用，需要维护一级缓存 和 二级缓存的一致性

适合多级缓存的场景
（1）缓存的数据不会频繁修改，比较稳定
（2）数据访问量特别大，比如秒杀场景

https://www.yuque.com/snailclimb/mf2z3k/fg8lgc
```



## Redis数据结构

### redis的数据结构有哪些

```
五种基础数据结构：
（1）字符串String：存储一个字符串值，可以是文本、整数、或二进制数
（2）哈希Hash：适用于存储对象的多个属性
（3）列表List：按照插入顺序存储一组有序值，可以在列表的两端进行元素的插入、删除
（4）集合Set：存储一组唯一的无序元素，支持集合的交集、并集、差集等操作
（5）有序集合ZSet：在集合的基础上，添加一个分数score属性，根据这个分数进行排序，支持根据分数范围进行元素的检索和排名

三种特殊结构：
（1）位图（Bitmap 2.2新增）
（2）HyperLogLogs（基数统计 2.8新增）：
（3）地理空间索引（Geospatial 3.2新增）：存储地理位置信息的数据结构，支持地理位置的存储、距离计算和范围查询。
（4）Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。

https://javaguide.cn/database/redis/redis-data-structures-01.html
https://javaguide.cn/database/redis/redis-data-structures-02.html
```

### 数据结构的应用场景

```
String 类型的应用场景：缓存对象、常规计数、分布式锁、共享session 信息等。
Hash 类型：缓存对象、购物车等。
Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
Zset 类型：排序场景，比如排行榜、电话和姓名排序等。
BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；
HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；
GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；
```

### 底层实现

```
https://xiaolincoding.com/redis/data_struct/data_struct.html
```

#### String TODO

描述

```
String 是最基本的 key-value 结构，key是唯一标识，value可以是数字、数字。
最多容纳的数据长度是512M
```

内部实现

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/03/15185116910471311691047131521d5hULY-sds.png" alt="img" style="zoom: 50%;" />

```
redis使用「简单动态字符串SDS」来表示字符串。动态字符串是一种可以自动调整长度的字符串，根据实际存储的数据进行调整。这就使得字符串的修改（增、删等）操作非常高效，无需频繁的进行内存的申请和释放

free:还剩多少空间
len:字符串长度
buf:存放的字符数组
```

使用场景

```
（1）共享session
（2）分布式锁
（3）计数器
（4）限流
```



#### Hash

```
底层由「压缩列表」或「哈希表」实现
- 如果哈希类型元素小于512个，所有值小于64字节，使用压缩列表
- 否则使用哈希表

redis7.0中，压缩列表数据结构已经废弃，交由listpack数据结构来实现
```





#### List

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/27/191613169313497316931349731258ewDaz-f46cbe347f65ded522f1cc3fd8dba549.png" alt="img" style="zoom:67%;" />

```
（redis3.2之前由「双向链表」或「压缩列表」实现
- 如果列表的元素个数 < 512, 每个元素的值都小于64字节 => 使用压缩列表
- 否则使用双向链表
redis3.2之后，由quicklist实现。）

redis是由quicklist实现
quicklist是由「压缩列表」和「双向链表」组成的混合体，它将链表按段切分，每一段使用「压缩列表」来紧凑存储。
每个压缩列表就是quicklist的一个节点，节点之间使用双向指针接起来

默认的单个ziplist长度为8k字节
```



#### Set

介绍

```
Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。
一个集合最多可以存储 2^32-1 个元素
Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。
```

内部实现

```
底层由「哈希表」或「整数集合」来实现
- 如果集合中的元素都是整数，且元素个数小于512，则使用「整数集合」
- 否则使用「哈希表」
```

应用场景

```
（1）存储的数据是「无序」并且「唯一」
（2）多个集合的交集、并集、差集

实际场景
（1）点赞
（2）共同好友、共同关注
（3）抽奖
```



#### ZSet

介绍

```
Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），
Zset每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。
```

内部实现

```
由「压缩列表」或「跳表」实现
- 如果有序集合元素小于128个，并且每个元素的值小于64字节，则使用压缩列表
- 否则使用跳表

redis7.0中，压缩列表数据结构已经废弃，交由listpack数据结构来实现
```

应用场景

```
需要展示最新列表、排行榜的场景
（1）排行榜
（2）电话、姓名排序
```

#### BitMap

介绍

```
即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。
BitMap通过最小的单位bit来进行0|1的设置，表示某个元素的值或者状态，时间复杂度为O(1)。

由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用二值统计的场景。
```

![image-20230827112314072](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/27/11231416931065941693106594317B4mVJ8-image-20230827112314072.png)

内部实现

```

```

应用场景

```
Bitmap 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 0 和 1 两种，在记录海量数据时，Bitmap 能够有效地节省内存空间。

（1）签到统计
（2）判断用户登陆状态
（3）连续签到用户总数
```

#### HyperLogLog

应用场景

```
（1）百万级网页 UV 计数
```

### Quicklist

是什么

```
redis是由quicklist实现
quicklist是由「压缩列表」和「双向链表」组成的混合体，它将链表按段切分，每一段使用「压缩列表」来紧凑存储。
每个压缩列表就是quicklist的一个节点，节点之间使用双向指针接起来

默认的单个ziplist长度为8k字节
```

插入

```
插入元素时，不会像普通链表那样，直接新建一个节点。而是会检查插入位置的压缩列表是否能容纳该元素：
- 如果能容纳就直接保存到quicklistNode结构里的压缩列表
- 如果不能，就会新建一个quicklistNode结构

quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。
```

为什么要有quicklist？

```
quicklist是「压缩列表」和「双向链表」的组合体
压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会有「连锁更新」的风险，一旦发生，会造成性能下降。

quicklist 解决办法，通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。
```



### 跳表

https://xiaolincoding.com/redis/data_struct/data_struct.html#%E8%B7%B3%E8%A1%A8

为什么要有跳表？

```
链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。
跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，这样的好处是能快读定位数据。
```

是什么

![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/27/19270816931356281693135628082nv8wiT-2ae0ed790c7e7403f215acb2bd82e884.png)

查找过程

```
查找一个元素时，会从最高层开始，逐一遍历每一层。
- 如果当前节点「小于」目标节点，跳表会访问该层的下一个节点，直到为null或者大于目标元素，然后回到上一个节点的下一层继续查找
```

更新、删除、插入 TODO

```

```

跳跃表节点层数设置

```
相邻层节点数通常是2:1，查找复杂度就可以降低到lg(N)
```

为什么用跳表而不用平衡树？

```
(1) 从内存占用上来比较，跳表比平衡树更灵活一些。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1/(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。
(2) 在做范围查找的时候，跳表比平衡树操作要简单。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。
(3) 从算法实现难度上来比较，跳表比平衡树要简单得多。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。
```







### set和list的区别

```
（1）List 可以存储重复元素，Set 只能存储非重复元素；
（2）List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。
```



### SortedSet和List异同点？

```
相同点：
（1）都是有序的；
（2）都可以获得某个范围内的元素。

不同点：
（1）实现
		- 列表基于链表实现，获取两端元素速度快，访问中间元素速度慢；
		- 有序集合基于散列表和跳跃表实现，访问中间元素时间复杂度是OlogN；
（3）列表不能简单的调整某个元素的位置，有序列表可以（更改元素的分数）；
（4）有序集合更耗内存。
```



### String 还是 Hash 存储对象数据更好呢？

```
String存储的是序列化后的对象数据，存放的是整个对象。
Hash是单独存储对象的每个字段，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。

String节省内存，约是Hash的一半
如果对象中的某些字段需要经常变动，或者需要经常查询对象中的个别字段信息，Hash适合

在绝大部分情况，我们建议使用 String 来存储对象数据即可
```

### 购物车信息用 String 还是 Hash 存储更好呢?

```
由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：

用户 id 为 key
商品 id 为 field，商品数量为 value
```

![Hash维护简单的购物车信息](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/02/10211516909428751690942875545HKxnFF-19015916893325191689332519632hGmU2k-hash-shopping-cart.png)

那用户购物车信息的维护具体应该怎么操作呢？

```

用户添加商品就是往 Hash 里面增加新的 field 与 value；
查询购物车信息就是遍历对应的 Hash；
更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；
删除商品就是删除 Hash 中对应的 field；
清空购物车直接删除对应的 key 即可。

javaGuide
```

### Set 的应用场景是什么？

```
Redis 中 Set 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet

常见应用场景：
（1）存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等等。
（2）需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。
（3）需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。
```

### 使用 Set 实现抽奖系统怎么做？

```
如果想要使用 Set 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：
SADD key member1 member2 ...：向指定集合添加一个或多个元素。
SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。
SRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。
```

### 使用 Bitmap 统计活跃用户怎么做？

```
Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。
你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。

如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。
SETBIT 20210308 1 1
SETBIT 20210308 2 1
SETBIT 20210309 1 1
```

### 使用 HyperLogLog 统计页面 UV 怎么做？

```

```



## Redis应用

### [Redis的常用场景有哪些?](https://www.javalearn.cn/#/doc/Redis/面试题?id=_6-redis的常用场景有哪些)

```
（1）缓存
（2）分布式锁
（3）限流
（4）消息队列
（5）延时队列
（6）分布式session
（7）复杂业务场景：排行榜、计数器、点赞、关注

https://javaguide.cn/database/redis/redis-questions-01.html#redis-除了做缓存-还能做什么
```

### Redis 可以做消息队列么？

```
可以做简单的消息队列，但不建议

（1）功能有限：相对于专门的消息队列中间件，redis提供的消息队列功能相对简单。缺少一些高级特性，如消息持久化、消息顺序保证、消息重试机制
（2）redis默认将数据存在内存中，如果故障或停机，可能会丢失数据
（3）拓展性：redis在处理大量消息时，可能会收到性能限制。当消息数量增长时，redis的单线程模型可能会成为瓶颈，影响吞吐量。redis6之后引入多线程模型，即redis线程池，一定程度上可以缓解，但并没有完全并行化处理所有请求，仍然存在一些串行化操作，如数据结构的修改操作疼需要进行同步。

chatgpt
```



### 分布式锁的实现方式有哪些？[*]

```
（1）基于数据库的分布式锁:
		- 通过在数据库中创建一个表，用于存放锁信息。当需要获取锁时，尝试在该表中插入一行数据，插入成功则获得锁，插入失败则等待或重试。
		- 也可以使用数据库的原生锁机制，例如MySQL的SELECT ... FOR UPDATE。
（2）基于Redis的分布式锁:
		- 使用Redis的SETNX命令（set if not exists）或者SET命令的NX选项来尝试获取锁。Redis的EXPIRE命令可以设置锁的超时时间，防止死锁。
		- Redlock算法是一种基于Redis的分布式锁算法，用于提高锁的可靠性。
```

###  如何基于 Redis 实现分布式锁？

```

```





## Redis持久化机制

### [Redis持久化机制？](https://www.javalearn.cn/#/doc/Redis/面试题?id=_8-redis持久化机制？)

```
redis提供了三种不同形式的持久化机制
（1）RDB（Redis DataBase）：快照
（2）AOF（Append Only File）：只追加文件
（3）混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；
```

### RDB

#### 是什么

```
是redis默认的持久化方式
在指定的时间间隔内，将内存中的数据集快照以二进制的形式写入磁盘，恢复时将快照文件读到内存中
```

#### 优缺点

```
（1）优点：适合大规模的数据恢复，对数据的完整性和一致性要求不高
（2）缺点：在一定间隔时间做一次备份，如果rdis意外down掉，会丢失最后一次快照后的所有修改
```

#### 备份是如何进行的

```
redis会单独创建fork一个子进程来持久化。首先将数据写入一个临时文件中，待持久化过程都结束了，再用这个文件替换上次持久化好的文件

https://zhangc233.github.io/2021/05/02/Redis/#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB
```

#### RDB 创建快照时会阻塞主线程吗？

```
Redis 提供了两个命令来生成 RDB 快照文件：
save : 在主线程生成rdb文件，会阻塞 Redis 主线程；
bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。
```

#### RDB 在执行快照的时候，数据能修改吗？

```
可以。在执行bgsave过程中，运用了「写时复制技术」，redis仍然可以继续处理操作命令

在执行bgsave过程中，会通过fork（）创建子进程创建快照。如果主进程执行写操作，被修改的数据会复制一份副本，然后bgsave子进程会把该副本数据写入RDB文件，在这个过程中，主线程仍然可以直接修改原来的数据
```



### AOF

#### 是什么 / AOF 日志是如何实现的？

```
以日志的形式来记录每个写操作（增量保存），将redis执行过的所有数据更新指令记录下来（读操作不记录），追加到AOF文件中。redis启动之初会读取该文件逐一执行命令来进行数据恢复
```

#### 优缺点

```
（1）优点：
		- 备份机制更文件，丢失数据的概率更低
（2）缺点
		- 比RDB更占空间
		- 恢复备份速度要慢
		- 每次读写都同步，会有一定的性能压力
```

#### AOF持久化流程 TODO

```
（1）命令追加：将所有写命令追加到AOF缓冲区中
（2）通过write（）系统调用将aof缓冲区中的数据写到aof文件中，此时数据并没有写到磁盘中，而是拷贝到了内核缓冲区，等待内核将数据写入磁盘
（3）根据写回策略，将数据写入硬盘中
（4）文件重写（rewrite）：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的
（5）重启加载（load）:当redis重启时，会重新加载AOF文件中的写操作恢复数据

```

#### 持久化策略 / AOF 写回策略有几种？

![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/04/10593616911179761691117976340S2YpGq-98987d9417b2bab43087f45fc959d32a-20230309232253633.png)

```
（1）appendfsync always：始终同步，每次 Redis 的写入都会立刻记入日志；性能较差但数据完整性比较好。
（2）appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。
（3）appendfsync no：redis 不主动进行同步，把同步时机交给操作系统。
```

#### AOF 为什么是在执行完命令之后记录日志？

```
关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志

为什么是在执行完命令之后记录日志呢？
（1）避免额外的检查开销，AOF记录日志不会对命令进行语法检查；如果先写再执行，命令语法有错误就会把错误命令记录到aof中，恢复数据时就会出错
（2）在命令执行完之后再记录，不会阻塞当前的命令执行。

这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：
（1）如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；
（2）可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。

javaguide
```

#### AOF 日志过大，会触发什么机制？

```
如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。

Redis 为了避免 AOF 文件越写越大，提供了「 AOF 重写机制」，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。

重写就是将多个键值对用一条命令记录
```

#### AOF 重写

```
当AOF变得太大时，redis会在后台的一个子进程中进行重写操作，避免对redis正常处理命令请求造成影响
AOF重写期间，redis会维护一个「AOF重写缓冲区」，该缓冲区会在子进程创建新的AOF文件期间，记录服务器执行的所有写命令。
当子进程创建完新的AOF文件后，服务器将重写缓冲区中的所有内容追加到新的AOF文件末尾。
最后替换旧的AOF文件，完成重写

https://javaguide.cn/database/redis/redis-persistence.html#aof-%E9%87%8D%E5%86%99%E4%BA%86%E8%A7%A3%E5%90%97
```

### AOF 和 RDB 同时开启，redis 听谁的？

```
AOF默认不开启，如果都开启，系统默认取AOF的数据
```

### AOF和RDB对比

```
RDB优势：
（1）RDB文件存储的内容是经过压缩的二进制数据，保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。
（2）使用RDB恢复数据，直接解析还原数据即可，非常快。而AOF需要一条一条执行，非常慢
（3）AOF需要选择合适的刷盘策略，如果刷盘策略选择不当的话，会影响Redis的正常运行。并且，根据所使用的刷盘策略，AOF的速度可能会慢于RDB

AOF优势：
（1）更安全。RDB会丢掉整个快照，而AOF可能只丢失一条命令或一秒钟内的数据

https://javaguide.cn/database/redis/redis-persistence.html#redis-4-0-%E5%AF%B9%E4%BA%8E%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96
```

### 如何选用

```
（1）对数据不敏感，选择RDB
（2）不建议单独使用AOF，因为是不是创建一个RDB快照可以进行数据库备份、更快的重启以及解决AOF引擎错误
（3）如果只是做纯内存缓存，可以都不用。
（4）安全性比较高，同时开启
```

### 混合持久化

#### 为什么会有混合持久化？

```
RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。
AOF 优点是丢失数据少，但是数据恢复不快。
混合持久化集成了两个的优点
```

#### 是什么？

```
混合持久化工作是在AOF日志重写过程中，当开启了混合持久化时，在AOF重写日志时，fork出来的子进程会先将与主线程共享的内存数据以RDB方式写入到AOF文件，然后主线程处理的操作会记录在重写缓冲区中，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。

AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。
```

#### 优点

```
混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。
```

#### 缺点

```
（1）AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；
（2）兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了
```



## 线程模型 TODO

https://mp.weixin.qq.com/s/oeOfsgF-9IOoT5eQt5ieyw

https://xiaolincoding.com/redis/base/redis_interview.html#redis-线程模型

### Redis 是单线程吗？

```
Redis 单线程指的是「接收客户端请求->解析 ->执行->内容返回」这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。

redis程序并不是单线程的，redis在启动时会启动后台线程（BIO）：
处理关闭文件、AOF 刷盘、释放内存（lazyfree 线程）

因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。
```

### Redis 单线程模式是怎样的？

```

```

### 讲讲Redis的线程模型？

```
https://mp.weixin.qq.com/s/CiFSsOx_g9g-0PUGXDuvcQ

https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-%E9%87%8D%E8%A6%81
```

### Redis 采用单线程为什么还这么快？

```
单线程的 Redis 吞吐量可以达到 10W/每秒

Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：
（1）都在内存中完成，并且采用了高效的数据结构
（2）Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。
（3）Redis 采用了 非阻塞的I/O 多路复用机制处理大量的客户端 Socket 请求。
IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。
#
```

### Redis 6.0 之前为什么使用单线程？

```
（1）单线程编程容易并且更容易维护；
（2）Redis 的性能瓶颈不在 CPU ，主要在内存和网络。CPU 并不是制约 Redis 性能表现的瓶颈所在，更多情况下是受到内存大小和网络I/O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题
（3）增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。
（4）多线程会带来线程不安全的情况；
```

### Redis 6.0 之后为什么引入了多线程？

```
（1）单线程无法利用多CPU
（1）为了提高网络 IO 读写性能。因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上，所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。但是对于命令的执行，Redis 仍然使用单线程来处理
```



## Redis事务

### 什么是redis事务？

```
redis事务就是提供了一种将多个命令请求打包的功能，然后按顺序的去执行，执行过程被打断。
与mysql不同的是，它不具备原子性
```

### 为什么不具备原子性

```
原子性：事务是最小的执行单位，它保证了事务中的操作要么都完成，要么都失败。
redis事务中，如果某个命令失败了，并不会影响事务继续执行，除了失败的命令，其它命令都能正常执行。
并且，redis事务是不支持回滚操作的。所以redis事务是不满足原子性的

https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97
```

### 为什么不支持回滚 x

```
redis官方的介绍是：redis开发者们觉得没有必要支持回滚，这样更简单便捷，性能也更好。
redis开发者们觉得即使命令执行错误，也应该在开发过程中就发现而不是在生产过程中
```

### Redis 事务支持持久性吗？

```
redis支持持久化，但redis事务不支持持久性
redis可以通过RDB、AOF或者两种方式混合进行持久化
redis事务在执行过程中，并不会立即将数据写入磁盘，而是先缓存在内存中，当事务执行完毕并成功提交时，才会将数据写入磁盘进行持久化存储。

这就以为着如果redis发生故障或意外宕机，事务中未提交的数据可能会丢失。只存在内存中，并没有持久化到磁盘中。

因此redis事务不具备持久性。
```

### 如何使用Redis事务？x

```
流程
（1）开始事务（Multi）
（2）命令入队（FIFO）：输入的命令都会依次进入命令队列中，但不会执行
（3）执行事务（Exec）：Redis 会将之前的命令队列中的命令依次执行
（4）取消事务（discard）

MULTI 命令用于标记事务的开始，
EXEC 命令用于执行事务中的命令，
WATCH 命令用于监视一个或多个键，如果被监视的键在事务执行期间被修改，则事务会被取消，
DISCARD 命令用于取消事务。
```

### 如何解决Redis事务的缺陷？

```
主要处理的是redis事务在原子性、隔离性、错误回滚方面的问题
可以使用lua脚本的方式解决。

利用lua脚本，可以批量执行多条redis命令，这些命令会被提交到redis服务器一次性执行完成，大幅减少网络开销。
一段lua脚本执行过程中不会有其他脚本或者redis命令执行，保证了操作不会被其他指令插入干扰。

如果执行期间出错，出错后的命令不会继续执行，但是出错前的命令是不会回滚的，所以也并不能完全保证redis事务的原子性。
```



## Redis性能优化

### 大量 key 集中过期问题 x

```
对于过期的key，redis使用定期删除 + 惰性删除两种策略
（1）响应慢：定期删除过程中，如果遇到大量key失效的情况，客户端必须等待清理完成，因为定期任务线程是在redis主线程中进行。会导致客户端请求不能被及时处理，响应比较慢。
（2）占内存：如果大量的key集中过期，但Redis没有及时清理它们，过期的key仍然会占用内存空间。这会导致Redis内存占用率上升，可能导致系统内存不足。
```

### 如何解决？

```
（1）给key设置随机过期时间。
（2）惰性删除。
```

### redis如何清理这些过期key？

```
定期删除：
（1）redis使用定时任务来主动查找并删除过期的键。默认每秒检查一定数量的过期键并删除。
（2）主线程执行定期任务，可能会导致客户端请求不能及时响应。

惰性删除：
（1）Redis 在访问某个键时，会先检查该键是否过期。如果键已过期，则会立即删除该键并返回空值。这种方式避免了在每个键上定期检查的开销，只在访问时进行检查和删除。
（2）采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。
（3）缺点：不能删除所有过期key
```



### Redis bigkey（大 Key）

#### 什么是 bigkey？

```
一个key对应的value所占的内存比较大，这个key就可以看成是bigkey

参考标准：
string类型的value超过10kb
符合类型的value包含元素超过5000个
```

#### bigkey 有什么危害？

```
bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。因此，我们应该尽量避免 Redis 中存在 bigkey。
```

#### 如何发现 bigkey？

```
（1）使用 Redis 自带的 --bigkeys 参数来查找。
（2）使用开源工具
```

#### 如何处理 bigkey？

```
（1）分割bigkey。分割成多个小的key，需要调整业务代码，不推荐
（2）优化数据结构
（3）持久化存储
（4）数据压缩
```



### Redis hotkey（热 Key）

#### 什么是 hotkey？

```
短时间内频繁访问的key
```

#### 有什么危害

```
（1）处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理
（2）如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。
```

#### 如何解决 hotkey？

```
（1）缓存预热：在系统启动或低峰期，提前加载热点数据到缓存中，避免热点数据在高峰期大量请求时才从后端存储加载。
（2）分布式缓存：使用分布式缓存，将热点数据分散到不同的缓存节点上，减轻单个缓存节点的压力。
（3）缓存穿透处理：使用布隆过滤器等技术，对查询请求进行预处理，判断请求的键是否存在于缓存中，不存在则直接拦截请求，避免穿透到后端存储。
（4）限流和熔断：对于大量请求访问同一个热点键，可以使用限流和熔断机制，控制请求的并发数或拒绝一部分请求，避免对后端存储造成过大压力。
（5）读写分离：主节点处理写请求，从节点处理读请求。
```



### 慢查询命令

#### 是什么

```
Redis 命令的执行可以简化为以下 4 步：
（1）发送命令
（2）命令排队
（3）命令执行
（4）返回结果

redis慢查询统计的是【命令执行】这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令
```

#### 为什么会有慢查询命令 x

```
redis中的大部分命令都是O（1）时间复杂度，但也会有部分O（n）时间复杂度的命令，例如：
KEYS *：会返回所有符合规则的 key。
HGETALL：会返回一个 Hash 中所有的键值对。
LRANGE：会返回 List 中指定范围内的元素。
SMEMBERS：返回 Set 中的所有元素。
SINTER/SUNION/SDIFF：计算多个 Set 的交集/并集/差集。

随着n的增大，执行的耗时也越长。

另外还有一些时间复杂度在O（N）之上的命令，例如：
（1）ZRANGE/ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。
（2）ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。

```

### Redis内存碎片

#### 是什么

```
已经分配的内存空间中存在未被使用的小块内存，这些小块内容无法被充分利用，导致整体内存利用率降低
随着内存碎片的不断积累，会导致内存碎片问题进一步加剧，导致「内存分配」和「回收」的性能下降
Redis内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。
```

#### 为什么会导致内存分配性能下降？x

```
因为系统需要寻找连续的内存块来满足分配请求，而内存碎片造成了空洞，增加了查找的复杂度
```

#### 为什么会有redis内存碎片？x

```
（1）内部原因：内存分配器无法做到按需分配，是按固定大小来分配内存空间。
		Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 jemalloc，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节......）来分配内存的

（2）频繁修改和删除Redis中的数据会产生内存碎片。
```

#### 详细说说为什么频繁修改 Redis 中的数据会产生内存碎片

```
修改时采用写时复制技术，修改流程：
（1）申请一块新的内存空间，大小与修改后的键值对大小相同（实际上可能会略大于）
（2）将原始键值对中的数据拷贝到新的内存空间中
（3）将新的内存空间作为键值对的值，替换原始的内存空间。

写时复制的优点在于：修改数据时保护了原始的内存空间，保证了读操作的并发安全性

频繁修改会导致问题：
写时复制需要申请新的内存空间，而旧的内存不会立即释放（只有当没有任何引用指向它时，它才会被垃圾回收释放掉），频繁写就会导致出现大量不连续的小块空闲内存
```



## RedLock TODO



## Redis集群

### 主从复制

#### 什么是主从复制

```
主从复制是一种数据同步机制，用于将一台redis主节点的数据，复制到其他redis从节点中，尽可能保证数据的一致性。
```

#### 作用

```
（1）读写分离，性能拓展。Master以写为主，Slave以读为主
（2）容灾快速恢复：主服务器故障时，可以快速切换到从服务器继续提供服务，提高了系统的容灾能力。
（3）拓展性。通过添加更多的从服务器，可以水平拓展系统的读取性能和容量。
```

#### 主从复制工作原理

```
（1）一个redis作为主服务器Master，负责处理所有的写操作和部分读操作
（2）其他多个redis服务器作为从服务器Slave，只负责读操作，并通过连接与主服务器建立连接，定期从主服务器同步数据，保持与主服务器数据的一致性。
```

#### 复制原理TODO: 

https://developer.baidu.com/article/detail.html?id=294748

```


（1）建立连接：slave向master发生一个sync命令来建立与主服务器的连接。
（2）快照传输：master收到命令后，会将当前的数据状态创建为一个快照，并将快照发送给从服务器。在传输过程中，主服务器继续处理写入操作，但会将写入操作的数据缓存到内存缓冲区中
（3）命令传播：当快照传输完成后，主服务器会将内存缓冲区中缓存的写操作的数据（命令）发送给从服务器。从服务器接收到命令后，会按照接收到的顺序逐个执行，使得自己的数据状态与主服务器的数据状态一致
（4）增量同步：建立连接后，从服务器会持续接收主服务器的增加数据，并执行相应的操作，保证与主服务器数据的一致性。
```

#### 读取从节点会读取到过期的数据吗

```
有可能
（1）情况1: 主节点的写操作（设置为过期），还没来得及通知从节点，此时读取从节点的数据就可能读取到过期数据。
（2）采用EXPIRE或者PEXPIRE设置过期时间到话，表示的是从执行这个命令开始往后TTL时间过期。所以从节点的过期时间会比主节点稍晚一些，在这期间读取从节点数据，则可能读到过期数据。（T3 - T4之间是过期）
可以使用ExpireAt 或者 PExpireAt, 注意主从节点的时钟要保持一致
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/07/25/15223816902697581690269758998zYU9bf-image-20230725152238667.png" alt="image-20230725152238667" style="zoom:50%;" />

#### 为什么全量复制用RDB而不用AOF？

```
本质在对比RDB和AOF
```

#### 主从复制方案有什么痛点？

```
主从复制方案下，master发生宕机，需要手动将一台slave升级为master，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。人工干预会大大增加问题的处理时间以及出错的可能性。

可以使用redis哨兵来解决

https://www.yuque.com/snailclimb/mf2z3k/ks9olb19hc9wse5k#4193d6d4
```

#### Redis主从节点时长连接还是短连接？

```
长连接
主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。
```

#### 怎么判断 Redis 某个节点是否正常工作？

```
通过相互ping-pong心跳检测机制，如果一半以上的节点去ping一个节点时没有pong回应，集群就会认为这个节点挂掉了，就会断开连接

有两种心跳间隔：
（1）主节点默认每10s发一次ping，判断从节点的存活性和连接状态
（2）从节点每1s发送replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量，目的是为了：
	- 实时监测主从节点网络状态；
	- 上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。
```

#### 主从复制架构中，过期key如何处理？

```
主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作。
```

#### Redis 是同步复制还是异步复制？

```
Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点。
```

#### 为什么会出现主从数据不一致？

```
主从数据不一致，就是指客户端从从节点中读取到的值和主节点中的最新值并不一致。
因为主从节点间的命令复制是异步进行的

具体来说：
主节点在收到新的写命令后，就会返回结果，并不是等从节点执行完之后再返回。
如果从节点还没有执行主节点同步过来的命令，主从节点间的数据就不一致了
```

#### 如何应对主从数据不一致？

```
（1）第一种方法，尽量保证主从节点间的网络连接状况良好，避免主从节点在不同的机房。
（2）第二种方法，可以开发一个外部程序来监控主从节点间的复制进度。
Redis 的 INFO replication 命令可以查看「主节点接收写命令的进度信息」和「从节点复制写命令的进度信息」，所以，我们就可以开发一个监控程序，先用 INFO replication 命令查到主、从节点的进度。
进度差值大于设定的阈值，就不让客户端从这个从节点读取数据
```

#### 主从切换如何减少数据丢失？TODO

```

```

#### 主从如何做到故障自动切换？

```
哨兵模式
```



### 哨兵模式 Sentinel

#### 是什么

```
是redis的一种运行模式，这种模式下，提供一个或多个哨兵运行在独立的服务器上，它会定期监控redis主从节点的状态。当主节点发生故障时，哨兵会通过【选举机制】自动从从节点中选出一个新的主节点，并将其他节点切换为新主节点的从节点，从而实现自动故障转移。
```

#### 为什么要有哨兵机制？

```
主从架构中，是读写分离的，如果主节点挂掉，那么就没法响应写操作，也就没法给从节点同步数据。
如果要恢复服务的话，需要人工介入，选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点
哨兵机制的作用就是实现「主从节点故障转移」
```

#### 有什么用

```
（1）高可用性：监控redis实例状态，主节点宕机自动故障
（2）配置管理：可以对redis实例的配置进行管理，包括增删改实例的配置，无需手动修改配置文件。
（3）统一的访问地址：哨兵会提供一个统一的访问地址，客户端可以通过这个地址访问redis实例，而不用关心实际的主节点地址，主从切换时，客户端无需重新配置。
```

#### 哨兵如何检测节点是否下线？

```
主观下线（SDOWN）: sentinel节点认为某个redis下线，但不确定，需要其他哨兵节点的投票
客观下线（ODOWN）：法定数量（通过为过半）的哨兵节点认为redis主节点已经下线，那就是真的下线。【只适用于主节点】

检测流程：
每个哨兵节点以每秒一次的频率向整个集群中的master、slave以及其他sentinel节点发送一个PING命令，规定时间没有进行有效回复则认为主观下线。

如果是slave节点下线，则无操作，因为对集群影响不大；如果是master，则会向其他哨兵发起命令，其他哨兵进一步确认。通常为半数的哨兵认定master下线，才判定为客观下线。
```

#### 哨兵如何选出新的master？

```
slave必须是在线状态才能参加新的master选举

筛选规则（优先级依次降低）：
（1）slave优先级。数值越小优先级越大，0表示没有参选资格
（2）复制进度。数据完整度与旧master越接近的
（3）runid。选runid最小的
```

#### 如何从哨兵集群中选出leader，进行主从故障转移？

```
哨兵集群确认有master客观下线之后，会开始故障转移流程，流程的第一步就是要在哨兵集群中选择一个leader，让leader来负责完成故障转移。
```

那谁来作为候选者呢？

```
leader的候选人就是那些判断主节点「客观下线」的哨兵
```

候选者如何选举成为 Leader？

```
候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。
每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。
那么在投票过程中，任何一个「候选者」，要满足两个条件：
（1）拿到「半数以上」的赞成票
（2）票数 > 哨兵配置文件中的quorum值
```

如果有多个候选者，怎么选？

```
如果某个时间点，刚好有两个哨兵节点判断到主节点为客观下线，那这时就有两个候选者

每位候选者都会先给自己投一票，然后向其他哨兵发起投票请求。
如果投票者先收到「候选者 A」的投票请求，就会先投票给它，如果投票者用完投票机会后，收到「候选者 B」的投票请求后，就会拒绝投票。这时，候选者 A 先满足了上面的那两个条件，所以「候选者 A」就会被选举为 Leader。
```

#### 如何选择哨兵个数？

```
配置成单数，且大于等于3
quorum 的值建议设置为哨兵个数的二分之一加1

如果两个哨兵，拿不到半数以上的票，即两票，选不出leader
避免平票
```

#### 主从故障转移的过程是怎样的？

```
第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。
第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；
第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；
第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；
```



### Redis集群（Cluster模式） TODO

https://www.yuque.com/snailclimb/mf2z3k/ikf0l2

#### 是什么？

```
是一种去中心集群的集群，至少由三个master，每个master至少一个slave节点，它将数据分散存储在多个节点上，每个节点负责管理一部分数据，从而实现数据的水平分片和负载均衡。

slave不对外提供服务，主要是用来保障master的高可用，当master故障时替代它
```

#### 为什么需要redis cluster？

```
现有方式存在的问题：
（1）高并发下，缓存数量可能很大，并发量要求很大
（2）主从复制和哨兵模式两种方案本质上都是通过增加master的副本slave数量来提高redis服务的整体可用性和读吞吐量，都不支持横向拓展来缓解压力以及解决缓存数据量过大的问题。
```

#### 什么是slots？

```
一个redis集群包含16384个插槽，数据库中每个键都属于一个插槽。
要计算某个key应该分布到哪个哈希槽中，需要先对key计算CRC-16校验码，然后对16384取模
```

#### 为什么是16384个插槽？ TODO

```
crc16算法产生的校验码有16位，理论上可以产生65536个值，
（1）哈希槽太大会导致心跳包太大，消耗太多带宽
（2）哈希槽总数越少，对存储哈希槽信息的bitmap压缩效果越好
（3）redis cluster的主节点通常不会拓展太多，16384个查希槽已经足够用了
```

#### redis cluster是如何分片的？ TODO

```

```



## 功能篇 TODO



## 面试篇 TODO



## Redis缓存 TODO

### 什么是缓存穿透、缓存击穿、缓存雪崩？

### 数据库和缓存一致性
