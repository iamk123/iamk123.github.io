## 3种常用的缓存读写策略

```
(1) Cache Aside Pattern（旁路缓存模式）
(2) Read/Write Through Pattern（读写穿透）
(3) Write Behind Pattern（异步缓存写入）
```

### Cache Aside Pattern（旁路缓存模式）

![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/19/11485216924169321692416932252IjV7I7-cache-aside-read.png)

```
是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。

读：
- 先读缓存，有则直接返回
- 没有缓存，从db加载，再存入缓存

写：
- 先更新数据库，再删缓存
```

###  Read/Write Through Pattern（读写穿透）

```
把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。

读 （与旁路缓存相同）
- 先读缓存，有则直接返回
- 没有缓存，从db加载，在写缓存

写
- 先查缓存，缓存不存在，直接更新db
- 缓存存在，则更新缓存，然后缓存服务器自己更新db（同步更新 cache 和 db）
```

### Write Behind Pattern（异步缓存写入）

```
与「读写穿透」很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。

区别：
- 读写穿透： 同步更新 cache 和 db
- 异步缓存写入： 只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。

问题：
对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。

应用场景：
- 消息队列中消息的异步写入磁盘、
- MySQL 的 Innodb Buffer Pool 机制

优点：
- db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。
```

参考

-   [3种常用的缓存读写策略详解](https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html)
-   [美团二面：Redis与MySQL双写一致性如何保证？](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247490243&idx=1&sn=ff11c3aab9ada3b16d7f2b57c846d567&chksm=cf21c5eaf8564cfc59e3d0d56fd02b0f5513015005f498381be4d12db462442a49aabe4159ef&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)





## 问题背景

使用缓存的常见方式

```
用户请求过来之后，先查缓存有没有数据，如果有则直接返回。
如果缓存没数据，再继续查数据库。
如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。
如果数据库也没数据，则直接返回空。
```

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/10015016860169101686016910255xZYvGL-640.png" alt="图片" style="zoom:50%;" />

存在的问题：

```
如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？

不更新缓存行不行？
答：当然不行，如果不更新缓存，在很长的一段时间内（决定于缓存的过期时间），用户请求从缓存中获取到的都可能是旧值，而非数据库的最新值。这不是有数据不一致的问题？
```

更新缓存的4种方案

```
先写缓存，再写数据库
先写数据库，再写缓存
先删缓存，再写数据库
先写数据库，再删缓存
```

## 更新缓存方式

### 1 先写缓存，再写数据库

#### 问题1：写数据库失败

```
某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了，缓存就变成脏数据了
```

#### 问题2: 高并发问题 「写 + 写」

![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/07/16323216913971521691397152901apgCcz-454a8228a6549176ad7e0484fba3c92b.png)

### 2 先写数据库，再写缓存

#### 问题1：写缓存失败

```
在写缓存过程中，出现网络异常导致写缓存失败
数据库数据已更新，但缓存中还是旧值
```

#### 问题2：高并发下的问题「写 + 写」

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/07/16315616913971161691397116319PcRbDl-8febac10b14bed16cb96d1d944cd08da.png" alt="图片" style="zoom:50%;" />

假设在高并发的场景中，针对同一个用户的同一条数据，有两个写数据请求：a和b，它们同时请求到业务系统。

其中请求a获取的是旧数据，而请求b获取的是新数据，如下图所示：

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/101057168601745716860174573311V2LXi-640-20230606101057189.png" alt="图片" style="zoom:50%;" />

1.  请求a先过来，刚写完了数据库。但由于网络原因，卡顿了一下，还没来得及写缓存。
2.  这时候请求b过来了，先写了数据库。
3.  接下来，请求b顺利写了缓存。
4.  此时，请求a卡顿结束，也写了缓存。

很显然，在这个过程当中，请求b在缓存中的`新数据`，被请求a的`旧数据`覆盖了。

也就是说：在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。

#### 问题3：浪费系统资源

```
对于写多读少的业务，每次写操作都需要写缓存，比较浪费系统资源。
```

### 3 先删缓存，再写数据库

#### 问题1：「写+读」并发问题（未写就读）

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/07/16353016913973301691397330391pr2kJd-cc208c2931b4e889d1a58cb655537767.png" alt="图片" style="zoom:50%;" />

假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求c，还有另一个写数据请求d（一个更新操作），同时请求到业务系统。如下图所示：

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/06/06/10193316860179731686017973114G7KgaY-image-20230606101932996.png" alt="image-20230606101932996" style="zoom:50%;" />

```
请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。
这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。
请求c将数据库中的旧值，更新到缓存中。
此时，请求d卡顿结束，把新值写入数据库。

总结：d删完缓存没写完数据库c就已经读数据了，读的就是mysql的旧值并存到缓存中
```



#### 改进：延迟双删

```
写数据库之前删除一次，写完数据库后，延迟再删除一次。

流程：（请求d-写操作，请求c-读操作）
请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。
这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。
请求c将数据库中的旧值，更新到缓存中。
此时，请求d卡顿结束，把新值写入数据库。
一段时间之后，比如：500ms，请求d将缓存删除。
```

#### 为什么一定要间隔一段时间之后，才能删除缓存呢？



```
请求d卡顿结束，把新值写入数据库后，请求c将数据库中的旧值，更新到缓存中。
此时，如果请求d删除太快，在请求c将数据库中的旧值更新到缓存之前，就已经把缓存删除了，这次删除就没任何意义。必须要在请求c更新缓存之后，再删除缓存，才能把旧值及时删除了。
所以需要在请求d中加一个时间间隔，确保请求c，或者类似于请求c的其他请求，如果在缓存中设置了旧值，最终都能够被请求d删除掉。
```

#### 问题2: 第二次删除缓存失败

```
下方：缓存删除失败
```



### 4 先写数据库，再删缓存

在高并发的场景中，有一个读数据请求，有一个写数据请求，更新过程如下：

1.  请求e先写数据库，由于网络原因卡顿了一下，没有来得及删除缓存。
2.  请求f查询缓存，发现缓存中有数据，直接返回该数据。
3.  请求e删除缓存。

在这个过程中，只有请求f读了一次旧数据，后来旧数据被请求e及时删除了，看起来问题不大。

但如果是读数据请求先过来呢？

1.  请求f查询缓存，发现缓存中有数据，直接返回该数据。
2.  请求e先写数据库。
3.  请求e删除缓存。

这种情况看起来也没问题呀？

#### 问题1: 「读+写」并发问题

在实际中，这个问题出现的概率并不高** 因为缓存的写入通常要远远快于数据库的写入

![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/07/16372416913974441691397444937NW2Zql-1cc7401143e79383ead96582ac11b615.png)

#### 问题2: 缓存删除失败

```

```



### 缓存删除失败

### 定时任务

```
删除失败就加入定时任务列表
```

#### 增加重试机制

```
在接口中如果更新了数据库成功了，但更新缓存失败了，可以立刻重试3次。如果其中有任何一次成功，则直接返回成功。如果3次都失败了，则写入数据库，准备后续再处理。
当然，如果你在接口中直接同步重试，该接口并发量比较高的时候，可能有点影响接口性能。
```

#### 改进：异步重试 - 消息队列

![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/07/16460316913979631691397963937bRXWVk-640.png)

```
（1）当用户操作写完数据库，但删除缓存失败了，产生一条mq消息，发送给mq服务器。
（2）mq消费者读取mq消息，重试5次删除缓存。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则写入死信队列中。
（3）推荐mq使用rocketmq，重试机制和死信队列默认是支持的。使用起来非常方便，而且还支持顺序消息，延迟消息和事务消息等多种业务场景。

https://mp.weixin.qq.com/s/DsZgnwIqW3jrE5KxShGKeg
```

#### 监听binlog 

为什么

```
（1）在使用定时任务的方案中，需要在业务代码中增加额外逻辑，如果删除缓存失败，需要将数据写入重试表。
（2）使用mq的方案中，如果删除缓存失败了，需要在业务代码中发送mq消息到mq服务器。
（3）更优雅的实现，即监听binlog
```

`canal`等中间件

![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/07/16513716913982971691398297573N41sxJ-640-20230807165137443.png)

```
（1）在业务接口中写数据库之后，就不管了，直接返回成功。
（2）mysql服务器会自动把变更的数据写入binlog中。
（3）binlog订阅者获取变更的数据，然后删除缓存。

如果删除失败，则用前文的重试机制
```

![图片](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/07/16522316913983431691398343280ya4mjs-640-20230807165223151.png)



## 其他

### 为什么是删除缓存，而不是更新缓存呢？

```
（1）删除一个数据，相比更新一个数据更加轻量级，出问题的概率更小。
（2）在实际业务中，缓存的数据可能不是直接来自数据库表，也许来自多张底层数据表的聚合。


https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#读者提问
```

### Canal 中间件

```
阿里巴巴开源的 Canal 中间件

Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。

https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#如何保证两个操作都能执行成功
```

canal的工作原理

<img src="https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/08/07/16571516913986351691398635006rx6QO2-2ee2280e9f59b6b4879ebdec6eb0cf52.png" alt="图片" style="zoom:50%;" />



### 参考

-   [如何保证数据库和缓存双写一致性？](https://mp.weixin.qq.com/s/DsZgnwIqW3jrE5KxShGKeg)
-   [江南一点雨：如何保证缓存和数据库的一致性？](https://mp.weixin.qq.com/s/7-vUDQGj8mZIeryZA3gEiw)
-   [数据库和缓存如何保证一致性？](https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#如何保证两个操作都能执行成功)
-   [田螺：Redis与MySQL双写一致性如何保证？](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247490243&idx=1&sn=ff11c3aab9ada3b16d7f2b57c846d567&chksm=cf21c5eaf8564cfc59e3d0d56fd02b0f5513015005f498381be4d12db462442a49aabe4159ef&token=1495321435&lang=zh_CN&scene=21#wechat_redirect)