## Redis持久化机制 *

### [Redis持久化机制？](https://www.javalearn.cn/#/doc/Redis/面试题?id=_8-redis持久化机制？)

```
redis提供了三种不同形式的持久化机制
（1）RDB（Redis DataBase）：快照
（2）AOF（Append Only File）：只追加文件
（3）混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；
```

### RDB

#### 是什么

```
将某一时刻的所有数据以二进制的形式写入到文件中，恢复时将快照文件读到内存中
```

#### 优缺点

```
（1）优点：适合大规模的数据恢复，对数据的完整性和一致性要求不高
（2）缺点：在一定间隔时间做一次备份，如果rdis意外down掉，会丢失最后一次快照后的所有修改
```

#### 备份是如何进行的

```
redis会单独创建fork一个子进程来持久化。首先将数据写入一个临时文件中，待持久化过程都结束了，再用这个文件替换上次持久化好的文件

https://zhangc233.github.io/2021/05/02/Redis/#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB
```

#### RDB 创建快照时会阻塞主线程吗？

```
Redis 提供了两个命令来生成 RDB 快照文件：
save : 在主线程生成rdb文件，会阻塞 Redis 主线程；
bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。
```

#### RDB 在执行快照的时候，数据能修改吗？

```
可以。在执行bgsave过程中，运用了「写时复制技术」，redis仍然可以继续处理操作命令

在执行bgsave过程中，会通过fork（）创建子进程创建快照。如果主进程执行写操作，被修改的数据会复制一份副本，然后bgsave子进程会把该副本数据写入RDB文件，在这个过程中，主线程仍然可以直接修改原来的数据
```



### AOF

#### 是什么 / AOF 日志是如何实现的？

```
以日志的形式来记录每个写操作（增量保存），将redis执行过的所有数据更新指令记录下来（读操作不记录），追加到AOF文件中。redis启动之初会读取该文件逐一执行命令来进行数据恢复
```

#### 优缺点

```
（1）优点：
		- 备份机制更文件，丢失数据的概率更低
（2）缺点
		- 比RDB更占空间
		- 恢复备份速度要慢
		- 每次读写都同步，会有一定的性能压力
```

#### AOF持久化流程 x

```
（1）命令追加：将所有写命令追加到AOF缓冲区中
（2）通过write（）系统调用将aof缓冲区中的数据写到aof文件中，此时数据并没有写到磁盘中，而是拷贝到了内核缓冲区，等待内核将数据写入磁盘
（3）根据写回策略，将数据写入硬盘中
（4）文件重写（rewrite）：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的
（5）重启加载（load）:当redis重启时，会重新加载AOF文件中的写操作恢复数据

```

#### 持久化策略 / AOF 写回策略有哪些？

![img](https://cdn.jsdelivr.net/gh/iamk123/typora@main/uPic/2023/09/06/15134416939844241693984424984DMkNkL-10593616911179761691117976340S2YpGq-98987d9417b2bab43087f45fc959d32a-20230309232253633.png)

```
（1）appendfsync always：
	- 始终同步，每次写操作命令执行完成，同步将AOF数据写回硬盘
	- 性能较差但数据完整性比较好。
（2）appendfsync everysec：
	- 每秒同步，每次写操作执行完后，先将命令写到AOF文件的内核缓冲区，每隔一秒将缓冲区内容写回硬盘。（异步任务执行fsync() 函数刷盘）
	- 如果宕机，本秒的数据可能丢失。
（3）appendfsync no：
	- 不主动进行同步，把同步时机交给操作系统。
```

#### AOF 为什么是在执行完命令之后记录日志？

```
关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志

为什么是在执行完命令之后记录日志呢？
（1）避免额外的检查开销，AOF记录日志不会对命令进行语法检查；如果先写再执行，命令语法有错误就会把错误命令记录到aof中，恢复数据时就会出错
（2）在命令执行完之后再记录，不会阻塞当前的命令执行。

这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：
（1）如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；
（2）可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。

javaguide
```

#### AOF 日志过大，会触发什么机制？

```
如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。

Redis 为了避免 AOF 文件越写越大，提供了「 AOF 重写机制」，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。

重写就是将多个键值对用一条命令记录
```

#### AOF 重写

```
当AOF变得太大时，redis会在后台的一个子进程中进行重写操作，避免对redis正常处理命令请求造成影响
AOF重写期间，redis会维护一个「AOF重写缓冲区」，该缓冲区会在子进程创建新的AOF文件期间，记录服务器执行的所有写命令。
当子进程创建完新的AOF文件后，服务器将重写缓冲区中的所有内容追加到新的AOF文件末尾。
最后替换旧的AOF文件，完成重写

https://javaguide.cn/database/redis/redis-persistence.html#aof-%E9%87%8D%E5%86%99%E4%BA%86%E8%A7%A3%E5%90%97
```

### AOF 和 RDB 同时开启，redis 听谁的？

```
AOF默认不开启，如果都开启，系统默认取AOF的数据
```

### AOF和RDB对比

```
RDB优势：
（1）RDB文件存储的内容是经过压缩的二进制数据，保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。
（2）使用RDB恢复数据，直接解析还原数据即可，非常快。而AOF需要一条一条执行，非常慢
（3）AOF需要选择合适的刷盘策略，如果刷盘策略选择不当的话，会影响Redis的正常运行。并且，根据所使用的刷盘策略，AOF的速度可能会慢于RDB

AOF优势：
（1）更安全。RDB会丢掉整个快照，而AOF可能只丢失一条命令或一秒钟内的数据

https://javaguide.cn/database/redis/redis-persistence.html#redis-4-0-%E5%AF%B9%E4%BA%8E%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96
```

### 如何选用

```
（1）对数据不敏感，选择RDB
（2）不建议单独使用AOF，因为是不是创建一个RDB快照可以进行数据库备份、更快的重启以及解决AOF引擎错误
（3）如果只是做纯内存缓存，可以都不用。
（4）安全性比较高，同时开启
```

### 混合持久化

#### 为什么会有混合持久化？

```
RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。
AOF 优点是丢失数据少，但是数据恢复不快。
混合持久化集成了两个的优点
```

#### 是什么？

```
混合持久化工作是在AOF日志重写过程中，当开启了混合持久化时，在AOF重写日志时，fork出来的子进程会先将与主线程共享的内存数据以RDB方式写入到AOF文件，然后主线程处理的操作会记录在重写缓冲区中，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。

AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。
```

#### 优点

```
混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。
```

#### 缺点

```
（1）AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；
（2）兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了
```

### 大key会有什么问题？ TODO

```
https://xiaolincoding.com/redis/storage/bigkey_aof_rdb.html#%E5%A4%A7-key-%E5%AF%B9-aof-%E6%97%A5%E5%BF%97%E7%9A%84%E5%BD%B1%E5%93%8D
```

